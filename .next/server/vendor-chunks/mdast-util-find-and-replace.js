"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-find-and-replace";
exports.ids = ["vendor-chunks/mdast-util-find-and-replace"];
exports.modules = {

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndReplace: () => (/* binding */ findAndReplace)\n/* harmony export */ });\n/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! escape-string-regexp */ \"(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-is */ \"(rsc)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */ /**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */ \n\n\nconst own = {}.hasOwnProperty;\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */ // To do: next major: remove `find` & `replace` combo, remove schema.\nconst findAndReplace = /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/ /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */ function(tree, find, replace, options) {\n    /** @type {Options | null | undefined} */ let settings;\n    /** @type {FindAndReplaceSchema|FindAndReplaceList} */ let schema;\n    if (typeof find === \"string\" || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [\n            [\n                find,\n                replace\n            ]\n        ];\n        settings = options;\n    } else {\n        schema = find;\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace;\n    }\n    if (!settings) {\n        settings = {};\n    }\n    const ignored = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_1__.convert)(settings.ignore || []);\n    const pairs = toPairs(schema);\n    let pairIndex = -1;\n    while(++pairIndex < pairs.length){\n        (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, \"text\", visitor);\n    }\n    // To do next major: don’t return the given tree.\n    return tree;\n    /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */ function visitor(node, parents) {\n        let index = -1;\n        /** @type {Parent | undefined} */ let grandparent;\n        while(++index < parents.length){\n            const parent = parents[index];\n            if (ignored(parent, // @ts-expect-error: TS doesn’t understand but it’s perfect.\n            grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n                return;\n            }\n            grandparent = parent;\n        }\n        if (grandparent) {\n            return handler(node, parents);\n        }\n    }\n    /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */ function handler(node, parents) {\n        const parent = parents[parents.length - 1];\n        const find = pairs[pairIndex][0];\n        const replace = pairs[pairIndex][1];\n        let start = 0;\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node);\n        let change = false;\n        /** @type {Array<PhrasingContent>} */ let nodes = [];\n        find.lastIndex = 0;\n        let match = find.exec(node.value);\n        while(match){\n            const position = match.index;\n            /** @type {RegExpMatchObject} */ const matchObject = {\n                index: match.index,\n                input: match.input,\n                // @ts-expect-error: stack is fine.\n                stack: [\n                    ...parents,\n                    node\n                ]\n            };\n            let value = replace(...match, matchObject);\n            if (typeof value === \"string\") {\n                value = value.length > 0 ? {\n                    type: \"text\",\n                    value\n                } : undefined;\n            }\n            // It wasn’t a match after all.\n            if (value !== false) {\n                if (start !== position) {\n                    nodes.push({\n                        type: \"text\",\n                        value: node.value.slice(start, position)\n                    });\n                }\n                if (Array.isArray(value)) {\n                    nodes.push(...value);\n                } else if (value) {\n                    nodes.push(value);\n                }\n                start = position + match[0].length;\n                change = true;\n            }\n            if (!find.global) {\n                break;\n            }\n            match = find.exec(node.value);\n        }\n        if (change) {\n            if (start < node.value.length) {\n                nodes.push({\n                    type: \"text\",\n                    value: node.value.slice(start)\n                });\n            }\n            parent.children.splice(index, 1, ...nodes);\n        } else {\n            nodes = [\n                node\n            ];\n        }\n        return index + nodes.length;\n    }\n};\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */ function toPairs(schema) {\n    /** @type {Pairs} */ const result = [];\n    if (typeof schema !== \"object\") {\n        throw new TypeError(\"Expected array or object as schema\");\n    }\n    if (Array.isArray(schema)) {\n        let index = -1;\n        while(++index < schema.length){\n            result.push([\n                toExpression(schema[index][0]),\n                toFunction(schema[index][1])\n            ]);\n        }\n    } else {\n        /** @type {string} */ let key;\n        for(key in schema){\n            if (own.call(schema, key)) {\n                result.push([\n                    toExpression(key),\n                    toFunction(schema[key])\n                ]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */ function toExpression(find) {\n    return typeof find === \"string\" ? new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(find), \"g\") : find;\n}\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */ function toFunction(replace) {\n    return typeof replace === \"function\" ? replace : ()=>replace;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9EQyxHQUV3QztBQUNZO0FBQ2hCO0FBRXJDLE1BQU1HLE1BQU0sQ0FBQyxFQUFFQyxjQUFjO0FBRTdCOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNELHFFQUFxRTtBQUM5RCxNQUFNQyxpQkFDWDs7Ozs7SUFLRSxHQUVBOzs7Ozs7O0tBT0MsR0FDRCxTQUFVQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ3BDLHVDQUF1QyxHQUN2QyxJQUFJQztJQUNKLG9EQUFvRCxHQUNwRCxJQUFJQztJQUVKLElBQUksT0FBT0osU0FBUyxZQUFZQSxnQkFBZ0JLLFFBQVE7UUFDdEQsK0NBQStDO1FBQy9DRCxTQUFTO1lBQUM7Z0JBQUNKO2dCQUFNQzthQUFRO1NBQUM7UUFDMUJFLFdBQVdEO0lBQ2IsT0FBTztRQUNMRSxTQUFTSjtRQUNULCtDQUErQztRQUMvQ0csV0FBV0Y7SUFDYjtJQUVBLElBQUksQ0FBQ0UsVUFBVTtRQUNiQSxXQUFXLENBQUM7SUFDZDtJQUVBLE1BQU1HLFVBQVVYLHNEQUFPQSxDQUFDUSxTQUFTSSxNQUFNLElBQUksRUFBRTtJQUM3QyxNQUFNQyxRQUFRQyxRQUFRTDtJQUN0QixJQUFJTSxZQUFZLENBQUM7SUFFakIsTUFBTyxFQUFFQSxZQUFZRixNQUFNRyxNQUFNLENBQUU7UUFDakNqQixzRUFBWUEsQ0FBQ0ssTUFBTSxRQUFRYTtJQUM3QjtJQUVBLGlEQUFpRDtJQUNqRCxPQUFPYjtJQUVQLDJGQUEyRixHQUMzRixTQUFTYSxRQUFRQyxJQUFJLEVBQUVDLE9BQU87UUFDNUIsSUFBSUMsUUFBUSxDQUFDO1FBQ2IsK0JBQStCLEdBQy9CLElB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LENBQUNqQyxTQUFTO1FBQ3pCLElBQUlXLFFBQVEsQ0FBQztRQUViLE1BQU8sRUFBRUEsUUFBUVgsT0FBT08sTUFBTSxDQUFFO1lBQzlCNkIsT0FBT04sSUFBSSxDQUFDO2dCQUNWUSxhQUFhdEMsTUFBTSxDQUFDVyxNQUFNLENBQUMsRUFBRTtnQkFDN0I0QixXQUFXdkMsTUFBTSxDQUFDVyxNQUFNLENBQUMsRUFBRTthQUM1QjtRQUNIO0lBQ0YsT0FBTztRQUNMLG1CQUFtQixHQUNuQixJQUFJNkI7UUFFSixJQUFLQSxPQUFPeEMsT0FBUTtZQUNsQixJQUFJUixJQUFJaUQsSUFBSSxDQUFDekMsUUFBUXdDLE1BQU07Z0JBQ3pCSixPQUFPTixJQUFJLENBQUM7b0JBQUNRLGFBQWFFO29CQUFNRCxXQUFXdkMsTUFBTSxDQUFDd0MsSUFBSTtpQkFBRTtZQUMxRDtRQUNGO0lBQ0Y7SUFFQSxPQUFPSjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNFLGFBQWExQyxJQUFJO0lBQ3hCLE9BQU8sT0FBT0EsU0FBUyxXQUFXLElBQUlLLE9BQU9aLGdFQUFNQSxDQUFDTyxPQUFPLE9BQU9BO0FBQ3BFO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVMyQyxXQUFXMUMsT0FBTztJQUN6QixPQUFPLE9BQU9BLFlBQVksYUFBYUEsVUFBVSxJQUFNQTtBQUN6RCIsInNvdXJjZXMiOlsid2VicGFjazovL3NlY3VyaXR5LWJsb2cvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcz85NDIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QYXJlbnR9IE1kYXN0UGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29udGVudH0gQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5QaHJhc2luZ0NvbnRlbnR9IFBocmFzaW5nQ29udGVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UZXh0fSBUZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5UZXN0fSBUZXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5WaXNpdG9yUmVzdWx0fSBWaXNpdG9yUmVzdWx0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q29udGVudCB8IFJvb3R9IE5vZGVcbiAqIEB0eXBlZGVmIHtFeHRyYWN0PE5vZGUsIE1kYXN0UGFyZW50Pn0gUGFyZW50XG4gKiBAdHlwZWRlZiB7RXhjbHVkZTxQYXJlbnQsIFJvb3Q+fSBDb250ZW50UGFyZW50XG4gKlxuICogQHR5cGVkZWYgUmVnRXhwTWF0Y2hPYmplY3RcbiAqICAgSW5mbyBvbiB0aGUgbWF0Y2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqICAgVGhlIGluZGV4IG9mIHRoZSBzZWFyY2ggYXQgd2hpY2ggdGhlIHJlc3VsdCB3YXMgZm91bmQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW5wdXRcbiAqICAgQSBjb3B5IG9mIHRoZSBzZWFyY2ggc3RyaW5nIGluIHRoZSB0ZXh0IG5vZGUuXG4gKiBAcHJvcGVydHkge1tSb290LCAuLi5BcnJheTxDb250ZW50UGFyZW50PiwgVGV4dF19IHN0YWNrXG4gKiAgIEFsbCBhbmNlc3RvcnMgb2YgdGhlIHRleHQgbm9kZSwgd2hlcmUgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gKlxuICogQGNhbGxiYWNrIFJlcGxhY2VGdW5jdGlvblxuICogICBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIHNlYXJjaCBtYXRjaGVzLlxuICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtZXRlcnNcbiAqICAgVGhlIHBhcmFtZXRlcnMgYXJlIHRoZSByZXN1bHQgb2YgY29ycmVzcG9uZGluZyBzZWFyY2ggZXhwcmVzc2lvbjpcbiAqXG4gKiAgICogYHZhbHVlYCAoYHN0cmluZ2ApIOKAlCB3aG9sZSBtYXRjaFxuICogICAqIGAuLi5jYXB0dXJlYCAoYEFycmF5PHN0cmluZz5gKSDigJQgbWF0Y2hlcyBmcm9tIHJlZ2V4IGNhcHR1cmUgZ3JvdXBzXG4gKiAgICogYG1hdGNoYCAoYFJlZ0V4cE1hdGNoT2JqZWN0YCkg4oCUIGluZm8gb24gdGhlIG1hdGNoXG4gKiBAcmV0dXJucyB7QXJyYXk8UGhyYXNpbmdDb250ZW50PiB8IFBocmFzaW5nQ29udGVudCB8IHN0cmluZyB8IGZhbHNlIHwgdW5kZWZpbmVkIHwgbnVsbH1cbiAqICAgVGhpbmcgdG8gcmVwbGFjZSB3aXRoLlxuICpcbiAqICAgKiB3aGVuIGBudWxsYCwgYHVuZGVmaW5lZGAsIGAnJ2AsIHJlbW92ZSB0aGUgbWF0Y2hcbiAqICAgKiDigKZvciB3aGVuIGBmYWxzZWAsIGRvIG5vdCByZXBsYWNlIGF0IGFsbFxuICogICAqIOKApm9yIHdoZW4gYHN0cmluZ2AsIHJlcGxhY2Ugd2l0aCBhIHRleHQgbm9kZSBvZiB0aGF0IHZhbHVlXG4gKiAgICog4oCmb3Igd2hlbiBgTm9kZWAgb3IgYEFycmF5PE5vZGU+YCwgcmVwbGFjZSB3aXRoIHRob3NlIG5vZGVzXG4gKlxuICogQHR5cGVkZWYge3N0cmluZyB8IFJlZ0V4cH0gRmluZFxuICogICBQYXR0ZXJuIHRvIGZpbmQuXG4gKlxuICogICBTdHJpbmdzIGFyZSBlc2NhcGVkIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGdsb2JhbCBleHByZXNzaW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8RmluZEFuZFJlcGxhY2VUdXBsZT59IEZpbmRBbmRSZXBsYWNlTGlzdFxuICogICBTZXZlcmFsIGZpbmQgYW5kIHJlcGxhY2VzLCBpbiBhcnJheSBmb3JtLlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIFJlcGxhY2U+fSBGaW5kQW5kUmVwbGFjZVNjaGVtYVxuICogICBTZXZlcmFsIGZpbmQgYW5kIHJlcGxhY2VzLCBpbiBvYmplY3QgZm9ybS5cbiAqIEB0eXBlZGVmIHtbRmluZCwgUmVwbGFjZV19IEZpbmRBbmRSZXBsYWNlVHVwbGVcbiAqICAgRmluZCBhbmQgcmVwbGFjZSBpbiB0dXBsZSBmb3JtLlxuICogQHR5cGVkZWYge3N0cmluZyB8IFJlcGxhY2VGdW5jdGlvbn0gUmVwbGFjZVxuICogICBUaGluZyB0byByZXBsYWNlIHdpdGguXG4gKiBAdHlwZWRlZiB7W1JlZ0V4cCwgUmVwbGFjZUZ1bmN0aW9uXX0gUGFpclxuICogICBOb3JtYWxpemVkIGZpbmQgYW5kIHJlcGxhY2UuXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGFpcj59IFBhaXJzXG4gKiAgIEFsbCBmaW5kIGFuZCByZXBsYWNlZC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1Rlc3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlXVxuICogICBUZXN0IGZvciB3aGljaCBub2RlcyB0byBpZ25vcmUuXG4gKi9cblxuaW1wb3J0IGVzY2FwZSBmcm9tICdlc2NhcGUtc3RyaW5nLXJlZ2V4cCdcbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogRmluZCBwYXR0ZXJucyBpbiBhIHRyZWUgYW5kIHJlcGxhY2UgdGhlbS5cbiAqXG4gKiBUaGUgYWxnb3JpdGhtIHNlYXJjaGVzIHRoZSB0cmVlIGluICpwcmVvcmRlciogZm9yIGNvbXBsZXRlIHZhbHVlcyBpbiBgVGV4dGBcbiAqIG5vZGVzLlxuICogUGFydGlhbCBtYXRjaGVzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB0cmVlXG4gKiAgIFRyZWUgdG8gY2hhbmdlLlxuICogQHBhcmFtIGZpbmRcbiAqICAgUGF0dGVybnMgdG8gZmluZC5cbiAqIEBwYXJhbSByZXBsYWNlXG4gKiAgIFRoaW5ncyB0byByZXBsYWNlIHdpdGggKHdoZW4gYGZpbmRgIGlzIGBGaW5kYCkgb3IgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKHdoZW4gYGZpbmRgIGlzIG5vdCBgRmluZGApLlxuICogQHJldHVybnNcbiAqICAgR2l2ZW4sIG1vZGlmaWVkLCB0cmVlLlxuICovXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogcmVtb3ZlIGBmaW5kYCAmIGByZXBsYWNlYCBjb21ibywgcmVtb3ZlIHNjaGVtYS5cbmV4cG9ydCBjb25zdCBmaW5kQW5kUmVwbGFjZSA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIGZpbmQ6IEZpbmQsIHJlcGxhY2U/OiBSZXBsYWNlIHwgbnVsbCB8IHVuZGVmaW5lZCwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBUcmVlKSAmXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZT4odHJlZTogVHJlZSwgc2NoZW1hOiBGaW5kQW5kUmVwbGFjZVNjaGVtYSB8IEZpbmRBbmRSZXBsYWNlTGlzdCwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBUcmVlKVxuICAgKiApfVxuICAgKiovXG4gIChcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUge05vZGV9IFRyZWVcbiAgICAgKiBAcGFyYW0ge1RyZWV9IHRyZWVcbiAgICAgKiBAcGFyYW0ge0ZpbmQgfCBGaW5kQW5kUmVwbGFjZVNjaGVtYSB8IEZpbmRBbmRSZXBsYWNlTGlzdH0gZmluZFxuICAgICAqIEBwYXJhbSB7UmVwbGFjZSB8IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbcmVwbGFjZV1cbiAgICAgKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7VHJlZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodHJlZSwgZmluZCwgcmVwbGFjZSwgb3B0aW9ucykge1xuICAgICAgLyoqIEB0eXBlIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBzZXR0aW5nc1xuICAgICAgLyoqIEB0eXBlIHtGaW5kQW5kUmVwbGFjZVNjaGVtYXxGaW5kQW5kUmVwbGFjZUxpc3R9ICovXG4gICAgICBsZXQgc2NoZW1hXG5cbiAgICAgIGlmICh0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgfHwgZmluZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvbuKAmXQgZXhwZWN0IG9wdGlvbnMgdHdpY2UuXG4gICAgICAgIHNjaGVtYSA9IFtbZmluZCwgcmVwbGFjZV1dXG4gICAgICAgIHNldHRpbmdzID0gb3B0aW9uc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gZmluZFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRvbuKAmXQgZXhwZWN0IHJlcGxhY2UgdHdpY2UuXG4gICAgICAgIHNldHRpbmdzID0gcmVwbGFjZVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0ge31cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWdub3JlZCA9IGNvbnZlcnQoc2V0dGluZ3MuaWdub3JlIHx8IFtdKVxuICAgICAgY29uc3QgcGFpcnMgPSB0b1BhaXJzKHNjaGVtYSlcbiAgICAgIGxldCBwYWlySW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytwYWlySW5kZXggPCBwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgdmlzaXRQYXJlbnRzKHRyZWUsICd0ZXh0JywgdmlzaXRvcilcbiAgICAgIH1cblxuICAgICAgLy8gVG8gZG8gbmV4dCBtYWpvcjogZG9u4oCZdCByZXR1cm4gdGhlIGdpdmVuIHRyZWUuXG4gICAgICByZXR1cm4gdHJlZVxuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2NvbXBsZXgtdHlwZXMuanMnKS5CdWlsZFZpc2l0b3I8Um9vdCwgJ3RleHQnPn0gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZSwgcGFyZW50cykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMVxuICAgICAgICAvKiogQHR5cGUge1BhcmVudCB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IGdyYW5kcGFyZW50XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbaW5kZXhdXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpZ25vcmVkKFxuICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGRvZXNu4oCZdCB1bmRlcnN0YW5kIGJ1dCBpdOKAmXMgcGVyZmVjdC5cbiAgICAgICAgICAgICAgZ3JhbmRwYXJlbnQgPyBncmFuZHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHBhcmVudCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGdyYW5kcGFyZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncmFuZHBhcmVudCA9IHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYW5kcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIobm9kZSwgcGFyZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBhIHRleHQgbm9kZSB3aGljaCBpcyBub3QgaW4gYW4gaWdub3JlZCBwYXJlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtUZXh0fSBub2RlXG4gICAgICAgKiAgIFRleHQgbm9kZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8UGFyZW50Pn0gcGFyZW50c1xuICAgICAgICogICBQYXJlbnRzLlxuICAgICAgICogQHJldHVybnMge1Zpc2l0b3JSZXN1bHR9XG4gICAgICAgKiAgIFJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaGFuZGxlcihub2RlLCBwYXJlbnRzKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgICAgICBjb25zdCBmaW5kID0gcGFpcnNbcGFpckluZGV4XVswXVxuICAgICAgICBjb25zdCByZXBsYWNlID0gcGFpcnNbcGFpckluZGV4XVsxXVxuICAgICAgICBsZXQgc3RhcnQgPSAwXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGlzIHdyb25nLCBzb21lIG9mIHRoZXNlIGNoaWxkcmVuIGNhbiBiZSB0ZXh0LlxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gICAgICAgIGxldCBjaGFuZ2UgPSBmYWxzZVxuICAgICAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgICAgIGxldCBub2RlcyA9IFtdXG5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSAwXG5cbiAgICAgICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtYXRjaC5pbmRleFxuICAgICAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICAgICAgY29uc3QgbWF0Y2hPYmplY3QgPSB7XG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzdGFjayBpcyBmaW5lLlxuICAgICAgICAgICAgc3RhY2s6IFsuLi5wYXJlbnRzLCBub2RlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSByZXBsYWNlKC4uLm1hdGNoLCBtYXRjaE9iamVjdClcblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJdCB3YXNu4oCZdCBhIG1hdGNoIGFmdGVyIGFsbC5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgIT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZS5zbGljZShzdGFydCwgcG9zaXRpb24pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKC4uLnZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFydCA9IHBvc2l0aW9uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmaW5kLmdsb2JhbCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaCA9IGZpbmQuZXhlYyhub2RlLnZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIGlmIChzdGFydCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAndGV4dCcsIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0KX0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4ubm9kZXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMgPSBbbm9kZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleCArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIFR1cm4gYSBzY2hlbWEgaW50byBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0ZpbmRBbmRSZXBsYWNlU2NoZW1hIHwgRmluZEFuZFJlcGxhY2VMaXN0fSBzY2hlbWFcbiAqICAgU2NoZW1hLlxuICogQHJldHVybnMge1BhaXJzfVxuICogICBDbGVhbiBwYWlycy5cbiAqL1xuZnVuY3Rpb24gdG9QYWlycyhzY2hlbWEpIHtcbiAgLyoqIEB0eXBlIHtQYWlyc30gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcnJheSBvciBvYmplY3QgYXMgc2NoZW1hJylcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBzY2hlbWEubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChbXG4gICAgICAgIHRvRXhwcmVzc2lvbihzY2hlbWFbaW5kZXhdWzBdKSxcbiAgICAgICAgdG9GdW5jdGlvbihzY2hlbWFbaW5kZXhdWzFdKVxuICAgICAgXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGtleVxuXG4gICAgZm9yIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAob3duLmNhbGwoc2NoZW1hLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFt0b0V4cHJlc3Npb24oa2V5KSwgdG9GdW5jdGlvbihzY2hlbWFba2V5XSldKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBUdXJuIGEgZmluZCBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtGaW5kfSBmaW5kXG4gKiAgIEZpbmQuXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogICBFeHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiB0b0V4cHJlc3Npb24oZmluZCkge1xuICByZXR1cm4gdHlwZW9mIGZpbmQgPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cChlc2NhcGUoZmluZCksICdnJykgOiBmaW5kXG59XG5cbi8qKlxuICogVHVybiBhIHJlcGxhY2UgaW50byBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVwbGFjZX0gcmVwbGFjZVxuICogICBSZXBsYWNlLlxuICogQHJldHVybnMge1JlcGxhY2VGdW5jdGlvbn1cbiAqICAgRnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRvRnVuY3Rpb24ocmVwbGFjZSkge1xuICByZXR1cm4gdHlwZW9mIHJlcGxhY2UgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlIDogKCkgPT4gcmVwbGFjZVxufVxuIl0sIm5hbWVzIjpbImVzY2FwZSIsInZpc2l0UGFyZW50cyIsImNvbnZlcnQiLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZpbmRBbmRSZXBsYWNlIiwidHJlZSIsImZpbmQiLCJyZXBsYWNlIiwib3B0aW9ucyIsInNldHRpbmdzIiwic2NoZW1hIiwiUmVnRXhwIiwiaWdub3JlZCIsImlnbm9yZSIsInBhaXJzIiwidG9QYWlycyIsInBhaXJJbmRleCIsImxlbmd0aCIsInZpc2l0b3IiLCJub2RlIiwicGFyZW50cyIsImluZGV4IiwiZ3JhbmRwYXJlbnQiLCJwYXJlbnQiLCJjaGlsZHJlbiIsImluZGV4T2YiLCJ1bmRlZmluZWQiLCJoYW5kbGVyIiwic3RhcnQiLCJjaGFuZ2UiLCJub2RlcyIsImxhc3RJbmRleCIsIm1hdGNoIiwiZXhlYyIsInZhbHVlIiwicG9zaXRpb24iLCJtYXRjaE9iamVjdCIsImlucHV0Iiwic3RhY2siLCJ0eXBlIiwicHVzaCIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2xvYmFsIiwic3BsaWNlIiwicmVzdWx0IiwiVHlwZUVycm9yIiwidG9FeHByZXNzaW9uIiwidG9GdW5jdGlvbiIsImtleSIsImNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ escapeStringRegexp)\n/* harmony export */ });\nfunction escapeStringRegexp(string) {\n    if (typeof string !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n    }\n    // Escape characters with special meaning either inside or outside character sets.\n    // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n    return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsbUJBQW1CQyxNQUFNO0lBQ2hELElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQy9CLE1BQU0sSUFBSUMsVUFBVTtJQUNyQjtJQUVBLGtGQUFrRjtJQUNsRiw2SkFBNko7SUFDN0osT0FBT0QsT0FDTEUsT0FBTyxDQUFDLHVCQUF1QixRQUMvQkEsT0FBTyxDQUFDLE1BQU07QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWN1cml0eS1ibG9nLy4vbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZS9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanM/MmUyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIl0sIm5hbWVzIjpbImVzY2FwZVN0cmluZ1JlZ2V4cCIsInN0cmluZyIsIlR5cGVFcnJvciIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/color.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/color.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color)\n/* harmony export */ });\n/**\n * @param {string} d\n * @returns {string}\n */ function color(d) {\n    return \"\\x1b[33m\" + d + \"\\x1b[39m\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvbGliL2NvbG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxTQUFTQSxNQUFNQyxDQUFDO0lBQ3JCLE9BQU8sYUFBZUEsSUFBSTtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlY3VyaXR5LWJsb2cvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvbGliL2NvbG9yLmpzPzk1ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKGQpIHtcbiAgcmV0dXJuICdcXHUwMDFCWzMzbScgKyBkICsgJ1xcdTAwMUJbMzltJ1xufVxuIl0sIm5hbWVzIjpbImNvbG9yIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/color.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTINUE: () => (/* binding */ CONTINUE),\n/* harmony export */   EXIT: () => (/* binding */ EXIT),\n/* harmony export */   SKIP: () => (/* binding */ SKIP),\n/* harmony export */   visitParents: () => (/* binding */ visitParents)\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"(rsc)/./node_modules/unist-util-is/lib/index.js\");\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ \"(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/color.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */ /**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */ /**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */ /**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */ \n\n/**\n * Continue traversing as normal.\n */ const CONTINUE = true;\n/**\n * Stop traversing immediately.\n */ const EXIT = false;\n/**\n * Do not traverse this node’s children.\n */ const SKIP = \"skip\";\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */ const visitParents = /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */ /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */ function(tree, test, visitor, reverse) {\n    if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test;\n        test = null;\n    }\n    const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test);\n    const step = reverse ? -1 : 1;\n    factory(tree, undefined, [])();\n    /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */ function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */ // @ts-expect-error: hush\n        const value = node && typeof node === \"object\" ? node : {};\n        if (typeof value.type === \"string\") {\n            const name = // `hast`\n            typeof value.tagName === \"string\" ? value.tagName : typeof value.name === \"string\" ? value.name : undefined;\n            Object.defineProperty(visit, \"name\", {\n                value: \"node (\" + (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.color)(node.type + (name ? \"<\" + name + \">\" : \"\")) + \")\"\n            });\n        }\n        return visit;\n        function visit() {\n            /** @type {ActionTuple} */ let result = [];\n            /** @type {ActionTuple} */ let subresult;\n            /** @type {number} */ let offset;\n            /** @type {Array<Parent>} */ let grandparents;\n            if (!test || is(node, index, parents[parents.length - 1] || null)) {\n                result = toResult(visitor(node, parents));\n                if (result[0] === EXIT) {\n                    return result;\n                }\n            }\n            // @ts-expect-error looks like a parent.\n            if (node.children && result[0] !== SKIP) {\n                // @ts-expect-error looks like a parent.\n                offset = (reverse ? node.children.length : -1) + step;\n                // @ts-expect-error looks like a parent.\n                grandparents = parents.concat(node);\n                // @ts-expect-error looks like a parent.\n                while(offset > -1 && offset < node.children.length){\n                    // @ts-expect-error looks like a parent.\n                    subresult = factory(node.children[offset], offset, grandparents)();\n                    if (subresult[0] === EXIT) {\n                        return subresult;\n                    }\n                    offset = typeof subresult[1] === \"number\" ? subresult[1] : offset + step;\n                }\n            }\n            return result;\n        }\n    }\n};\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */ function toResult(value) {\n    if (Array.isArray(value)) {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return [\n            CONTINUE,\n            value\n        ];\n    }\n    return [\n        value\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRW9DO0FBQ0w7QUFFaEM7O0NBRUMsR0FDTSxNQUFNRSxXQUFXLEtBQUk7QUFFNUI7O0NBRUMsR0FDTSxNQUFNQyxPQUFPLE1BQUs7QUFFekI7O0NBRUMsR0FDTSxNQUFNQyxPQUFPLE9BQU07QUFFMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDTSxNQUFNQyxlQUNYOzs7OztHQUtDLEdBRUM7Ozs7OztLQU1DLEdBQ0QsU0FBVUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUNwQyxJQUFJLE9BQU9GLFNBQVMsY0FBYyxPQUFPQyxZQUFZLFlBQVk7UUFDL0RDLFVBQVVEO1FBQ1YsMkRBQTJEO1FBQzNEQSxVQUFVRDtRQUNWQSxPQUFPO0lBQ1Q7SUFFQSxNQUFNRyxLQUFLVixzREFBT0EsQ0FBQ087SUFDbkIsTUFBTUksT0FBT0YsVUFBVSxDQUFDLElBQUk7SUFFNUJHLFFBQVFOLE1BQU1PLFdBQVcsRUFBRTtJQUUzQjs7OztPQUlDLEdBQ0QsU0FBU0QsUUFBUUUsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU87UUFDbkMsb0NBQW9DLEdBQ3BDLHlCQUF5QjtRQUN6QixNQUFNQyxRQUFRSCxRQUFRLE9BQU9BLFNBQVMsV0FBV0EsT0FBTyxDQUFDO1FBRXpELElBQUksT0FBT0csTUFBTUMsSUFBSSxLQUFLLFVBQVU7WUFDbEMsTUFBTUMsT0FDSixTQUFTO1lBQ1QsT0FBT0YsTUFBTUcsT0FBTyxLQUFLLFdBQ3JCSCxNQUFNRyxPQUFPLEdBRWYsT0FBT0gsTUFBTUUsSUFBSSxLQUFLLFdBQ3BCRixNQUFNRSxJQUFJLEdBQ1ZOO1lBRU5RLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxRQUFRO2dCQUNuQ04sT0FDRSxXQUFXaEIsZ0RBQUtBLENBQUNhLEtBQUtJLElBQUksR0FBSUMsQ0FBQUEsT0FBTyxNQUFNQSxPQUFPLE1BQU0sRUFBQyxLQUFNO1lBQ25FO1FBQ0Y7UUFFQSxPQUFPSTtRQUVQLFNBQVNBO1lBQ1Asd0JBQXdCLEdBQ3hCLElBQUlDLFNBQVMsRUFBRTtZQUNmLHdCQUF3QixHQUN4QixJQUFJQztZQUNKLG1CQUFtQixHQUNuQixJQUFJQztZQUNKLDBCQUEwQixHQUMxQixJQUFJQztZQUVKLElBQUksQ0FBQ3BCLFFBQVFHLEdBQUdJLE1BQU1DLE9BQU9DLE9BQU8sQ0FBQ0EsUUFBUVksTUFBTSxHQUFHLEVBQUUsSUFBSSxPQUFPO2dCQUNqRUosU0FBU0ssU0FBU3JCLFFBQVFNLE1BQU1FO2dCQUVoQyxJQUFJUSxNQUFNLENBQUMsRUFBRSxLQUFLckIsTUFBTTtvQkFDdEIsT0FBT3FCO2dCQUNUO1lBQ0Y7WUFFQSx3Q0FBd0M7WUFDeEMsSUFBSVYsS0FBS2dCLFFBQVEsSUFBSU4sTUFBTSxDQUFDLEVBQUUsS0FBS3BCLE1BQU07Z0JBQ3ZDLHdDQUF3QztnQkFDeENzQixTQUFTLENBQUNqQixVQUFVSyxLQUFLZ0IsUUFBUSxDQUFDRixNQUFNLEdBQUcsQ0FBQyxLQUFLakI7Z0JBQ2pELHdDQUF3QztnQkFDeENnQixlQUFlWCxRQUFRZSxNQUFNLENBQUNqQjtnQkFFOUIsd0NBQXdDO2dCQUN4QyxNQUFPWSxTQUFTLENBQUMsS0FBS0EsU0FBU1osS0FBS2dCLFFBQVEsQ0FBQ0YsTUFBTSxDQUFFO29CQUNuRCx3Q0FBd0M7b0JBQ3hDSCxZQUFZYixRQUFRRSxLQUFLZ0IsUUFBUSxDQUFDSixPQUFPLEVBQUVBLFFBQVFDO29CQUVuRCxJQUFJRixTQUFTLENBQUMsRUFBRSxLQUFLdEIsTUFBTTt3QkFDekIsT0FBT3NCO29CQUNUO29CQUVBQyxTQUNFLE9BQU9ELFNBQVMsQ0FBQyxFQUFFLEtBQUssV0FBV0EsU0FBUyxDQUFDLEVBQUUsR0FBR0MsU0FBU2Y7Z0JBQy9EO1lBQ0Y7WUFFQSxPQUFPYTtRQUNUO0lBQ0Y7QUFDRixFQUNEO0FBRUg7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNLLFNBQVNaLEtBQUs7SUFDckIsSUFBSWUsTUFBTUMsT0FBTyxDQUFDaEIsUUFBUTtRQUN4QixPQUFPQTtJQUNUO0lBRUEsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDN0IsT0FBTztZQUFDZjtZQUFVZTtTQUFNO0lBQzFCO0lBRUEsT0FBTztRQUFDQTtLQUFNO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2Uvbm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cy9saWIvaW5kZXguanM/M2ZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QtdXRpbC1pcycpLlRlc3R9IFRlc3RcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtib29sZWFuIHwgJ3NraXAnfSBBY3Rpb25cbiAqICAgVW5pb24gb2YgdGhlIGFjdGlvbiB0eXBlcy5cbiAqXG4gKiBAdHlwZWRlZiB7bnVtYmVyfSBJbmRleFxuICogICBNb3ZlIHRvIHRoZSBzaWJsaW5nIGF0IGBpbmRleGAgbmV4dCAoYWZ0ZXIgbm9kZSBpdHNlbGYgaXMgY29tcGxldGVseVxuICogICB0cmF2ZXJzZWQpLlxuICpcbiAqICAgVXNlZnVsIGlmIG11dGF0aW5nIHRoZSB0cmVlLCBzdWNoIGFzIHJlbW92aW5nIHRoZSBub2RlIHRoZSB2aXNpdG9yIGlzXG4gKiAgIGN1cnJlbnRseSBvbiwgb3IgYW55IG9mIGl0cyBwcmV2aW91cyBzaWJsaW5ncy5cbiAqICAgUmVzdWx0cyBsZXNzIHRoYW4gMCBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGNoaWxkcmVuLmxlbmd0aGAgc3RvcFxuICogICB0cmF2ZXJzaW5nIHRoZSBwYXJlbnQuXG4gKlxuICogQHR5cGVkZWYge1soQWN0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQpPywgKEluZGV4IHwgbnVsbCB8IHVuZGVmaW5lZCk/XX0gQWN0aW9uVHVwbGVcbiAqICAgTGlzdCB3aXRoIG9uZSBvciB0d28gdmFsdWVzLCB0aGUgZmlyc3QgYW4gYWN0aW9uLCB0aGUgc2Vjb25kIGFuIGluZGV4LlxuICpcbiAqIEB0eXBlZGVmIHtBY3Rpb24gfCBBY3Rpb25UdXBsZSB8IEluZGV4IHwgbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWR9IFZpc2l0b3JSZXN1bHRcbiAqICAgQW55IHZhbHVlIHRoYXQgY2FuIGJlIHJldHVybmVkIGZyb20gYSB2aXNpdG9yLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBbVmlzaXRlZD1Ob2RlXVxuICogICBWaXNpdGVkIG5vZGUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7UGFyZW50fSBbQW5jZXN0b3I9UGFyZW50XVxuICogICBBbmNlc3RvciB0eXBlLlxuICogQGNhbGxiYWNrIFZpc2l0b3JcbiAqICAgSGFuZGxlIGEgbm9kZSAobWF0Y2hpbmcgYHRlc3RgLCBpZiBnaXZlbikuXG4gKlxuICogICBWaXNpdG9ycyBhcmUgZnJlZSB0byB0cmFuc2Zvcm0gYG5vZGVgLlxuICogICBUaGV5IGNhbiBhbHNvIHRyYW5zZm9ybSB0aGUgcGFyZW50IG9mIG5vZGUgKHRoZSBsYXN0IG9mIGBhbmNlc3RvcnNgKS5cbiAqXG4gKiAgIFJlcGxhY2luZyBgbm9kZWAgaXRzZWxmLCBpZiBgU0tJUGAgaXMgbm90IHJldHVybmVkLCBzdGlsbCBjYXVzZXMgaXRzXG4gKiAgIGRlc2NlbmRhbnRzIHRvIGJlIHdhbGtlZCAod2hpY2ggaXMgYSBidWcpLlxuICpcbiAqICAgV2hlbiBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJldmlvdXMgc2libGluZ3Mgb2YgYG5vZGVgIChvciBuZXh0IHNpYmxpbmdzLCBpblxuICogICBjYXNlIG9mIHJldmVyc2UpLCB0aGUgYFZpc2l0b3JgIHNob3VsZCByZXR1cm4gYSBuZXcgYEluZGV4YCB0byBzcGVjaWZ5IHRoZVxuICogICBzaWJsaW5nIHRvIHRyYXZlcnNlIGFmdGVyIGBub2RlYCBpcyB0cmF2ZXJzZWQuXG4gKiAgIEFkZGluZyBvciByZW1vdmluZyBuZXh0IHNpYmxpbmdzIG9mIGBub2RlYCAob3IgcHJldmlvdXMgc2libGluZ3MsIGluIGNhc2VcbiAqICAgb2YgcmV2ZXJzZSkgaXMgaGFuZGxlZCBhcyBleHBlY3RlZCB3aXRob3V0IG5lZWRpbmcgdG8gcmV0dXJuIGEgbmV3IGBJbmRleGAuXG4gKlxuICogICBSZW1vdmluZyB0aGUgY2hpbGRyZW4gcHJvcGVydHkgb2YgYW4gYW5jZXN0b3Igc3RpbGwgcmVzdWx0cyBpbiB0aGVtIGJlaW5nXG4gKiAgIHRyYXZlcnNlZC5cbiAqIEBwYXJhbSB7VmlzaXRlZH0gbm9kZVxuICogICBGb3VuZCBub2RlLlxuICogQHBhcmFtIHtBcnJheTxBbmNlc3Rvcj59IGFuY2VzdG9yc1xuICogICBBbmNlc3RvcnMgb2YgYG5vZGVgLlxuICogQHJldHVybnMge1Zpc2l0b3JSZXN1bHR9XG4gKiAgIFdoYXQgdG8gZG8gbmV4dC5cbiAqXG4gKiAgIEFuIGBJbmRleGAgaXMgdHJlYXRlZCBhcyBhIHR1cGxlIG9mIGBbQ09OVElOVUUsIEluZGV4XWAuXG4gKiAgIEFuIGBBY3Rpb25gIGlzIHRyZWF0ZWQgYXMgYSB0dXBsZSBvZiBgW0FjdGlvbl1gLlxuICpcbiAqICAgUGFzc2luZyBhIHR1cGxlIGJhY2sgb25seSBtYWtlcyBzZW5zZSBpZiB0aGUgYEFjdGlvbmAgaXMgYFNLSVBgLlxuICogICBXaGVuIHRoZSBgQWN0aW9uYCBpcyBgRVhJVGAsIHRoYXQgYWN0aW9uIGNhbiBiZSByZXR1cm5lZC5cbiAqICAgV2hlbiB0aGUgYEFjdGlvbmAgaXMgYENPTlRJTlVFYCwgYEluZGV4YCBjYW4gYmUgcmV0dXJuZWQuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IFtUcmVlPU5vZGVdXG4gKiAgIFRyZWUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VGVzdH0gW0NoZWNrPXN0cmluZ11cbiAqICAgVGVzdCB0eXBlLlxuICogQHR5cGVkZWYge1Zpc2l0b3I8aW1wb3J0KCcuL2NvbXBsZXgtdHlwZXMuanMnKS5NYXRjaGVzPGltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuSW5jbHVzaXZlRGVzY2VuZGFudDxUcmVlPiwgQ2hlY2s+LCBFeHRyYWN0PGltcG9ydCgnLi9jb21wbGV4LXR5cGVzLmpzJykuSW5jbHVzaXZlRGVzY2VuZGFudDxUcmVlPiwgUGFyZW50Pj59IEJ1aWxkVmlzaXRvclxuICogICBCdWlsZCBhIHR5cGVkIGBWaXNpdG9yYCBmdW5jdGlvbiBmcm9tIGEgdHJlZSBhbmQgYSB0ZXN0LlxuICpcbiAqICAgSXQgd2lsbCBpbmZlciB3aGljaCB2YWx1ZXMgYXJlIHBhc3NlZCBhcyBgbm9kZWAgYW5kIHdoaWNoIGFzIGBwYXJlbnRzYC5cbiAqL1xuXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5pbXBvcnQge2NvbG9yfSBmcm9tICcuL2NvbG9yLmpzJ1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsLlxuICovXG5leHBvcnQgY29uc3QgQ09OVElOVUUgPSB0cnVlXG5cbi8qKlxuICogU3RvcCB0cmF2ZXJzaW5nIGltbWVkaWF0ZWx5LlxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IGZhbHNlXG5cbi8qKlxuICogRG8gbm90IHRyYXZlcnNlIHRoaXMgbm9kZeKAmXMgY2hpbGRyZW4uXG4gKi9cbmV4cG9ydCBjb25zdCBTS0lQID0gJ3NraXAnXG5cbi8qKlxuICogVmlzaXQgbm9kZXMsIHdpdGggYW5jZXN0cmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIHBlcmZvcm1zICpkZXB0aC1maXJzdCogKnRyZWUgdHJhdmVyc2FsKiBpbiAqcHJlb3JkZXIqXG4gKiAoKipOTFIqKikgb3IgaWYgYHJldmVyc2VgIGlzIGdpdmVuLCBpbiAqcmV2ZXJzZSBwcmVvcmRlciogKCoqTlJMKiopLlxuICpcbiAqIFlvdSBjYW4gY2hvb3NlIGZvciB3aGljaCBub2RlcyBgdmlzaXRvcmAgaXMgY2FsbGVkIGJ5IHBhc3NpbmcgYSBgdGVzdGAuXG4gKiBGb3IgY29tcGxleCB0ZXN0cywgeW91IHNob3VsZCB0ZXN0IHlvdXJzZWxmIGluIGB2aXNpdG9yYCwgYXMgaXQgd2lsbCBiZVxuICogZmFzdGVyIGFuZCB3aWxsIGhhdmUgaW1wcm92ZWQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBXYWxraW5nIHRoZSB0cmVlIGlzIGFuIGludGVuc2l2ZSB0YXNrLlxuICogTWFrZSB1c2Ugb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHZpc2l0b3Igd2hlbiBwb3NzaWJsZS5cbiAqIEluc3RlYWQgb2Ygd2Fsa2luZyBhIHRyZWUgbXVsdGlwbGUgdGltZXMsIHdhbGsgaXQgb25jZSwgdXNlIGB1bmlzdC11dGlsLWlzYFxuICogdG8gY2hlY2sgaWYgYSBub2RlIG1hdGNoZXMsIGFuZCB0aGVuIHBlcmZvcm0gZGlmZmVyZW50IG9wZXJhdGlvbnMuXG4gKlxuICogWW91IGNhbiBjaGFuZ2UgdGhlIHRyZWUuXG4gKiBTZWUgYFZpc2l0b3JgIGZvciBtb3JlIGluZm8uXG4gKlxuICogQHBhcmFtIHRyZWVcbiAqICAgVHJlZSB0byB0cmF2ZXJzZS5cbiAqIEBwYXJhbSB0ZXN0XG4gKiAgIGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3RcbiAqIEBwYXJhbSB2aXNpdG9yXG4gKiAgIEhhbmRsZSBlYWNoIG5vZGUuXG4gKiBAcGFyYW0gcmV2ZXJzZVxuICogICBUcmF2ZXJzZSBpbiByZXZlcnNlIHByZW9yZGVyIChOUkwpIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgcHJlb3JkZXIgKE5MUikuXG4gKiBAcmV0dXJuc1xuICogICBOb3RoaW5nLlxuICovXG5leHBvcnQgY29uc3QgdmlzaXRQYXJlbnRzID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZSwgQ2hlY2sgZXh0ZW5kcyBUZXN0Pih0cmVlOiBUcmVlLCB0ZXN0OiBDaGVjaywgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWUsIENoZWNrPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKSAmXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZT4odHJlZTogVHJlZSwgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWU+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAgICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gICAgICogQHBhcmFtIHtWaXNpdG9yPE5vZGU+fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3JldmVyc2VdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRyZWUsIHRlc3QsIHZpc2l0b3IsIHJldmVyc2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmlzaXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXZlcnNlID0gdmlzaXRvclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vIHZpc2l0b3IgZ2l2ZW4sIHNvIGB2aXNpdG9yYCBpcyB0ZXN0LlxuICAgICAgICB2aXNpdG9yID0gdGVzdFxuICAgICAgICB0ZXN0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBpcyA9IGNvbnZlcnQodGVzdClcbiAgICAgIGNvbnN0IHN0ZXAgPSByZXZlcnNlID8gLTEgOiAxXG5cbiAgICAgIGZhY3RvcnkodHJlZSwgdW5kZWZpbmVkLCBbXSkoKVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gICAgICAgKiBAcGFyYW0ge0FycmF5PFBhcmVudD59IHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmFjdG9yeShub2RlLCBpbmRleCwgcGFyZW50cykge1xuICAgICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBodXNoXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgPyBub2RlIDoge31cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9XG4gICAgICAgICAgICAvLyBgaGFzdGBcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50YWdOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IHZhbHVlLnRhZ05hbWVcbiAgICAgICAgICAgICAgOiAvLyBgeGFzdGBcbiAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgID8gdmFsdWUubmFtZVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpc2l0LCAnbmFtZScsIHtcbiAgICAgICAgICAgIHZhbHVlOlxuICAgICAgICAgICAgICAnbm9kZSAoJyArIGNvbG9yKG5vZGUudHlwZSArIChuYW1lID8gJzwnICsgbmFtZSArICc+JyA6ICcnKSkgKyAnKSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2l0XG5cbiAgICAgICAgZnVuY3Rpb24gdmlzaXQoKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtBY3Rpb25UdXBsZX0gKi9cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gW11cbiAgICAgICAgICAvKiogQHR5cGUge0FjdGlvblR1cGxlfSAqL1xuICAgICAgICAgIGxldCBzdWJyZXN1bHRcbiAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgICBsZXQgb2Zmc2V0XG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxQYXJlbnQ+fSAqL1xuICAgICAgICAgIGxldCBncmFuZHBhcmVudHNcblxuICAgICAgICAgIGlmICghdGVzdCB8fCBpcyhub2RlLCBpbmRleCwgcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdIHx8IG51bGwpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0b1Jlc3VsdCh2aXNpdG9yKG5vZGUsIHBhcmVudHMpKVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgcmVzdWx0WzBdICE9PSBTS0lQKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSBwYXJlbnQuXG4gICAgICAgICAgICBvZmZzZXQgPSAocmV2ZXJzZSA/IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDogLTEpICsgc3RlcFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAgICAgZ3JhbmRwYXJlbnRzID0gcGFyZW50cy5jb25jYXQobm9kZSlcblxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgcGFyZW50LlxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA+IC0xICYmIG9mZnNldCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIHBhcmVudC5cbiAgICAgICAgICAgICAgc3VicmVzdWx0ID0gZmFjdG9yeShub2RlLmNoaWxkcmVuW29mZnNldF0sIG9mZnNldCwgZ3JhbmRwYXJlbnRzKSgpXG5cbiAgICAgICAgICAgICAgaWYgKHN1YnJlc3VsdFswXSA9PT0gRVhJVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJyZXN1bHRcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9mZnNldCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHN1YnJlc3VsdFsxXSA9PT0gJ251bWJlcicgPyBzdWJyZXN1bHRbMV0gOiBvZmZzZXQgKyBzdGVwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApXG5cbi8qKlxuICogVHVybiBhIHJldHVybiB2YWx1ZSBpbnRvIGEgY2xlYW4gcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7VmlzaXRvclJlc3VsdH0gdmFsdWVcbiAqICAgVmFsaWQgcmV0dXJuIHZhbHVlcyBmcm9tIHZpc2l0b3JzLlxuICogQHJldHVybnMge0FjdGlvblR1cGxlfVxuICogICBDbGVhbiByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIHRvUmVzdWx0KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV1cbiAgfVxuXG4gIHJldHVybiBbdmFsdWVdXG59XG4iXSwibmFtZXMiOlsiY29udmVydCIsImNvbG9yIiwiQ09OVElOVUUiLCJFWElUIiwiU0tJUCIsInZpc2l0UGFyZW50cyIsInRyZWUiLCJ0ZXN0IiwidmlzaXRvciIsInJldmVyc2UiLCJpcyIsInN0ZXAiLCJmYWN0b3J5IiwidW5kZWZpbmVkIiwibm9kZSIsImluZGV4IiwicGFyZW50cyIsInZhbHVlIiwidHlwZSIsIm5hbWUiLCJ0YWdOYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2aXNpdCIsInJlc3VsdCIsInN1YnJlc3VsdCIsIm9mZnNldCIsImdyYW5kcGFyZW50cyIsImxlbmd0aCIsInRvUmVzdWx0IiwiY2hpbGRyZW4iLCJjb25jYXQiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/lib/index.js\n");

/***/ })

};
;