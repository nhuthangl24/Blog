"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/rehype-pretty-code/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n    return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n    return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n    return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent) {\n    return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n    return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n    const placeholder = \"\\x00\";\n    let temp = meta.replace(/\\\\\\\\/g, placeholder);\n    temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n    const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n    return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n    let meta = filter(// @ts-expect-error: TODO handle this\n    element.data?.meta ?? element.properties?.metastring ?? \"\");\n    const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n    const title = titleMatch?.[1] ?? null;\n    meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n    const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n    const caption = captionMatch?.[1] ?? null;\n    meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n    let lang = defaultFallback;\n    if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n        lang = element.properties.className[0].replace(\"language-\", \"\");\n    }\n    return {\n        title,\n        caption,\n        lang,\n        meta\n    };\n}\nfunction getThemeNames(theme) {\n    if (isJSONTheme(theme)) {\n        return [\n            theme.name\n        ];\n    }\n    if (typeof theme === \"string\") {\n        return [\n            theme\n        ];\n    }\n    return Object.values(theme).map((theme2)=>typeof theme2 === \"string\" ? theme2 : theme2.name);\n}\nfunction replaceLineClass(element) {\n    if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n        const className = element.properties.className.filter((c)=>c !== \"line\");\n        element.properties.className = className.length > 0 ? className : void 0;\n        element.properties[\"data-line\"] = \"\";\n    }\n}\nfunction getLineId(lineNumber, meta) {\n    const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n    if (!segments) return null;\n    for (const segment of segments){\n        const [range, id] = segment.split(\"#\");\n        if (!(range && id)) continue;\n        const match = range.match(/\\{(.*?)\\}/);\n        const capture = match?.[1];\n        if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n            return id;\n        }\n    }\n    return null;\n}\n// src/chars/splitElement.ts\nfunction splitElement({ elements, elementToWrap, innerString, rightString, leftString, rest, nextElementContinues, index, ignoreChars }) {\n    if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n        return [\n            elementToWrap,\n            index\n        ];\n    }\n    let newIndex = index;\n    const textElement = elementToWrap.children[0];\n    if (isText(textElement)) {\n        textElement.value = innerString;\n    }\n    let rightStr = rightString;\n    const leftStr = leftString;\n    if (rest.length > 0) {\n        rightStr += rest.map((s)=>s === \"\" ? innerString : innerString + s).join(\"\");\n    }\n    if (leftStr.length > 0) {\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: leftStr\n                }\n            ]\n        });\n    }\n    if (rightStr.length > 0 && !nextElementContinues) {\n        newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: rightStr\n                }\n            ]\n        });\n    }\n    return [\n        elementToWrap,\n        index + 1\n    ];\n}\nfunction nextElementMaybeContinuesChars({ elements, nextIndex, remainingPart }) {\n    if (remainingPart === \"\") {\n        return false;\n    }\n    const nextNode = elements[nextIndex];\n    const content = getContent(nextNode);\n    if (!content) {\n        return false;\n    }\n    const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n    const overlap = findOverlap(content, remainingPart);\n    if (overlap === remainingPart && content.startsWith(remainingPart)) {\n        return true;\n    }\n    if (includesNext) {\n        return nextElementMaybeContinuesChars({\n            elements,\n            nextIndex: nextIndex + 1,\n            remainingPart: remainingPart.replace(content, \"\")\n        });\n    }\n    return false;\n}\nfunction getContent(node) {\n    if (!node) return;\n    return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n    if (b.length === 0) {\n        return \"\";\n    }\n    if (a.endsWith(b)) {\n        return b;\n    }\n    if (a.indexOf(b) >= 0) {\n        return b;\n    }\n    return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n    return s.split(\"\").reverse().join(\"\");\n}\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n    const toWrap = [];\n    let charsSoFar = \"\";\n    if (element.children) {\n        const elements = element.children;\n        for(let i = startIndex; i < elements.length; i++){\n            const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n            if (remaining === \"\") {\n                return toWrap;\n            }\n            const maybeElement = elements[i];\n            if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n            Object.hasOwn(maybeElement.properties ?? {}, \"rehype-pretty-code-visited\")) {\n                continue;\n            }\n            const content = getContent(maybeElement) || \"\";\n            if (content === chars || charsSoFar + content === chars) {\n                toWrap.push({\n                    element: maybeElement,\n                    index: i\n                });\n                return toWrap;\n            }\n            if (chars.startsWith(charsSoFar + content)) {\n                if (nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: remaining.replace(content, \"\")\n                })) {\n                    toWrap.push({\n                        element: elements[i],\n                        index: i\n                    });\n                    charsSoFar += content;\n                    continue;\n                }\n            }\n            const overlap = findOverlap(content, remaining);\n            const partialMatch = overlap && remaining.startsWith(overlap);\n            if (partialMatch) {\n                const nextPart = remaining.replace(overlap, \"\");\n                if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: nextPart\n                })) {\n                    continue;\n                }\n                const splitParts = content.split(overlap);\n                const [leftPart, rightPart, ...rest] = splitParts;\n                if (rightPart || leftPart || rest.length > 0) {\n                    const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n                    const nextNodeOverlap = findOverlap(withNextNode, remaining);\n                    const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n                    if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n                        const rightString = rightPart.replace(overlap, \"\");\n                        const innerString = overlap;\n                        const leftString = content.substring(0, splitIndex);\n                        const nextElementContinues = nextElementMaybeContinuesChars({\n                            elements,\n                            nextIndex: i + 1,\n                            remainingPart: nextPart\n                        });\n                        const [newElement, updatedIndex] = splitElement({\n                            elements,\n                            elementToWrap: elements[i],\n                            innerString,\n                            rightString,\n                            leftString,\n                            rest,\n                            nextElementContinues,\n                            index: i,\n                            ignoreChars\n                        });\n                        charsSoFar += overlap;\n                        toWrap.push({\n                            element: newElement,\n                            index: updatedIndex\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return toWrap;\n}\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n    if (!elementsToWrap || elementsToWrap.length === 0) {\n        return;\n    }\n    const [{ element }] = elementsToWrap;\n    if (ignoreWord) {\n        if (element.properties) {\n            element.properties[\"rehype-pretty-code-visited\"] = \"\";\n        }\n        return;\n    }\n    if (elementsToWrap.length > 1) {\n        parentElement.children.splice(elementsToWrap[0].index, elementsToWrap.length, {\n            type: \"element\",\n            tagName: \"mark\",\n            properties: {\n                \"data-highlighted-chars-mark\": \"\"\n            },\n            children: elementsToWrap.map(({ element: element3 })=>element3)\n        });\n        const element2 = parentElement.children[elementsToWrap[0].index];\n        if (!isElement(element2)) {\n            return;\n        }\n        const wordStr = element2.children.reduce((acc, node)=>{\n            const textElement = isElement(node) ? node.children[0] : null;\n            if (isText(textElement)) {\n                return acc + textElement.value;\n            }\n            return acc;\n        }, \"\");\n        const id = options.idsMap.get(wordStr);\n        element2.properties = element2.properties || {};\n        element2.properties[\"data-highlighted-chars\"] = \"\";\n        element2.properties[\"data-chars-id\"] = id;\n        element2.tagName = \"mark\";\n        onVisitHighlightedChars?.(element2, id);\n    } else {\n        const [{ element: element2 }] = elementsToWrap;\n        const textElement = element2.children[0];\n        if (!isText(textElement)) {\n            return;\n        }\n        const id = options.idsMap.get(textElement.value);\n        element2.properties = element2.properties || {};\n        element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n        element2.properties[\"data-highlighted-chars\"] = \"\";\n        element2.properties[\"data-chars-id\"] = id;\n        element2.tagName = \"mark\";\n        element2.children = [\n            {\n                type: \"element\",\n                tagName: \"span\",\n                properties: {\n                    style: element2.properties.style\n                },\n                children: element2.children\n            }\n        ];\n        element2.properties.style = void 0;\n        onVisitHighlightedChars?.(element2, id);\n    }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n    const { ranges = [] } = options;\n    const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n    charsList.forEach((chars, index)=>{\n        if (chars && textContent?.includes(chars)) {\n            let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n            let startIndex = 0;\n            while(textContent2.includes(chars)){\n                const currentCharsRange = ranges[index] || [];\n                const id = `${chars}-${index}`;\n                options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n                const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n                const elementsToWrap = getElementsToHighlight(element, chars, startIndex, ignoreChars);\n                if (elementsToWrap.length === 0) break;\n                wrapHighlightedChars(element, elementsToWrap, options, ignoreChars, onVisitHighlightedChars);\n                startIndex = Math.max(elementsToWrap[elementsToWrap.length - 1].index - 2, 0);\n                textContent2 = element.children.map((childNode)=>{\n                    const props = isElement(childNode) ? childNode.properties : {};\n                    if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n                        return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n                    }\n                }).join(\"\");\n            }\n        }\n    });\n    element.children.forEach((childNode)=>{\n        if (!isElement(childNode)) return;\n        if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n            childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n        }\n    });\n}\n// src/index.ts\nfunction apply(element, { tree, lang, title, caption, inline = false, keepBackground = true, grid = true, lineNumbersMaxDigits = 1, theme, onVisitTitle, onVisitCaption }) {\n    element.tagName = inline ? \"span\" : \"figure\";\n    element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n    const codeData = element.children[0]?.data;\n    element.children = [\n        tree\n    ].map((tree2)=>{\n        const pre = tree2.children[0];\n        const themeNames = getThemeNames(theme);\n        const themeNamesString = themeNames.join(\" \");\n        if (!(isElement(pre) && pre.properties)) {\n            return [];\n        }\n        const code = pre.children[0];\n        if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n            const className = pre.properties.className.filter((c)=>c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true));\n            pre.properties.className = className.length > 0 ? className : void 0;\n        }\n        if (!keepBackground) {\n            pre.properties.style = void 0;\n        }\n        pre.properties[\"data-language\"] = lang;\n        pre.properties[\"data-theme\"] = themeNamesString;\n        if (!(isElement(code) && code.properties)) {\n            return [];\n        }\n        code.properties[\"data-language\"] = lang;\n        code.properties[\"data-theme\"] = themeNamesString;\n        code.data = codeData;\n        if (inline) {\n            if (keepBackground) {\n                code.properties.style = pre.properties.style;\n            }\n            return code;\n        }\n        if (grid) {\n            if (code.properties.style) {\n                code.properties.style += \"display: grid;\";\n            } else {\n                code.properties.style = \"display: grid;\";\n            }\n        }\n        if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n            code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n        }\n        const fragments = [];\n        if (title) {\n            const elementContent = {\n                type: \"element\",\n                tagName: caption ? \"div\" : \"figcaption\",\n                properties: {\n                    \"data-rehype-pretty-code-title\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": themeNamesString\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: title\n                    }\n                ]\n            };\n            onVisitTitle?.(elementContent);\n            fragments.push(elementContent);\n        }\n        fragments.push(pre);\n        if (caption) {\n            const elementContent = {\n                type: \"element\",\n                tagName: \"figcaption\",\n                properties: {\n                    \"data-rehype-pretty-code-caption\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": themeNamesString\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: caption\n                    }\n                ]\n            };\n            onVisitCaption?.(elementContent);\n            fragments.push(elementContent);\n        }\n        return fragments;\n    }).flatMap((c)=>c);\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n    fragment: true\n});\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n    const { grid = true, theme = \"github-dark-dimmed\", keepBackground = true, defaultLang = \"\", tokensMap = {}, filterMetaString = (v)=>v, getHighlighter: getHighlighter$1 = shiki__WEBPACK_IMPORTED_MODULE_0__.getHighlighter, transformers, onVisitLine, onVisitHighlightedLine, onVisitHighlightedChars, onVisitTitle, onVisitCaption } = options;\n    const key = JSON.stringify(theme);\n    let cachedHighlighter = globalHighlighterCache.get(key);\n    if (!cachedHighlighter) {\n        cachedHighlighter = getHighlighter$1({\n            themes: isJSONTheme(theme) || typeof theme === \"string\" ? [\n                theme\n            ] : Object.values(theme),\n            langs: [\n                \"plaintext\"\n            ]\n        });\n        globalHighlighterCache.set(key, cachedHighlighter);\n    }\n    const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n    const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n    function getOptions(lang, meta) {\n        const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n        const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n        return {\n            lang,\n            meta: {\n                __raw: meta\n            },\n            transformers,\n            defaultColor: typeof theme === \"string\" ? theme : false,\n            ...multipleThemes ? {\n                themes: multipleThemes\n            } : {\n                theme: singleTheme\n            }\n        };\n    }\n    return async (tree)=>{\n        const langsToLoad = /* @__PURE__ */ new Set();\n        const highlighter = await cachedHighlighter;\n        if (!highlighter) return;\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent)=>{\n            if (isInlineCode(element, parent)) {\n                const textElement = element.children[0];\n                if (!isText(textElement)) return;\n                const value = textElement.value;\n                if (!value) return;\n                const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n                if (lang && lang[0] !== \".\") {\n                    langsToLoad.add(lang);\n                }\n            }\n            if (isBlockCode(element)) {\n                const codeElement = element.children[0];\n                if (!isElement(codeElement)) return;\n                const { lang } = parseBlockMetaString(codeElement, filterMetaString, defaultCodeBlockLang);\n                if (lang) {\n                    langsToLoad.add(lang);\n                }\n            }\n        });\n        try {\n            await Promise.allSettled(Array.from(langsToLoad).map((lang)=>{\n                try {\n                    return highlighter.loadLanguage(lang);\n                } catch (e) {\n                    return Promise.reject(e);\n                }\n            }));\n        } catch (e) {\n            console.error(e);\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent)=>{\n            if (isInlineCode(element, parent)) {\n                const textElement = element.children[0];\n                if (!isText(textElement)) return;\n                const value = textElement.value;\n                if (!value) return;\n                const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n                const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n                textElement.value = strippedValue;\n                const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n                const isLang = lang[0] !== \".\";\n                if (!lang) return;\n                let codeTree;\n                if (isLang) {\n                    try {\n                        codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(lang)));\n                    } catch  {\n                        codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\")));\n                    }\n                } else {\n                    const themeNames = getThemeNames(theme);\n                    const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n                    const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n                    const colorsByTheme = themeNames.map((name)=>name ? highlighter.getTheme(name).settings.find(({ scope })=>scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1)))?.settings.foreground ?? \"inherit\" : \"inherit\");\n                    if (isMultiTheme && themeKeys) {\n                        codeTree = hastParser.parse(`<pre><code><span style=\"${themeKeys.map((key2, i)=>`--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`);\n                    } else {\n                        codeTree = hastParser.parse(`<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`);\n                    }\n                }\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n                apply(element, {\n                    tree: codeTree,\n                    lang: isLang ? lang : \".token\",\n                    inline: true,\n                    keepBackground,\n                    theme\n                });\n            }\n            if (isBlockCode(element)) {\n                const codeElement = element.children[0];\n                if (!isElement(codeElement)) return;\n                const textElement = codeElement.children[0];\n                const { title, caption, meta, lang } = parseBlockMetaString(codeElement, filterMetaString, defaultCodeBlockLang);\n                if (!lang || lang === \"math\") return;\n                const lineNumbers = [];\n                if (meta) {\n                    const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n                    for (const match of matches){\n                        if (match[1]) {\n                            lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n                        }\n                    }\n                }\n                let lineNumbersMaxDigits = 0;\n                const lineIdMap = /* @__PURE__ */ new Map();\n                const charsList = [];\n                const charsListNumbers = [];\n                const charsListIdMap = /* @__PURE__ */ new Map();\n                const charsMatches = meta ? [\n                    ...meta.matchAll(/(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g)\n                ] : void 0;\n                lineNumbers.forEach((lineNumber)=>{\n                    const id = getLineId(lineNumber, meta);\n                    id && lineIdMap.set(lineNumber, id);\n                });\n                if (Array.isArray(charsMatches)) {\n                    charsMatches.forEach((name)=>{\n                        const { chars, charsIdAndOrRange } = name.groups;\n                        charsList.push(chars);\n                        if (charsIdAndOrRange === \"\") {\n                            charsListNumbers.push([]);\n                        } else {\n                            const [range, id] = charsIdAndOrRange.split(\"#\");\n                            range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n                            id && charsListIdMap.set(chars, id);\n                        }\n                    });\n                }\n                if (!isText(textElement)) return;\n                const strippedValue = textElement.value.replace(/\\n$/, \"\");\n                let codeTree;\n                try {\n                    codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(lang, meta)));\n                } catch  {\n                    codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\", meta)));\n                }\n                let lineCounter = 0;\n                const charsHighlighterOptions = {\n                    ranges: charsListNumbers,\n                    idsMap: charsListIdMap,\n                    counterMap: /* @__PURE__ */ new Map()\n                };\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2)=>{\n                    if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n                        if (element2.properties) {\n                            element2.properties[\"data-line-numbers\"] = \"\";\n                        }\n                        const lineNumbersStartAtMatch = reverseString(meta).match(/(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/);\n                        const startNumberString = lineNumbersStartAtMatch?.[1];\n                        if (startNumberString) {\n                            const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n                            lineNumbersMaxDigits = startAt;\n                            if (element2.properties) {\n                                element2.properties.style = `counter-set: line ${startAt};`;\n                            }\n                        }\n                    }\n                    if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n                        if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n                            element2.children = [\n                                {\n                                    type: \"text\",\n                                    value: \" \"\n                                }\n                            ];\n                        }\n                        replaceLineClass(element2);\n                        onVisitLine?.(element2);\n                        lineCounter++;\n                        if (lineNumbers.includes(lineCounter)) {\n                            element2.properties[\"data-highlighted-line\"] = \"\";\n                            const lineId = lineIdMap.get(lineCounter);\n                            if (lineId) {\n                                element2.properties[\"data-highlighted-line-id\"] = lineId;\n                            }\n                            onVisitHighlightedLine?.(element2, lineId);\n                        }\n                        charsHighlighter(element2, charsList, charsHighlighterOptions, onVisitHighlightedChars);\n                        lineNumbersMaxDigits++;\n                    }\n                });\n                apply(element, {\n                    tree: codeTree,\n                    lang,\n                    title,\n                    caption,\n                    keepBackground,\n                    grid,\n                    lineNumbersMaxDigits,\n                    theme,\n                    onVisitTitle,\n                    onVisitCaption\n                });\n            }\n        });\n    };\n}\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDRTtBQUNNO0FBQ0E7QUFDYjtBQUNLO0FBRXZDLGVBQWU7QUFDZixTQUFTTSxZQUFZQyxLQUFLO0lBQ3hCLE9BQU9BLFFBQVFDLE9BQU9DLE1BQU0sQ0FBQ0YsT0FBTyxpQkFBaUI7QUFDdkQ7QUFDQSxTQUFTRyxVQUFVSCxLQUFLO0lBQ3RCLE9BQU9BLFFBQVFBLE1BQU1JLElBQUksS0FBSyxZQUFZO0FBQzVDO0FBQ0EsU0FBU0MsT0FBT0wsS0FBSztJQUNuQixPQUFPQSxRQUFRQSxNQUFNSSxJQUFJLEtBQUssU0FBUztBQUN6QztBQUNBLFNBQVNFLGFBQWFDLE9BQU8sRUFBRUMsTUFBTTtJQUNuQyxPQUFPRCxRQUFRRSxPQUFPLEtBQUssVUFBVU4sVUFBVUssV0FBV0EsT0FBT0MsT0FBTyxLQUFLLFNBQVNGLFFBQVFFLE9BQU8sS0FBSztBQUM1RztBQUNBLFNBQVNDLFlBQVlILE9BQU87SUFDMUIsT0FBT0EsUUFBUUUsT0FBTyxLQUFLLFNBQVNFLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUU0sUUFBUSxLQUFLTixRQUFRTSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLWCxVQUFVSSxRQUFRTSxRQUFRLENBQUMsRUFBRSxLQUFLTixRQUFRTSxRQUFRLENBQUMsRUFBRSxDQUFDSixPQUFPLEtBQUs7QUFDNUs7QUFDQSxTQUFTTSxrQkFBa0JDLElBQUksRUFBRUMsbUJBQW1CO0lBQ2xELE1BQU1DLGNBQWM7SUFDcEIsSUFBSUMsT0FBT0gsS0FBS0ksT0FBTyxDQUFDLFNBQVNGO0lBQ2pDQyxPQUFPQSxLQUFLQyxPQUFPLENBQUMsdUJBQXVCO0lBQzNDLE1BQU1DLE9BQU9GLEtBQUtHLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFO0lBQ2pELE9BQU9ELE1BQU1ELFFBQVEsSUFBSUcsT0FBT0wsYUFBYSxNQUFN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ckYsdUJBQXVCc0Y7NEJBQ3ZCLElBQUkvRyxTQUFTckYsVUFBVSxFQUFFO2dDQUN2QnFGLFNBQVNyRixVQUFVLENBQUMyRixLQUFLLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRXlHLFFBQVEsQ0FBQyxDQUFDOzRCQUM3RDt3QkFDRjtvQkFDRjtvQkFDQSxJQUFJck4sTUFBTUMsT0FBTyxDQUFDcUcsU0FBU3JGLFVBQVUsRUFBRU0sY0FBYytFLFNBQVNyRixVQUFVLEVBQUVNLFdBQVcsQ0FBQyxFQUFFLEtBQUssUUFBUTt3QkFDbkcsSUFBSXVHLFFBQVE5SSw2REFBUUEsQ0FBQ3NILGNBQWMsSUFBSTs0QkFDckNBLFNBQVNwRyxRQUFRLEdBQUc7Z0NBQUM7b0NBQUVULE1BQU07b0NBQVFKLE9BQU87Z0NBQUk7NkJBQUU7d0JBQ3BEO3dCQUNBMEMsaUJBQWlCdUU7d0JBQ2pCa0QsY0FBY2xEO3dCQUNkMkc7d0JBQ0EsSUFBSVQsWUFBWXhLLFFBQVEsQ0FBQ2lMLGNBQWM7NEJBQ3JDM0csU0FBU3JGLFVBQVUsQ0FBQyx3QkFBd0IsR0FBRzs0QkFDL0MsTUFBTXNNLFNBQVNaLFVBQVVoRyxHQUFHLENBQUNzRzs0QkFDN0IsSUFBSU0sUUFBUTtnQ0FDVmpILFNBQVNyRixVQUFVLENBQUMsMkJBQTJCLEdBQUdzTTs0QkFDcEQ7NEJBQ0E5RCx5QkFBeUJuRCxVQUFVaUg7d0JBQ3JDO3dCQUNBMUcsaUJBQ0VQLFVBQ0FRLFdBQ0FvRyx5QkFDQTlHO3dCQUVGMkI7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FMLE1BQU05SCxTQUFTO29CQUNiK0gsTUFBTStEO29CQUNOaEw7b0JBQ0FVO29CQUNBRTtvQkFDQXVHO29CQUNBQztvQkFDQUM7b0JBQ0FyRztvQkFDQXNHO29CQUNBQztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvZGlzdC9pbmRleC5qcz84Yjc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEhpZ2hsaWdodGVyIH0gZnJvbSAnc2hpa2knO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0JztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnaGFzdC11dGlsLXRvLXN0cmluZyc7XG5pbXBvcnQgcmFuZ2VQYXJzZXIyIGZyb20gJ3BhcnNlLW51bWVyaWMtcmFuZ2UnO1xuaW1wb3J0IHsgdW5pZmllZCB9IGZyb20gJ3VuaWZpZWQnO1xuaW1wb3J0IHJlaHlwZVBhcnNlIGZyb20gJ3JlaHlwZS1wYXJzZSc7XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gaXNKU09OVGhlbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ0b2tlbkNvbG9yc1wiKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09IFwiZWxlbWVudFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUudHlwZSA9PT0gXCJ0ZXh0XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJjb2RlXCIgJiYgaXNFbGVtZW50KHBhcmVudCkgJiYgcGFyZW50LnRhZ05hbWUgIT09IFwicHJlXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcImlubGluZUNvZGVcIjtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tDb2RlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJwcmVcIiAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQuY2hpbGRyZW4pICYmIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGlzRWxlbWVudChlbGVtZW50LmNoaWxkcmVuWzBdKSAmJiBlbGVtZW50LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09IFwiY29kZVwiO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lQ29kZUxhbmcobWV0YSwgZGVmYXVsdEZhbGxiYWNrTGFuZykge1xuICBjb25zdCBwbGFjZWhvbGRlciA9IFwiXFwwXCI7XG4gIGxldCB0ZW1wID0gbWV0YS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBwbGFjZWhvbGRlcik7XG4gIHRlbXAgPSB0ZW1wLnJlcGxhY2UoL1xcXFwoezpbYS16QS1aLi1dK30pJC8sIFwiJDFcIik7XG4gIGNvbnN0IGxhbmcgPSB0ZW1wLm1hdGNoKC97OihbYS16QS1aLi1dKyl9JC8pPy5bMV07XG4gIHJldHVybiBsYW5nPy5yZXBsYWNlKG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsIFwiZ1wiKSwgXCJcXFxcXCIpIHx8IGRlZmF1bHRGYWxsYmFja0xhbmc7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrTWV0YVN0cmluZyhlbGVtZW50LCBmaWx0ZXIsIGRlZmF1bHRGYWxsYmFjaykge1xuICBsZXQgbWV0YSA9IGZpbHRlcihcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUT0RPIGhhbmRsZSB0aGlzXG4gICAgZWxlbWVudC5kYXRhPy5tZXRhID8/IGVsZW1lbnQucHJvcGVydGllcz8ubWV0YXN0cmluZyA/PyBcIlwiXG4gICk7XG4gIGNvbnN0IHRpdGxlTWF0Y2ggPSBtZXRhLm1hdGNoKC90aXRsZT1cIihbXlwiXSopXCIvKTtcbiAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgbWV0YSA9IG1ldGEucmVwbGFjZSh0aXRsZU1hdGNoPy5bMF0gPz8gXCJcIiwgXCJcIik7XG4gIGNvbnN0IGNhcHRpb25NYXRjaCA9IG1ldGEubWF0Y2goL2NhcHRpb249XCIoW15cIl0qKVwiLyk7XG4gIGNvbnN0IGNhcHRpb24gPSBjYXB0aW9uTWF0Y2g/LlsxXSA/PyBudWxsO1xuICBtZXRhID0gbWV0YS5yZXBsYWNlKGNhcHRpb25NYXRjaD8uWzBdID8/IFwiXCIsIFwiXCIpO1xuICBsZXQgbGFuZyA9IGRlZmF1bHRGYWxsYmFjaztcbiAgaWYgKGVsZW1lbnQucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUpICYmIHR5cGVvZiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdID09PSBcInN0cmluZ1wiICYmIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0uc3RhcnRzV2l0aChcImxhbmd1YWdlLVwiKSkge1xuICAgIGxhbmcgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnJlcGxhY2UoXCJsYW5ndWFnZS1cIiwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aXRsZSxcbiAgICBjYXB0aW9uLFxuICAgIGxhbmcsXG4gICAgbWV0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGhlbWVOYW1lcyh0aGVtZSkge1xuICBpZiAoaXNKU09OVGhlbWUodGhlbWUpKSB7XG4gICAgcmV0dXJuIFt0aGVtZS5uYW1lXTtcbiAgfVxuICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFt0aGVtZV07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhlbWUpLm1hcChcbiAgICAodGhlbWUyKSA9PiB0eXBlb2YgdGhlbWUyID09PSBcInN0cmluZ1wiID8gdGhlbWUyIDogdGhlbWUyLm5hbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lQ2xhc3MoZWxlbWVudCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcImxpbmVcIikpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcigoYykgPT4gYyAhPT0gXCJsaW5lXCIpO1xuICAgIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJkYXRhLWxpbmVcIl0gPSBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMaW5lSWQobGluZU51bWJlciwgbWV0YSkge1xuICBjb25zdCBzZWdtZW50cyA9IG1ldGEubWF0Y2goL1xce1tefV0rXFx9I1thLXpBLVowLTldKy9nKTtcbiAgaWYgKCFzZWdtZW50cylcbiAgICByZXR1cm4gbnVsbDtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3QgW3JhbmdlLCBpZF0gPSBzZWdtZW50LnNwbGl0KFwiI1wiKTtcbiAgICBpZiAoIShyYW5nZSAmJiBpZCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBtYXRjaCA9IHJhbmdlLm1hdGNoKC9cXHsoLio/KVxcfS8pO1xuICAgIGNvbnN0IGNhcHR1cmUgPSBtYXRjaD8uWzFdO1xuICAgIGlmIChjYXB0dXJlICYmIHJhbmdlUGFyc2VyMihjYXB0dXJlKS5pbmNsdWRlcyhsaW5lTnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2NoYXJzL3NwbGl0RWxlbWVudC50c1xuZnVuY3Rpb24gc3BsaXRFbGVtZW50KHtcbiAgZWxlbWVudHMsXG4gIGVsZW1lbnRUb1dyYXAsXG4gIGlubmVyU3RyaW5nLFxuICByaWdodFN0cmluZyxcbiAgbGVmdFN0cmluZyxcbiAgcmVzdCxcbiAgbmV4dEVsZW1lbnRDb250aW51ZXMsXG4gIGluZGV4LFxuICBpZ25vcmVDaGFyc1xufSkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnRUb1dyYXApICYmIGVsZW1lbnRUb1dyYXAuY2hpbGRyZW4/LlswXT8udHlwZSAhPT0gXCJ0ZXh0XCIgfHwgaWdub3JlQ2hhcnMpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4XTtcbiAgfVxuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcbiAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50VG9XcmFwLmNoaWxkcmVuWzBdO1xuICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgIHRleHRFbGVtZW50LnZhbHVlID0gaW5uZXJTdHJpbmc7XG4gIH1cbiAgbGV0IHJpZ2h0U3RyID0gcmlnaHRTdHJpbmc7XG4gIGNvbnN0IGxlZnRTdHIgPSBsZWZ0U3RyaW5nO1xuICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgcmlnaHRTdHIgKz0gcmVzdC5tYXAoKHMpID0+IHMgPT09IFwiXCIgPyBpbm5lclN0cmluZyA6IGlubmVyU3RyaW5nICsgcykuam9pbihcIlwiKTtcbiAgfVxuICBpZiAobGVmdFN0ci5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudHMuc3BsaWNlKG5ld0luZGV4LCAwLCB7XG4gICAgICAuLi5lbGVtZW50VG9XcmFwLFxuICAgICAgcHJvcGVydGllczogeyAuLi5lbGVtZW50VG9XcmFwLnByb3BlcnRpZXMgfSxcbiAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGxlZnRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICBpZiAocmlnaHRTdHIubGVuZ3RoID4gMCAmJiAhbmV4dEVsZW1lbnRDb250aW51ZXMpIHtcbiAgICBuZXdJbmRleCA9IGxlZnRTdHIubGVuZ3RoID4gMCA/IG5ld0luZGV4ICsgMiA6IG5ld0luZGV4ICsgMTtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7IC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllcyB9LFxuICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogcmlnaHRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4ICsgMV07XG59XG5mdW5jdGlvbiBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICBlbGVtZW50cyxcbiAgbmV4dEluZGV4LFxuICByZW1haW5pbmdQYXJ0XG59KSB7XG4gIGlmIChyZW1haW5pbmdQYXJ0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5leHROb2RlID0gZWxlbWVudHNbbmV4dEluZGV4XTtcbiAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobmV4dE5vZGUpO1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNOZXh0ID0gY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpIHx8IHJlbWFpbmluZ1BhcnQuc3RhcnRzV2l0aChjb250ZW50KTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZ1BhcnQpO1xuICBpZiAob3ZlcmxhcCA9PT0gcmVtYWluaW5nUGFydCAmJiBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5jbHVkZXNOZXh0KSB7XG4gICAgcmV0dXJuIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICBlbGVtZW50cyxcbiAgICAgIG5leHRJbmRleDogbmV4dEluZGV4ICsgMSxcbiAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZ1BhcnQucmVwbGFjZShjb250ZW50LCBcIlwiKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbnRlbnQobm9kZSkge1xuICBpZiAoIW5vZGUpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gdG9TdHJpbmcobm9kZSk7XG59XG5mdW5jdGlvbiBmaW5kT3ZlcmxhcChhLCBiKSB7XG4gIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChhLmVuZHNXaXRoKGIpKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGEuaW5kZXhPZihiKSA+PSAwKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgcmV0dXJuIGZpbmRPdmVybGFwKGEsIGIuc3Vic3RyaW5nKDAsIGIubGVuZ3RoIC0gMSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvY2hhcnMvZ2V0RWxlbWVudHNUb0hpZ2hsaWdodC50c1xuZnVuY3Rpb24gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChlbGVtZW50LCBjaGFycywgc3RhcnRJbmRleCA9IDAsIGlnbm9yZUNoYXJzID0gZmFsc2UpIHtcbiAgY29uc3QgdG9XcmFwID0gW107XG4gIGxldCBjaGFyc1NvRmFyID0gXCJcIjtcbiAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gY2hhcnNTb0ZhciA/IGNoYXJzLnJlcGxhY2UoY2hhcnNTb0ZhciwgXCJcIikgOiBjaGFycztcbiAgICAgIGlmIChyZW1haW5pbmcgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlRWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKCFtYXliZUVsZW1lbnQgfHwgbWF5YmVFbGVtZW50LnR5cGUgIT09IFwiZWxlbWVudFwiIHx8IC8vIGlnbm9yZSBhbnkgcHJldmlvdXNseSBtYXRjaGVkIGNoYXJzIHdpdGhpblxuICAgICAgT2JqZWN0Lmhhc093bihcbiAgICAgICAgbWF5YmVFbGVtZW50LnByb3BlcnRpZXMgPz8ge30sXG4gICAgICAgIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIlxuICAgICAgKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KG1heWJlRWxlbWVudCkgfHwgXCJcIjtcbiAgICAgIGlmIChjb250ZW50ID09PSBjaGFycyB8fCBjaGFyc1NvRmFyICsgY29udGVudCA9PT0gY2hhcnMpIHtcbiAgICAgICAgdG9XcmFwLnB1c2goeyBlbGVtZW50OiBtYXliZUVsZW1lbnQsIGluZGV4OiBpIH0pO1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJzLnN0YXJ0c1dpdGgoY2hhcnNTb0ZhciArIGNvbnRlbnQpKSB7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogcmVtYWluaW5nLnJlcGxhY2UoY29udGVudCwgXCJcIilcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0b1dyYXAucHVzaCh7IGVsZW1lbnQ6IGVsZW1lbnRzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgICBjaGFyc1NvRmFyICs9IGNvbnRlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBmaW5kT3ZlcmxhcChjb250ZW50LCByZW1haW5pbmcpO1xuICAgICAgY29uc3QgcGFydGlhbE1hdGNoID0gb3ZlcmxhcCAmJiByZW1haW5pbmcuc3RhcnRzV2l0aChvdmVybGFwKTtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmV4dFBhcnQgPSByZW1haW5pbmcucmVwbGFjZShvdmVybGFwLCBcIlwiKTtcbiAgICAgICAgaWYgKG5leHRQYXJ0ICE9PSBcIlwiICYmIGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSAmJiAhbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IG5leHRQYXJ0XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BsaXRQYXJ0cyA9IGNvbnRlbnQuc3BsaXQob3ZlcmxhcCk7XG4gICAgICAgIGNvbnN0IFtsZWZ0UGFydCwgcmlnaHRQYXJ0LCAuLi5yZXN0XSA9IHNwbGl0UGFydHM7XG4gICAgICAgIGlmIChyaWdodFBhcnQgfHwgbGVmdFBhcnQgfHwgcmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgd2l0aE5leHROb2RlID0gY29udGVudCArIChnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgPyBnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgOiBcIlwiKTtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZU92ZXJsYXAgPSBmaW5kT3ZlcmxhcCh3aXRoTmV4dE5vZGUsIHJlbWFpbmluZyk7XG4gICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHdpdGhOZXh0Tm9kZS5pbmRleE9mKG5leHROb2RlT3ZlcmxhcCk7XG4gICAgICAgICAgaWYgKGNoYXJzLmVuZHNXaXRoKG92ZXJsYXApIHx8IGNoYXJzLnN0YXJ0c1dpdGgob3ZlcmxhcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RyaW5nID0gcmlnaHRQYXJ0LnJlcGxhY2Uob3ZlcmxhcCwgXCJcIik7XG4gICAgICAgICAgICBjb25zdCBpbm5lclN0cmluZyA9IG92ZXJsYXA7XG4gICAgICAgICAgICBjb25zdCBsZWZ0U3RyaW5nID0gY29udGVudC5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RWxlbWVudENvbnRpbnVlcyA9IG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbbmV3RWxlbWVudCwgdXBkYXRlZEluZGV4XSA9IHNwbGl0RWxlbWVudCh7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgICBlbGVtZW50VG9XcmFwOiBlbGVtZW50c1tpXSxcbiAgICAgICAgICAgICAgaW5uZXJTdHJpbmcsXG4gICAgICAgICAgICAgIHJpZ2h0U3RyaW5nLFxuICAgICAgICAgICAgICBsZWZ0U3RyaW5nLFxuICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgICBuZXh0RWxlbWVudENvbnRpbnVlcyxcbiAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoYXJzU29GYXIgKz0gb3ZlcmxhcDtcbiAgICAgICAgICAgIHRvV3JhcC5wdXNoKHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcbiAgICAgICAgICAgICAgaW5kZXg6IHVwZGF0ZWRJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1dyYXA7XG59XG5cbi8vIHNyYy9jaGFycy93cmFwSGlnaGxpZ2h0ZWRDaGFycy50c1xuZnVuY3Rpb24gd3JhcEhpZ2hsaWdodGVkQ2hhcnMocGFyZW50RWxlbWVudCwgZWxlbWVudHNUb1dyYXAsIG9wdGlvbnMsIGlnbm9yZVdvcmQsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGlmICghZWxlbWVudHNUb1dyYXAgfHwgZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt7IGVsZW1lbnQgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgaWYgKGlnbm9yZVdvcmQpIHtcbiAgICBpZiAoZWxlbWVudC5wcm9wZXJ0aWVzKSB7XG4gICAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID4gMSkge1xuICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgZWxlbWVudHNUb1dyYXBbMF0uaW5kZXgsXG4gICAgICBlbGVtZW50c1RvV3JhcC5sZW5ndGgsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcIm1hcmtcIixcbiAgICAgICAgcHJvcGVydGllczogeyBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiOiBcIlwiIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50c1RvV3JhcC5tYXAoKHsgZWxlbWVudDogZWxlbWVudDMgfSkgPT4gZWxlbWVudDMpXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBlbGVtZW50MiA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudHNUb1dyYXBbMF0uaW5kZXhdO1xuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3b3JkU3RyID0gZWxlbWVudDIuY2hpbGRyZW4ucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gaXNFbGVtZW50KG5vZGUpID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWNjICsgdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFwiXCIpO1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZHNNYXAuZ2V0KHdvcmRTdHIpO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMgPSBlbGVtZW50Mi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1jaGFycy1pZFwiXSA9IGlkO1xuICAgIGVsZW1lbnQyLnRhZ05hbWUgPSBcIm1hcmtcIjtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3sgZWxlbWVudDogZWxlbWVudDIgfV0gPSBlbGVtZW50c1RvV3JhcDtcbiAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQyLmNoaWxkcmVuWzBdO1xuICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh0ZXh0RWxlbWVudC52YWx1ZSk7XG4gICAgZWxlbWVudDIucHJvcGVydGllcyA9IGVsZW1lbnQyLnByb3BlcnRpZXMgfHwge307XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1jaGFyc1wiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtY2hhcnMtaWRcIl0gPSBpZDtcbiAgICBlbGVtZW50Mi50YWdOYW1lID0gXCJtYXJrXCI7XG4gICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHN0eWxlOiBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBlbGVtZW50Mi5jaGlsZHJlblxuICAgICAgfVxuICAgIF07XG4gICAgZWxlbWVudDIucHJvcGVydGllcy5zdHlsZSA9IHZvaWQgMDtcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycz8uKGVsZW1lbnQyLCBpZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYXJzSGlnaGxpZ2h0ZXIoZWxlbWVudCwgY2hhcnNMaXN0LCBvcHRpb25zLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBjb25zdCB7IHJhbmdlcyA9IFtdIH0gPSBvcHRpb25zO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRvU3RyaW5nKGVsZW1lbnQpO1xuICBjaGFyc0xpc3QuZm9yRWFjaCgoY2hhcnMsIGluZGV4KSA9PiB7XG4gICAgaWYgKGNoYXJzICYmIHRleHRDb250ZW50Py5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgIGxldCB0ZXh0Q29udGVudDIgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICh0ZXh0Q29udGVudDIuaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFyc1JhbmdlID0gcmFuZ2VzW2luZGV4XSB8fCBbXTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHtjaGFyc30tJHtpbmRleH1gO1xuICAgICAgICBvcHRpb25zLmNvdW50ZXJNYXAuc2V0KGlkLCAob3B0aW9ucy5jb3VudGVyTWFwLmdldChpZCkgfHwgMCkgKyAxKTtcbiAgICAgICAgY29uc3QgaWdub3JlQ2hhcnMgPSBjdXJyZW50Q2hhcnNSYW5nZS5sZW5ndGggPiAwICYmICFjdXJyZW50Q2hhcnNSYW5nZS5pbmNsdWRlcyhvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSA/PyAtMSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzVG9XcmFwID0gZ2V0RWxlbWVudHNUb0hpZ2hsaWdodChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGNoYXJzLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgaWdub3JlQ2hhcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgd3JhcEhpZ2hsaWdodGVkQ2hhcnMoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGlnbm9yZUNoYXJzLFxuICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICk7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heChcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcFtlbGVtZW50c1RvV3JhcC5sZW5ndGggLSAxXS5pbmRleCAtIDIsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBlbGVtZW50LmNoaWxkcmVuLm1hcCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBpc0VsZW1lbnQoY2hpbGROb2RlKSA/IGNoaWxkTm9kZS5wcm9wZXJ0aWVzIDoge307XG4gICAgICAgICAgaWYgKHByb3BzICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCIpICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgaWYgKCFpc0VsZW1lbnQoY2hpbGROb2RlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjaGlsZE5vZGUucHJvcGVydGllcywgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiKSkge1xuICAgICAgY2hpbGROb2RlLnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGFwcGx5KGVsZW1lbnQsIHtcbiAgdHJlZSxcbiAgbGFuZyxcbiAgdGl0bGUsXG4gIGNhcHRpb24sXG4gIGlubGluZSA9IGZhbHNlLFxuICBrZWVwQmFja2dyb3VuZCA9IHRydWUsXG4gIGdyaWQgPSB0cnVlLFxuICBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDEsXG4gIHRoZW1lLFxuICBvblZpc2l0VGl0bGUsXG4gIG9uVmlzaXRDYXB0aW9uXG59KSB7XG4gIGVsZW1lbnQudGFnTmFtZSA9IGlubGluZSA/IFwic3BhblwiIDogXCJmaWd1cmVcIjtcbiAgZWxlbWVudC5wcm9wZXJ0aWVzW1wiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtZmlndXJlXCJdID0gXCJcIjtcbiAgY29uc3QgY29kZURhdGEgPSBlbGVtZW50LmNoaWxkcmVuWzBdPy5kYXRhO1xuICBlbGVtZW50LmNoaWxkcmVuID0gW3RyZWVdLm1hcCgodHJlZTIpID0+IHtcbiAgICBjb25zdCBwcmUgPSB0cmVlMi5jaGlsZHJlblswXTtcbiAgICBjb25zdCB0aGVtZU5hbWVzID0gZ2V0VGhlbWVOYW1lcyh0aGVtZSk7XG4gICAgY29uc3QgdGhlbWVOYW1lc1N0cmluZyA9IHRoZW1lTmFtZXMuam9pbihcIiBcIik7XG4gICAgaWYgKCEoaXNFbGVtZW50KHByZSkgJiYgcHJlLnByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBwcmUuY2hpbGRyZW5bMF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuaW5jbHVkZXMoXCJzaGlraVwiKSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcihcbiAgICAgICAgKGMpID0+IGMgIT09IFwic2hpa2lcIiAmJiBjICE9PSBcInNoaWtpLXRoZW1lc1wiICYmICh0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiA/ICF0aGVtZU5hbWVzLmluY2x1ZGVzKGMpIDogdHJ1ZSlcbiAgICAgICk7XG4gICAgICBwcmUucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCFrZWVwQmFja2dyb3VuZCkge1xuICAgICAgcHJlLnByb3BlcnRpZXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHByZS5wcm9wZXJ0aWVzW1wiZGF0YS1sYW5ndWFnZVwiXSA9IGxhbmc7XG4gICAgcHJlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBpZiAoIShpc0VsZW1lbnQoY29kZSkgJiYgY29kZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxhbmd1YWdlXCJdID0gbGFuZztcbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBjb2RlLmRhdGEgPSBjb2RlRGF0YTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBpZiAoa2VlcEJhY2tncm91bmQpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgaWYgKGdyaWQpIHtcbiAgICAgIGlmIChjb2RlLnByb3BlcnRpZXMuc3R5bGUpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlICs9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSA9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY29kZS5wcm9wZXJ0aWVzLCBcImRhdGEtbGluZS1udW1iZXJzXCIpKSB7XG4gICAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxpbmUtbnVtYmVycy1tYXgtZGlnaXRzXCJdID0gbGluZU51bWJlcnNNYXhEaWdpdHMudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBjYXB0aW9uID8gXCJkaXZcIiA6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS10aXRsZVwiOiBcIlwiLFxuICAgICAgICAgIFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLFxuICAgICAgICAgIFwiZGF0YS10aGVtZVwiOiB0aGVtZU5hbWVzU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRpdGxlIH1dXG4gICAgICB9O1xuICAgICAgb25WaXNpdFRpdGxlPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICBmcmFnbWVudHMucHVzaChwcmUpO1xuICAgIGlmIChjYXB0aW9uKSB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS1jYXB0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcsXG4gICAgICAgICAgXCJkYXRhLXRoZW1lXCI6IHRoZW1lTmFtZXNTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogY2FwdGlvbiB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRDYXB0aW9uPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xuICB9KS5mbGF0TWFwKChjKSA9PiBjKTtcbn1cbnZhciBnbG9iYWxIaWdobGlnaHRlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBoYXN0UGFyc2VyID0gdW5pZmllZCgpLnVzZShyZWh5cGVQYXJzZSwgeyBmcmFnbWVudDogdHJ1ZSB9KTtcbnZhciBzcmNfZGVmYXVsdCA9IHJlaHlwZVByZXR0eUNvZGU7XG5mdW5jdGlvbiByZWh5cGVQcmV0dHlDb2RlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZ3JpZCA9IHRydWUsXG4gICAgdGhlbWUgPSBcImdpdGh1Yi1kYXJrLWRpbW1lZFwiLFxuICAgIGtlZXBCYWNrZ3JvdW5kID0gdHJ1ZSxcbiAgICBkZWZhdWx0TGFuZyA9IFwiXCIsXG4gICAgdG9rZW5zTWFwID0ge30sXG4gICAgZmlsdGVyTWV0YVN0cmluZyA9ICh2KSA9PiB2LFxuICAgIGdldEhpZ2hsaWdodGVyOiBnZXRIaWdobGlnaHRlciQxID0gZ2V0SGlnaGxpZ2h0ZXIsXG4gICAgdHJhbnNmb3JtZXJzLFxuICAgIG9uVmlzaXRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMsXG4gICAgb25WaXNpdFRpdGxlLFxuICAgIG9uVmlzaXRDYXB0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh0aGVtZSk7XG4gIGxldCBjYWNoZWRIaWdobGlnaHRlciA9IGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICghY2FjaGVkSGlnaGxpZ2h0ZXIpIHtcbiAgICBjYWNoZWRIaWdobGlnaHRlciA9IGdldEhpZ2hsaWdodGVyJDEoe1xuICAgICAgdGhlbWVzOiBpc0pTT05UaGVtZSh0aGVtZSkgfHwgdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gW3RoZW1lXSA6IE9iamVjdC52YWx1ZXModGhlbWUpLFxuICAgICAgbGFuZ3M6IFtcInBsYWludGV4dFwiXVxuICAgIH0pO1xuICAgIGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuc2V0KGtleSwgY2FjaGVkSGlnaGxpZ2h0ZXIpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRDb2RlQmxvY2tMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSBcInN0cmluZ1wiID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5ibG9jayB8fCBcIlwiO1xuICBjb25zdCBkZWZhdWx0SW5saW5lQ29kZUxhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0TGFuZyA6IGRlZmF1bHRMYW5nLmlubGluZSB8fCBcIlwiO1xuICBmdW5jdGlvbiBnZXRPcHRpb25zKGxhbmcsIG1ldGEpIHtcbiAgICBjb25zdCBtdWx0aXBsZVRoZW1lcyA9ICFpc0pTT05UaGVtZSh0aGVtZSkgJiYgdHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiID8gdGhlbWUgOiBudWxsO1xuICAgIGNvbnN0IHNpbmdsZVRoZW1lID0gaXNKU09OVGhlbWUodGhlbWUpIHx8IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZyxcbiAgICAgIG1ldGE6IHsgX19yYXc6IG1ldGEgfSxcbiAgICAgIHRyYW5zZm9ybWVycyxcbiAgICAgIGRlZmF1bHRDb2xvcjogdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBmYWxzZSxcbiAgICAgIC4uLm11bHRpcGxlVGhlbWVzID8geyB0aGVtZXM6IG11bHRpcGxlVGhlbWVzIH0gOiB7IHRoZW1lOiBzaW5nbGVUaGVtZSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXN5bmMgKHRyZWUpID0+IHtcbiAgICBjb25zdCBsYW5nc1RvTG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZXIgPSBhd2FpdCBjYWNoZWRIaWdobGlnaHRlcjtcbiAgICBpZiAoIWhpZ2hsaWdodGVyKVxuICAgICAgcmV0dXJuO1xuICAgIHZpc2l0KHRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudCwgXywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFuZyA9IGdldElubGluZUNvZGVMYW5nKHZhbHVlLCBkZWZhdWx0SW5saW5lQ29kZUxhbmcpO1xuICAgICAgICBpZiAobGFuZyAmJiBsYW5nWzBdICE9PSBcIi5cIikge1xuICAgICAgICAgIGxhbmdzVG9Mb2FkLmFkZChsYW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBsYW5nIH0gPSBwYXJzZUJsb2NrTWV0YVN0cmluZyhcbiAgICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgICBmaWx0ZXJNZXRhU3RyaW5nLFxuICAgICAgICAgIGRlZmF1bHRDb2RlQmxvY2tMYW5nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgbGFuZ3NUb0xvYWQuYWRkKGxhbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgICAgQXJyYXkuZnJvbShsYW5nc1RvTG9hZCkubWFwKChsYW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRlci5sb2FkTGFuZ3VhZ2UoXG4gICAgICAgICAgICAgIGxhbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdmlzaXQodHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50LCBfLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50KSkge1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBrZWVwTGFuZ1BhcnQgPSAvXFxcXHs6W2EtekEtWi4tXSt9JC8udGVzdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSBrZWVwTGFuZ1BhcnQgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcKHs6W2EtekEtWi4tXSt9KSQvLCBcIiQxXCIpIDogdmFsdWUucmVwbGFjZSgvezpbYS16QS1aLi1dK30kLywgXCJcIik7XG4gICAgICAgIHRleHRFbGVtZW50LnZhbHVlID0gc3RyaXBwZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgbGFuZyA9IGtlZXBMYW5nUGFydCA/IFwiXCIgOiBnZXRJbmxpbmVDb2RlTGFuZyh2YWx1ZSwgZGVmYXVsdElubGluZUNvZGVMYW5nKTtcbiAgICAgICAgY29uc3QgaXNMYW5nID0gbGFuZ1swXSAhPT0gXCIuXCI7XG4gICAgICAgIGlmICghbGFuZylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgaWYgKGlzTGFuZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhsYW5nKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBnZXRUaGVtZU5hbWVzKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCBpc011bHRpVGhlbWUgPSB0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgJiYgIWlzSlNPTlRoZW1lKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCB0aGVtZUtleXMgPSBpc011bHRpVGhlbWUgPyBPYmplY3Qua2V5cyh0aGVtZSkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGNvbG9yc0J5VGhlbWUgPSB0aGVtZU5hbWVzLm1hcChcbiAgICAgICAgICAgIChuYW1lKSA9PiBuYW1lID8gaGlnaGxpZ2h0ZXIuZ2V0VGhlbWUobmFtZSkuc2V0dGluZ3MuZmluZChcbiAgICAgICAgICAgICAgKHsgc2NvcGUgfSkgPT4gc2NvcGU/LmluY2x1ZGVzKHRva2Vuc01hcFtsYW5nLnNsaWNlKDEpXSA/PyBsYW5nLnNsaWNlKDEpKVxuICAgICAgICAgICAgKT8uc2V0dGluZ3MuZm9yZWdyb3VuZCA/PyBcImluaGVyaXRcIiA6IFwiaW5oZXJpdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNNdWx0aVRoZW1lICYmIHRoZW1lS2V5cykge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cIiR7dGhlbWVLZXlzLm1hcCgoa2V5MiwgaSkgPT4gYC0tc2hpa2ktJHtrZXkyfToke2NvbG9yc0J5VGhlbWVbaV19YCkuam9pbihcIjtcIil9XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cImNvbG9yOiR7Y29sb3JzQnlUaGVtZVswXX1cIj4ke3N0cmlwcGVkVmFsdWV9PC9zcGFuPjwvY29kZT48L3ByZT5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIHJlcGxhY2VMaW5lQ2xhc3MpO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZzogaXNMYW5nID8gbGFuZyA6IFwiLnRva2VuXCIsXG4gICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIHRoZW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBjb2RlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgY2FwdGlvbiwgbWV0YSwgbGFuZyB9ID0gcGFyc2VCbG9ja01ldGFTdHJpbmcoXG4gICAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgICAgZmlsdGVyTWV0YVN0cmluZyxcbiAgICAgICAgICBkZWZhdWx0Q29kZUJsb2NrTGFuZ1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWxhbmcgfHwgbGFuZyA9PT0gXCJtYXRoXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBtZXRhLm1hdGNoQWxsKC9cXEJcXHsoLio/KVxcfVxcQi9nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICBsaW5lTnVtYmVycy5wdXNoKC4uLnJhbmdlUGFyc2VyMihtYXRjaFsxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAwO1xuICAgICAgICBjb25zdCBsaW5lSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0TnVtYmVycyA9IFtdO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3RJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNoYXJzTWF0Y2hlcyA9IG1ldGEgPyBbXG4gICAgICAgICAgLi4ubWV0YS5tYXRjaEFsbChcbiAgICAgICAgICAgIC8oPzxkZWxpbWl0ZXI+W1wiL10pKD88Y2hhcnM+Lio/KVxcazxkZWxpbWl0ZXI+KD88Y2hhcnNJZEFuZE9yUmFuZ2U+XFxTKikvZ1xuICAgICAgICAgIClcbiAgICAgICAgXSA6IHZvaWQgMDtcbiAgICAgICAgbGluZU51bWJlcnMuZm9yRWFjaCgobGluZU51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2V0TGluZUlkKGxpbmVOdW1iZXIsIG1ldGEpO1xuICAgICAgICAgIGlkICYmIGxpbmVJZE1hcC5zZXQobGluZU51bWJlciwgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhcnNNYXRjaGVzKSkge1xuICAgICAgICAgIGNoYXJzTWF0Y2hlcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYXJzLCBjaGFyc0lkQW5kT3JSYW5nZSB9ID0gbmFtZS5ncm91cHM7XG4gICAgICAgICAgICBjaGFyc0xpc3QucHVzaChjaGFycyk7XG4gICAgICAgICAgICBpZiAoY2hhcnNJZEFuZE9yUmFuZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgY2hhcnNMaXN0TnVtYmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtyYW5nZSwgaWRdID0gY2hhcnNJZEFuZE9yUmFuZ2Uuc3BsaXQoXCIjXCIpO1xuICAgICAgICAgICAgICByYW5nZSAmJiBjaGFyc0xpc3ROdW1iZXJzLnB1c2gocmFuZ2VQYXJzZXIyKHJhbmdlKSk7XG4gICAgICAgICAgICAgIGlkICYmIGNoYXJzTGlzdElkTWFwLnNldChjaGFycywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMobGFuZywgbWV0YSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChcbiAgICAgICAgICAgICAgc3RyaXBwZWRWYWx1ZSxcbiAgICAgICAgICAgICAgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiLCBtZXRhKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVDb3VudGVyID0gMDtcbiAgICAgICAgY29uc3QgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgcmFuZ2VzOiBjaGFyc0xpc3ROdW1iZXJzLFxuICAgICAgICAgIGlkc01hcDogY2hhcnNMaXN0SWRNYXAsXG4gICAgICAgICAgY291bnRlck1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50MikgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50Mi50YWdOYW1lID09PSBcImNvZGVcIiAmJiAvc3JlYm11TmVuaUx3b2hzKD8hKC4qKShcXC8pKS8udGVzdChyZXZlcnNlU3RyaW5nKG1ldGEpKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtbGluZS1udW1iZXJzXCJdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoID0gcmV2ZXJzZVN0cmluZyhtZXRhKS5tYXRjaChcbiAgICAgICAgICAgICAgLyg/OlxcfShcXGQrKXspP3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnROdW1iZXJTdHJpbmcgPSBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaD8uWzFdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtYmVyU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXQgPSBzdGFydE51bWJlclN0cmluZyA/IE51bWJlcihyZXZlcnNlU3RyaW5nKHN0YXJ0TnVtYmVyU3RyaW5nKSkgLSAxIDogMDtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSBzdGFydEF0O1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudDIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGUgPSBgY291bnRlci1zZXQ6IGxpbmUgJHtzdGFydEF0fTtgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQyLnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudDIucHJvcGVydGllcz8uY2xhc3NOYW1lPy5bMF0gPT09IFwibGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZCAmJiB0b1N0cmluZyhlbGVtZW50MikgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZUxpbmVDbGFzcyhlbGVtZW50Mik7XG4gICAgICAgICAgICBvblZpc2l0TGluZT8uKGVsZW1lbnQyKTtcbiAgICAgICAgICAgIGxpbmVDb3VudGVyKys7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlcnMuaW5jbHVkZXMobGluZUNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmVcIl0gPSBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lSWQgPSBsaW5lSWRNYXAuZ2V0KGxpbmVDb3VudGVyKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVJZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmUtaWRcIl0gPSBsaW5lSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkTGluZT8uKGVsZW1lbnQyLCBsaW5lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlcihcbiAgICAgICAgICAgICAgZWxlbWVudDIsXG4gICAgICAgICAgICAgIGNoYXJzTGlzdCxcbiAgICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBjYXB0aW9uLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMsXG4gICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgb25WaXNpdFRpdGxlLFxuICAgICAgICAgIG9uVmlzaXRDYXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgeyBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0LCByZWh5cGVQcmV0dHlDb2RlIH07XG4iXSwibmFtZXMiOlsiZ2V0SGlnaGxpZ2h0ZXIiLCJ2aXNpdCIsInRvU3RyaW5nIiwicmFuZ2VQYXJzZXIyIiwidW5pZmllZCIsInJlaHlwZVBhcnNlIiwiaXNKU09OVGhlbWUiLCJ2YWx1ZSIsIk9iamVjdCIsImhhc093biIsImlzRWxlbWVudCIsInR5cGUiLCJpc1RleHQiLCJpc0lubGluZUNvZGUiLCJlbGVtZW50IiwicGFyZW50IiwidGFnTmFtZSIsImlzQmxvY2tDb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJnZXRJbmxpbmVDb2RlTGFuZyIsIm1ldGEiLCJkZWZhdWx0RmFsbGJhY2tMYW5nIiwicGxhY2Vob2xkZXIiLCJ0ZW1wIiwicmVwbGFjZSIsImxhbmciLCJtYXRjaCIsIlJlZ0V4cCIsInBhcnNlQmxvY2tNZXRhU3RyaW5nIiwiZmlsdGVyIiwiZGVmYXVsdEZhbGxiYWNrIiwiZGF0YSIsInByb3BlcnRpZXMiLCJtZXRhc3RyaW5nIiwidGl0bGVNYXRjaCIsInRpdGxlIiwiY2FwdGlvbk1hdGNoIiwiY2FwdGlvbiIsImNsYXNzTmFtZSIsInN0YXJ0c1dpdGgiLCJnZXRUaGVtZU5hbWVzIiwidGhlbWUiLCJuYW1lIiwidmFsdWVzIiwibWFwIiwidGhlbWUyIiwicmVwbGFjZUxpbmVDbGFzcyIsImluY2x1ZGVzIiwiYyIsImdldExpbmVJZCIsImxpbmVOdW1iZXIiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJyYW5nZSIsImlkIiwic3BsaXQiLCJjYXB0dXJlIiwic3BsaXRFbGVtZW50IiwiZWxlbWVudHMiLCJlbGVtZW50VG9XcmFwIiwiaW5uZXJTdHJpbmciLCJyaWdodFN0cmluZyIsImxlZnRTdHJpbmciLCJyZXN0IiwibmV4dEVsZW1lbnRDb250aW51ZXMiLCJpbmRleCIsImlnbm9yZUNoYXJzIiwibmV3SW5kZXgiLCJ0ZXh0RWxlbWVudCIsInJpZ2h0U3RyIiwibGVmdFN0ciIsInMiLCJqb2luIiwic3BsaWNlIiwibmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzIiwibmV4dEluZGV4IiwicmVtYWluaW5nUGFydCIsIm5leHROb2RlIiwiY29udGVudCIsImdldENvbnRlbnQiLCJpbmNsdWRlc05leHQiLCJvdmVybGFwIiwiZmluZE92ZXJsYXAiLCJub2RlIiwiYSIsImIiLCJlbmRzV2l0aCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyZXZlcnNlU3RyaW5nIiwicmV2ZXJzZSIsImdldEVsZW1lbnRzVG9IaWdobGlnaHQiLCJjaGFycyIsInN0YXJ0SW5kZXgiLCJ0b1dyYXAiLCJjaGFyc1NvRmFyIiwiaSIsInJlbWFpbmluZyIsIm1heWJlRWxlbWVudCIsInB1c2giLCJwYXJ0aWFsTWF0Y2giLCJuZXh0UGFydCIsInNwbGl0UGFydHMiLCJsZWZ0UGFydCIsInJpZ2h0UGFydCIsIndpdGhOZXh0Tm9kZSIsIm5leHROb2RlT3ZlcmxhcCIsInNwbGl0SW5kZXgiLCJuZXdFbGVtZW50IiwidXBkYXRlZEluZGV4Iiwid3JhcEhpZ2hsaWdodGVkQ2hhcnMiLCJwYXJlbnRFbGVtZW50IiwiZWxlbWVudHNUb1dyYXAiLCJvcHRpb25zIiwiaWdub3JlV29yZCIsIm9uVmlzaXRIaWdobGlnaHRlZENoYXJzIiwiZWxlbWVudDMiLCJlbGVtZW50MiIsIndvcmRTdHIiLCJyZWR1Y2UiLCJhY2MiLCJpZHNNYXAiLCJnZXQiLCJzdHlsZSIsImNoYXJzSGlnaGxpZ2h0ZXIiLCJjaGFyc0xpc3QiLCJyYW5nZXMiLCJ0ZXh0Q29udGVudCIsImZvckVhY2giLCJ0ZXh0Q29udGVudDIiLCJjdXJyZW50Q2hhcnNSYW5nZSIsImNvdW50ZXJNYXAiLCJzZXQiLCJNYXRoIiwibWF4IiwiY2hpbGROb2RlIiwicHJvcHMiLCJhcHBseSIsInRyZWUiLCJpbmxpbmUiLCJrZWVwQmFja2dyb3VuZCIsImdyaWQiLCJsaW5lTnVtYmVyc01heERpZ2l0cyIsIm9uVmlzaXRUaXRsZSIsIm9uVmlzaXRDYXB0aW9uIiwiY29kZURhdGEiLCJ0cmVlMiIsInByZSIsInRoZW1lTmFtZXMiLCJ0aGVtZU5hbWVzU3RyaW5nIiwiY29kZSIsImZyYWdtZW50cyIsImVsZW1lbnRDb250ZW50IiwiZmxhdE1hcCIsImdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUiLCJNYXAiLCJoYXN0UGFyc2VyIiwidXNlIiwiZnJhZ21lbnQiLCJzcmNfZGVmYXVsdCIsInJlaHlwZVByZXR0eUNvZGUiLCJkZWZhdWx0TGFuZyIsInRva2Vuc01hcCIsImZpbHRlck1ldGFTdHJpbmciLCJ2IiwiZ2V0SGlnaGxpZ2h0ZXIkMSIsInRyYW5zZm9ybWVycyIsIm9uVmlzaXRMaW5lIiwib25WaXNpdEhpZ2hsaWdodGVkTGluZSIsImtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYWNoZWRIaWdobGlnaHRlciIsInRoZW1lcyIsImxhbmdzIiwiZGVmYXVsdENvZGVCbG9ja0xhbmciLCJibG9jayIsImRlZmF1bHRJbmxpbmVDb2RlTGFuZyIsImdldE9wdGlvbnMiLCJtdWx0aXBsZVRoZW1lcyIsInNpbmdsZVRoZW1lIiwiX19yYXciLCJkZWZhdWx0Q29sb3IiLCJsYW5nc1RvTG9hZCIsIlNldCIsImhpZ2hsaWdodGVyIiwiXyIsImFkZCIsImNvZGVFbGVtZW50IiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJmcm9tIiwibG9hZExhbmd1YWdlIiwiZSIsInJlamVjdCIsImNvbnNvbGUiLCJlcnJvciIsImtlZXBMYW5nUGFydCIsInRlc3QiLCJzdHJpcHBlZFZhbHVlIiwiaXNMYW5nIiwiY29kZVRyZWUiLCJwYXJzZSIsImNvZGVUb0h0bWwiLCJpc011bHRpVGhlbWUiLCJ0aGVtZUtleXMiLCJrZXlzIiwiY29sb3JzQnlUaGVtZSIsImdldFRoZW1lIiwic2V0dGluZ3MiLCJmaW5kIiwic2NvcGUiLCJzbGljZSIsImZvcmVncm91bmQiLCJrZXkyIiwibGluZU51bWJlcnMiLCJtYXRjaGVzIiwibWF0Y2hBbGwiLCJsaW5lSWRNYXAiLCJjaGFyc0xpc3ROdW1iZXJzIiwiY2hhcnNMaXN0SWRNYXAiLCJjaGFyc01hdGNoZXMiLCJjaGFyc0lkQW5kT3JSYW5nZSIsImdyb3VwcyIsImxpbmVDb3VudGVyIiwiY2hhcnNIaWdobGlnaHRlck9wdGlvbnMiLCJsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaCIsInN0YXJ0TnVtYmVyU3RyaW5nIiwic3RhcnRBdCIsIk51bWJlciIsImxpbmVJZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/callable-instance.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/node_modules/unified/lib/callable-instance.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CallableInstance: () => (/* binding */ CallableInstance)\n/* harmony export */ });\nconst CallableInstance = /** @type {unknown} */ /**\n       * @this {Function}\n       * @param {string | symbol} property\n       * @returns {(...parameters: Array<unknown>) => unknown}\n       */ function(property) {\n    const self = this;\n    const constr = self.constructor;\n    const proto = /** @type {Record<string | symbol, Function>} */ // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    constr.prototype;\n    const value = proto[property];\n    /** @type {(...parameters: Array<unknown>) => unknown} */ const apply = function() {\n        return value.apply(apply, arguments);\n    };\n    Object.setPrototypeOf(apply, proto);\n    // Not needed for us in `unified`: we only call this on the `copy`\n    // function,\n    // and we don't need to add its fields (`length`, `name`)\n    // over.\n    // See also: GH-246.\n    // const names = Object.getOwnPropertyNames(value)\n    //\n    // for (const p of names) {\n    //   const descriptor = Object.getOwnPropertyDescriptor(value, p)\n    //   if (descriptor) Object.defineProperty(apply, p, descriptor)\n    // }\n    return apply;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL25vZGVfbW9kdWxlcy91bmlmaWVkL2xpYi9jYWxsYWJsZS1pbnN0YW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsbUJBS1Qsb0JBQW9CLEdBRWxCOzs7O09BSUMsR0FDRCxTQUFVQyxRQUFRO0lBQ2hCLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixNQUFNQyxTQUFTRCxLQUFLRSxXQUFXO0lBQy9CLE1BQU1DLFFBQVEsOENBQThDLEdBQzFELHVCQUF1QjtJQUN2QixpQ0FBaUM7SUFDakNGLE9BQU9HLFNBQVM7SUFFbEIsTUFBTUMsUUFBUUYsS0FBSyxDQUFDSixTQUFTO0lBQzdCLHVEQUF1RCxHQUN2RCxNQUFNTyxRQUFRO1FBQ1osT0FBT0QsTUFBTUMsS0FBSyxDQUFDQSxPQUFPQztJQUM1QjtJQUVBQyxPQUFPQyxjQUFjLENBQUNILE9BQU9IO0lBRTdCLGtFQUFrRTtJQUNsRSxZQUFZO0lBQ1oseURBQXlEO0lBQ3pELFFBQVE7SUFDUixvQkFBb0I7SUFDcEIsa0RBQWtEO0lBQ2xELEVBQUU7SUFDRiwyQkFBMkI7SUFDM0IsaUVBQWlFO0lBQ2pFLGdFQUFnRTtJQUNoRSxJQUFJO0lBRUosT0FBT0c7QUFDVCxFQUVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvbm9kZV9tb2R1bGVzL3VuaWZpZWQvbGliL2NhbGxhYmxlLWluc3RhbmNlLmpzP2QwMGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IENhbGxhYmxlSW5zdGFuY2UgPVxuICAvKipcbiAgICogQHR5cGUge25ldyA8UGFyYW1ldGVycyBleHRlbmRzIEFycmF5PHVua25vd24+LCBSZXN1bHQ+KHByb3BlcnR5OiBzdHJpbmcgfCBzeW1ib2wpID0+ICguLi5wYXJhbWV0ZXJzOiBQYXJhbWV0ZXJzKSA9PiBSZXN1bHR9XG4gICAqL1xuICAoXG4gICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgIChcbiAgICAgIC8qKlxuICAgICAgICogQHRoaXMge0Z1bmN0aW9ufVxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IHByb3BlcnR5XG4gICAgICAgKiBAcmV0dXJucyB7KC4uLnBhcmFtZXRlcnM6IEFycmF5PHVua25vd24+KSA9PiB1bmtub3dufVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgICAgY29uc3QgY29uc3RyID0gc2VsZi5jb25zdHJ1Y3RvclxuICAgICAgICBjb25zdCBwcm90byA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgRnVuY3Rpb24+fSAqLyAoXG4gICAgICAgICAgLy8gUHJvdG90eXBlcyBkbyBleGlzdC5cbiAgICAgICAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICAgICAgICBjb25zdHIucHJvdG90eXBlXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm90b1twcm9wZXJ0eV1cbiAgICAgICAgLyoqIEB0eXBlIHsoLi4ucGFyYW1ldGVyczogQXJyYXk8dW5rbm93bj4pID0+IHVua25vd259ICovXG4gICAgICAgIGNvbnN0IGFwcGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShhcHBseSwgYXJndW1lbnRzKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFwcGx5LCBwcm90bylcblxuICAgICAgICAvLyBOb3QgbmVlZGVkIGZvciB1cyBpbiBgdW5pZmllZGA6IHdlIG9ubHkgY2FsbCB0aGlzIG9uIHRoZSBgY29weWBcbiAgICAgICAgLy8gZnVuY3Rpb24sXG4gICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdHMgZmllbGRzIChgbGVuZ3RoYCwgYG5hbWVgKVxuICAgICAgICAvLyBvdmVyLlxuICAgICAgICAvLyBTZWUgYWxzbzogR0gtMjQ2LlxuICAgICAgICAvLyBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKVxuICAgICAgICAvL1xuICAgICAgICAvLyBmb3IgKGNvbnN0IHAgb2YgbmFtZXMpIHtcbiAgICAgICAgLy8gICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwgcClcbiAgICAgICAgLy8gICBpZiAoZGVzY3JpcHRvcikgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcGx5LCBwLCBkZXNjcmlwdG9yKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGFwcGx5XG4gICAgICB9XG4gICAgKVxuICApXG4iXSwibmFtZXMiOlsiQ2FsbGFibGVJbnN0YW5jZSIsInByb3BlcnR5Iiwic2VsZiIsImNvbnN0ciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJwcm90b3R5cGUiLCJ2YWx1ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/callable-instance.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/node_modules/unified/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   unified: () => (/* binding */ unified)\n/* harmony export */ });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bail */ \"(rsc)/./node_modules/bail/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-plain-obj */ \"(rsc)/./node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! trough */ \"(rsc)/./node_modules/trough/lib/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vfile */ \"(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/index.js\");\n/* harmony import */ var _callable_instance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./callable-instance.js */ \"(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/callable-instance.js\");\n/**\n * @typedef {import('trough').Pipeline} Pipeline\n *\n * @typedef {import('unist').Node} Node\n *\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('vfile').Value} Value\n *\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Settings} Settings\n */ /**\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\n *   Acceptable results from compilers.\n *\n *   To register custom results, add them to\n *   {@linkcode CompileResultMap}.\n */ /**\n * @template {Node} [Tree=Node]\n *   The node that the compiler receives (default: `Node`).\n * @template {CompileResults} [Result=CompileResults]\n *   The thing that the compiler yields (default: `CompileResults`).\n * @callback Compiler\n *   A **compiler** handles the compiling of a syntax tree to something else\n *   (in most cases, text) (TypeScript type).\n *\n *   It is used in the stringify phase and called with a {@linkcode Node}\n *   and {@linkcode VFile} representation of the document to compile.\n *   It should return the textual representation of the given tree (typically\n *   `string`).\n *\n *   > **Note**: unified typically compiles by serializing: most compilers\n *   > return `string` (or `Uint8Array`).\n *   > Some compilers, such as the one configured with\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\n *   > React tree).\n *   > If youre using a compiler that doesnt serialize, expect different\n *   > result values.\n *   >\n *   > To register custom results in TypeScript, add them to\n *   > {@linkcode CompileResultMap}.\n *\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\n * @param {Tree} tree\n *   Tree to compile.\n * @param {VFile} file\n *   File associated with `tree`.\n * @returns {Result}\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\n *   something else (for `file.result`).\n */ /**\n * @template {Node} [Tree=Node]\n *   The node that the parser yields (default: `Node`)\n * @callback Parser\n *   A **parser** handles the parsing of text to a syntax tree.\n *\n *   It is used in the parse phase and is called with a `string` and\n *   {@linkcode VFile} of the document to parse.\n *   It must return the syntax tree representation of the given file\n *   ({@linkcode Node}).\n * @param {string} document\n *   Document to parse.\n * @param {VFile} file\n *   File associated with `document`.\n * @returns {Tree}\n *   Node representing the given file.\n */ /**\n * @typedef {(\n *   Plugin<Array<any>, any, any> |\n *   PluginTuple<Array<any>, any, any> |\n *   Preset\n * )} Pluggable\n *   Union of the different ways to add plugins and settings.\n */ /**\n * @typedef {Array<Pluggable>} PluggableList\n *   List of plugins and presets.\n */ // Note: we cant use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\n * @template {Array<unknown>} [PluginParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=Node]\n *   Value that is expected as input (default: `Node`).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@linkcode Parser}, this should be\n *       `string`.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be the\n *       node it expects.\n * @template [Output=Input]\n *   Value that is yielded as output (default: `Input`).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@linkcode Parser}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be\n *       result it yields.\n * @typedef {(\n *   (this: Processor, ...parameters: PluginParameters) =>\n *     Input extends string ? // Parser.\n *        Output extends Node | undefined ? undefined | void : never :\n *     Output extends CompileResults ? // Compiler.\n *        Input extends Node | undefined ? undefined | void : never :\n *     Transformer<\n *       Input extends Node ? Input : Node,\n *       Output extends Node ? Output : Node\n *     > | undefined | void\n * )} Plugin\n *   Single plugin.\n *\n *   Plugins configure the processors they are applied on in the following\n *   ways:\n *\n *   *   they change the processor, such as the parser, the compiler, or by\n *       configuring data\n *   *   they specify how to handle trees and files\n *\n *   In practice, they are functions that can receive options and configure the\n *   processor (`this`).\n *\n *   > **Note**: plugins are called when the processor is *frozen*, not when\n *   > they are applied.\n */ /**\n * Tuple of a plugin and its configuration.\n *\n * The first item is a plugin, the rest are its parameters.\n *\n * @template {Array<unknown>} [TupleParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=undefined]\n *   Value that is expected as input (optional).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@linkcode Parser}, this should be\n *       `string`.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be the\n *       node it expects.\n * @template [Output=undefined] (optional).\n *   Value that is yielded as output.\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@linkcode Parser}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be\n *       result it yields.\n * @typedef {(\n *   [\n *     plugin: Plugin<TupleParameters, Input, Output>,\n *     ...parameters: TupleParameters\n *   ]\n * )} PluginTuple\n */ /**\n * @typedef Preset\n *   Sharable configuration.\n *\n *   They can contain plugins and settings.\n * @property {PluggableList | undefined} [plugins]\n *   List of plugins and presets (optional).\n * @property {Settings | undefined} [settings]\n *   Shared settings for parsers and compilers (optional).\n */ /**\n * @template {VFile} [File=VFile]\n *   The file that the callback receives (default: `VFile`).\n * @callback ProcessCallback\n *   Callback called when the process is done.\n *\n *   Called with either an error or a result.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {File | undefined} [file]\n *   Processed file (optional).\n * @returns {undefined}\n *   Nothing.\n */ /**\n * @template {Node} [Tree=Node]\n *   The tree that the callback receives (default: `Node`).\n * @callback RunCallback\n *   Callback called when transformers are done.\n *\n *   Called with either an error or results.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {Tree | undefined} [tree]\n *   Transformed tree (optional).\n * @param {VFile | undefined} [file]\n *   File (optional).\n * @returns {undefined}\n *   Nothing.\n */ /**\n * @template {Node} [Output=Node]\n *   Node type that the transformer yields (default: `Node`).\n * @callback TransformCallback\n *   Callback passed to transforms.\n *\n *   If the signature of a `transformer` accepts a third argument, the\n *   transformer may perform asynchronous operations, and must call it.\n * @param {Error | undefined} [error]\n *   Fatal error to stop the process (optional).\n * @param {Output | undefined} [tree]\n *   New, changed, tree (optional).\n * @param {VFile | undefined} [file]\n *   New, changed, file (optional).\n * @returns {undefined}\n *   Nothing.\n */ /**\n * @template {Node} [Input=Node]\n *   Node type that the transformer expects (default: `Node`).\n * @template {Node} [Output=Input]\n *   Node type that the transformer yields (default: `Input`).\n * @callback Transformer\n *   Transformers handle syntax trees and files.\n *\n *   They are functions that are called each time a syntax tree and file are\n *   passed through the run phase.\n *   When an error occurs in them (either because its thrown, returned,\n *   rejected, or passed to `next`), the process stops.\n *\n *   The run phase is handled by [`trough`][trough], see its documentation for\n *   the exact semantics of these functions.\n *\n *   > **Note**: you should likely ignore `next`: dont accept it.\n *   > it supports callback-style async work.\n *   > But promises are likely easier to reason about.\n *\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\n * @param {Input} tree\n *   Tree to handle.\n * @param {VFile} file\n *   File to handle.\n * @param {TransformCallback<Output>} next\n *   Callback.\n * @returns {(\n *   Promise<Output | undefined | void> |\n *   Promise<never> | // For some reason this is needed separately.\n *   Output |\n *   Error |\n *   undefined |\n *   void\n * )}\n *   If you accept `next`, nothing.\n *   Otherwise:\n *\n *   *   `Error`  fatal error to stop the process\n *   *   `Promise<undefined>` or `undefined`  the next transformer keeps using\n *       same tree\n *   *   `Promise<Node>` or `Node`  new, changed, tree\n */ /**\n * @template {Node | undefined} ParseTree\n *   Output of `parse`.\n * @template {Node | undefined} HeadTree\n *   Input for `run`.\n * @template {Node | undefined} TailTree\n *   Output for `run`.\n * @template {Node | undefined} CompileTree\n *   Input of `stringify`.\n * @template {CompileResults | undefined} CompileResult\n *   Output of `stringify`.\n * @template {Node | string | undefined} Input\n *   Input of plugin.\n * @template Output\n *   Output of plugin (optional).\n * @typedef {(\n *   Input extends string\n *     ? Output extends Node | undefined\n *       ? // Parser.\n *         Processor<\n *           Output extends undefined ? ParseTree : Output,\n *           HeadTree,\n *           TailTree,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Output extends CompileResults\n *     ? Input extends Node | undefined\n *       ? // Compiler.\n *         Processor<\n *           ParseTree,\n *           HeadTree,\n *           TailTree,\n *           Input extends undefined ? CompileTree : Input,\n *           Output extends undefined ? CompileResult : Output\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Input extends Node | undefined\n *     ? Output extends Node | undefined\n *       ? // Transform.\n *         Processor<\n *           ParseTree,\n *           HeadTree extends undefined ? Input : HeadTree,\n *           Output extends undefined ? TailTree : Output,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : // Unknown.\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n * )} UsePlugin\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\n */ /**\n * @template {CompileResults | undefined} Result\n *   Node type that the transformer yields.\n * @typedef {(\n *   Result extends Value | undefined ?\n *     VFile :\n *     VFile & {result: Result}\n *   )} VFileWithOutput\n *   Type to generate a {@linkcode VFile} corresponding to a compiler result.\n *\n *   If a result that is not acceptable on a `VFile` is used, that will\n *   be stored on the `result` field of {@linkcode VFile}.\n */ \n\n\n\n\n\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\nconst own = {}.hasOwnProperty;\n/**\n * @template {Node | undefined} [ParseTree=undefined]\n *   Output of `parse` (optional).\n * @template {Node | undefined} [HeadTree=undefined]\n *   Input for `run` (optional).\n * @template {Node | undefined} [TailTree=undefined]\n *   Output for `run` (optional).\n * @template {Node | undefined} [CompileTree=undefined]\n *   Input of `stringify` (optional).\n * @template {CompileResults | undefined} [CompileResult=undefined]\n *   Output of `stringify` (optional).\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\n */ class Processor extends _callable_instance_js__WEBPACK_IMPORTED_MODULE_2__.CallableInstance {\n    /**\n   * Create a processor.\n   */ constructor(){\n        // If `Processor()` is called (w/o new), `copy` is called instead.\n        super(\"copy\");\n        /**\n     * Compiler to use (deprecated).\n     *\n     * @deprecated\n     *   Use `compiler` instead.\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */ this.Compiler = undefined;\n        /**\n     * Parser to use (deprecated).\n     *\n     * @deprecated\n     *   Use `parser` instead.\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */ this.Parser = undefined;\n        // Note: the following fields are considered private.\n        // However, they are needed for tests, and TSC generates an untyped\n        // `private freezeIndex` field for, which trips `type-coverage` up.\n        // Instead, we use `@deprecated` to visualize that they shouldnt be used.\n        /**\n     * Internal list of configured plugins.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Array<PluginTuple<Array<unknown>>>}\n     */ this.attachers = [];\n        /**\n     * Compiler to use.\n     *\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */ this.compiler = undefined;\n        /**\n     * Internal state to track where we are while freezing.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {number}\n     */ this.freezeIndex = -1;\n        /**\n     * Internal state to track whether were frozen.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {boolean | undefined}\n     */ this.frozen = undefined;\n        /**\n     * Internal state.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Data}\n     */ this.namespace = {};\n        /**\n     * Parser to use.\n     *\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */ this.parser = undefined;\n        /**\n     * Internal list of configured transformers.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Pipeline}\n     */ this.transformers = (0,trough__WEBPACK_IMPORTED_MODULE_3__.trough)();\n    }\n    /**\n   * Copy a processor.\n   *\n   * @deprecated\n   *   This is a private internal method and should not be used.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   New *unfrozen* processor ({@linkcode Processor}) that is\n   *   configured to work the same as its ancestor.\n   *   When the descendant processor is configured in the future it does not\n   *   affect the ancestral processor.\n   */ copy() {\n        // Cast as the type parameters will be the same after attaching.\n        const destination = /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */ new Processor();\n        let index = -1;\n        while(++index < this.attachers.length){\n            const attacher = this.attachers[index];\n            destination.use(...attacher);\n        }\n        destination.data(extend__WEBPACK_IMPORTED_MODULE_0__(true, {}, this.namespace));\n        return destination;\n    }\n    /**\n   * Configure the processor with info available to all plugins.\n   * Information is stored in an object.\n   *\n   * Typically, options can be given to a specific plugin, but sometimes it\n   * makes sense to have information shared with several plugins.\n   * For example, a list of HTML elements that are self-closing, which is\n   * needed during all phases.\n   *\n   * > **Note**: setting information cannot occur on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * > **Note**: to register custom data in TypeScript, augment the\n   * > {@linkcode Data} interface.\n   *\n   * @example\n   *   This example show how to get and set info:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   const processor = unified().data('alpha', 'bravo')\n   *\n   *   processor.data('alpha') // => 'bravo'\n   *\n   *   processor.data() // => {alpha: 'bravo'}\n   *\n   *   processor.data({charlie: 'delta'})\n   *\n   *   processor.data() // => {charlie: 'delta'}\n   *   ```\n   *\n   * @template {keyof Data} Key\n   *\n   * @overload\n   * @returns {Data}\n   *\n   * @overload\n   * @param {Data} dataset\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Key} key\n   * @returns {Data[Key]}\n   *\n   * @overload\n   * @param {Key} key\n   * @param {Data[Key]} value\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @param {Data | Key} [key]\n   *   Key to get or set, or entire dataset to set, or nothing to get the\n   *   entire dataset (optional).\n   * @param {Data[Key]} [value]\n   *   Value to set (optional).\n   * @returns {unknown}\n   *   The current processor when setting, the value at `key` when getting, or\n   *   the entire dataset when getting without key.\n   */ data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", this.frozen);\n                this.namespace[key] = value;\n                return this;\n            }\n            // Get `key`.\n            return own.call(this.namespace, key) && this.namespace[key] || undefined;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", this.frozen);\n            this.namespace = key;\n            return this;\n        }\n        // Get space.\n        return this.namespace;\n    }\n    /**\n   * Freeze a processor.\n   *\n   * Frozen processors are meant to be extended and not to be configured\n   * directly.\n   *\n   * When a processor is frozen it cannot be unfrozen.\n   * New processors working the same way can be created by calling the\n   * processor.\n   *\n   * Its possible to freeze processors explicitly by calling `.freeze()`.\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\n   *\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   The current processor.\n   */ freeze() {\n        if (this.frozen) {\n            return this;\n        }\n        // Cast so that we can type plugins easier.\n        // Plugins are supposed to be usable on different processors, not just on\n        // this exact processor.\n        const self = /** @type {unknown} */ this;\n        while(++this.freezeIndex < this.attachers.length){\n            const [attacher, ...options] = this.attachers[this.freezeIndex];\n            if (options[0] === false) {\n                continue;\n            }\n            if (options[0] === true) {\n                options[0] = undefined;\n            }\n            const transformer = attacher.call(self, ...options);\n            if (typeof transformer === \"function\") {\n                this.transformers.use(transformer);\n            }\n        }\n        this.frozen = true;\n        this.freezeIndex = Number.POSITIVE_INFINITY;\n        return this;\n    }\n    /**\n   * Parse text to a syntax tree.\n   *\n   * > **Note**: `parse` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `parse` performs the parse phase, not the run phase or other\n   * > phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   file to parse (optional); typically `string` or `VFile`; any value\n   *   accepted as `x` in `new VFile(x)`.\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\n   *   Syntax tree representing `file`.\n   */ parse(file) {\n        this.freeze();\n        const realFile = vfile(file);\n        const parser = this.parser || this.Parser;\n        assertParser(\"parse\", parser);\n        return parser(String(realFile), realFile);\n    }\n    /**\n   * Process the given file as configured on the processor.\n   *\n   * > **Note**: `process` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `process` performs the parse, run, and stringify phases.\n   *\n   * @overload\n   * @param {Compatible | undefined} file\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\n   *   Callback (optional).\n   * @returns {Promise<VFile> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\n   *   processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */ process(file, done) {\n        const self = this;\n        this.freeze();\n        assertParser(\"process\", this.parser || this.Parser);\n        assertCompiler(\"process\", this.compiler || this.Compiler);\n        return done ? executor(undefined, done) : new Promise(executor);\n        // Note: `void`s needed for TS.\n        /**\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\n     * @param {(error: Error | undefined) => undefined | void} reject\n     * @returns {undefined}\n     */ function executor(resolve, reject) {\n            const realFile = vfile(file);\n            // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n            // input of the first transform).\n            const parseTree = /** @type {unknown} */ self.parse(realFile);\n            self.run(parseTree, realFile, function(error, tree, file) {\n                if (error || !tree || !file) {\n                    return realDone(error);\n                }\n                // Assume `TailTree` (the output of the last transform) matches\n                // `CompileTree` (the input of the compiler).\n                const compileTree = /** @type {unknown} */ tree;\n                const compileResult = self.stringify(compileTree, file);\n                if (looksLikeAValue(compileResult)) {\n                    file.value = compileResult;\n                } else {\n                    file.result = compileResult;\n                }\n                realDone(error, /** @type {VFileWithOutput<CompileResult>} */ file);\n            });\n            /**\n       * @param {Error | undefined} error\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\n       * @returns {undefined}\n       */ function realDone(error, file) {\n                if (error || !file) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(done, \"`done` is defined if `resolve` is not\");\n                    done(undefined, file);\n                }\n            }\n        }\n    }\n    /**\n   * Process the given file as configured on the processor.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > **Note**: `processSync` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `processSync` performs the parse, run, and stringify phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @returns {VFileWithOutput<CompileResult>}\n   *   The processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */ processSync(file) {\n        /** @type {boolean} */ let complete = false;\n        /** @type {VFileWithOutput<CompileResult> | undefined} */ let result;\n        this.freeze();\n        assertParser(\"processSync\", this.parser || this.Parser);\n        assertCompiler(\"processSync\", this.compiler || this.Compiler);\n        this.process(file, realDone);\n        assertDone(\"processSync\", \"process\", complete);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(result, \"we either bailed on an error or have a tree\");\n        return result;\n        /**\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\n     */ function realDone(error, file) {\n            complete = true;\n            (0,bail__WEBPACK_IMPORTED_MODULE_5__.bail)(error);\n            result = file;\n        }\n    }\n    /**\n   * Run *transformers* on a syntax tree.\n   *\n   * > **Note**: `run` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `run` performs the run phase, not other phases.\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} file\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {(\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\n   *   Compatible\n   * )} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\n   *   Callback (optional).\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\n   *   transformed tree.\n   */ run(tree, file, done) {\n        assertNode(tree);\n        this.freeze();\n        const transformers = this.transformers;\n        if (!done && typeof file === \"function\") {\n            done = file;\n            file = undefined;\n        }\n        return done ? executor(undefined, done) : new Promise(executor);\n        // Note: `void`s needed for TS.\n        /**\n     * @param {(\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\n     *   undefined\n     * )} resolve\n     * @param {(error: Error) => undefined | void} reject\n     * @returns {undefined}\n     */ function executor(resolve, reject) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(typeof file !== \"function\", \"`file` cant be a `done` anymore, we checked\");\n            const realFile = vfile(file);\n            transformers.run(tree, realFile, realDone);\n            /**\n       * @param {Error | undefined} error\n       * @param {Node} outputTree\n       * @param {VFile} file\n       * @returns {undefined}\n       */ function realDone(error, outputTree, file) {\n                const resultingTree = /** @type {TailTree extends undefined ? Node : TailTree} */ outputTree || tree;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(resultingTree);\n                } else {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(done, \"`done` is defined if `resolve` is not\");\n                    done(undefined, resultingTree, file);\n                }\n            }\n        }\n    }\n    /**\n   * Run *transformers* on a syntax tree.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > **Note**: `runSync` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `runSync` performs the run phase, not other phases.\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {TailTree extends undefined ? Node : TailTree}\n   *   Transformed tree.\n   */ runSync(tree, file) {\n        /** @type {boolean} */ let complete = false;\n        /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */ let result;\n        this.run(tree, file, realDone);\n        assertDone(\"runSync\", \"run\", complete);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(result, \"we either bailed on an error or have a tree\");\n        return result;\n        /**\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\n     */ function realDone(error, tree) {\n            (0,bail__WEBPACK_IMPORTED_MODULE_5__.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * Compile a syntax tree.\n   *\n   * > **Note**: `stringify` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `stringify` performs the stringify phase, not the run phase\n   * > or other phases.\n   *\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\n   *   Tree to compile.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\n   *   Textual representation of the tree (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most compilers\n   *   > return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */ stringify(tree, file) {\n        this.freeze();\n        const realFile = vfile(file);\n        const compiler = this.compiler || this.Compiler;\n        assertCompiler(\"stringify\", compiler);\n        assertNode(tree);\n        return compiler(tree, realFile);\n    }\n    /**\n   * Configure the processor to use a plugin, a list of usable values, or a\n   * preset.\n   *\n   * If the processor is already using a plugin, the previous plugin\n   * configuration is changed based on the options that are passed in.\n   * In other words, the plugin is not added a second time.\n   *\n   * > **Note**: `use` cannot be called on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * @example\n   *   There are many ways to pass plugins to `.use()`.\n   *   This example gives an overview:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   unified()\n   *     // Plugin with options:\n   *     .use(pluginA, {x: true, y: true})\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n   *     .use(pluginA, {y: false, z: true})\n   *     // Plugins:\n   *     .use([pluginB, pluginC])\n   *     // Two plugins, the second with options:\n   *     .use([pluginD, [pluginE, {}]])\n   *     // Preset with plugins and settings:\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n   *     // Settings only:\n   *     .use({settings: {position: false}})\n   *   ```\n   *\n   * @template {Array<unknown>} [Parameters=[]]\n   * @template {Node | string | undefined} [Input=undefined]\n   * @template [Output=Input]\n   *\n   * @overload\n   * @param {Preset | null | undefined} [preset]\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {PluggableList} list\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Plugin<Parameters, Input, Output>} plugin\n   * @param {...(Parameters | [boolean])} parameters\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\n   *\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\n   *   Usable value.\n   * @param {...unknown} parameters\n   *   Parameters, when a plugin is given as a usable value.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   Current processor.\n   */ use(value, ...parameters) {\n        const attachers = this.attachers;\n        const namespace = this.namespace;\n        assertUnfrozen(\"use\", this.frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin(value, parameters);\n        } else if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        return this;\n        /**\n     * @param {Pluggable} value\n     * @returns {undefined}\n     */ function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value, []);\n            } else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...parameters] = /** @type {PluginTuple<Array<unknown>>} */ value;\n                    addPlugin(plugin, parameters);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        /**\n     * @param {Preset} result\n     * @returns {undefined}\n     */ function addPreset(result) {\n            if (!(\"plugins\" in result) && !(\"settings\" in result)) {\n                throw new Error(\"Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither\");\n            }\n            addList(result.plugins);\n            if (result.settings) {\n                namespace.settings = extend__WEBPACK_IMPORTED_MODULE_0__(true, namespace.settings, result.settings);\n            }\n        }\n        /**\n     * @param {PluggableList | null | undefined} plugins\n     * @returns {undefined}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (Array.isArray(plugins)) {\n                while(++index < plugins.length){\n                    const thing = plugins[index];\n                    add(thing);\n                }\n            } else {\n                throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {Array<unknown>} parameters\n     * @returns {undefined}\n     */ function addPlugin(plugin, parameters) {\n            let index = -1;\n            let entryIndex = -1;\n            while(++index < attachers.length){\n                if (attachers[index][0] === plugin) {\n                    entryIndex = index;\n                    break;\n                }\n            }\n            if (entryIndex === -1) {\n                attachers.push([\n                    plugin,\n                    ...parameters\n                ]);\n            } else if (parameters.length > 0) {\n                let [primary, ...rest] = parameters;\n                const currentPrimary = attachers[entryIndex][1];\n                if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(currentPrimary) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(primary)) {\n                    primary = extend__WEBPACK_IMPORTED_MODULE_0__(true, currentPrimary, primary);\n                }\n                attachers[entryIndex] = [\n                    plugin,\n                    primary,\n                    ...rest\n                ];\n            }\n        }\n    }\n}\n// Note: this returns a *callable* instance.\n// Thats why its documented as a function.\n/**\n * Create a new processor.\n *\n * @example\n *   This example shows how a new processor can be created (from `remark`) and linked\n *   to **stdin**(4) and **stdout**(4).\n *\n *   ```js\n *   import process from 'node:process'\n *   import concatStream from 'concat-stream'\n *   import {remark} from 'remark'\n *\n *   process.stdin.pipe(\n *     concatStream(function (buf) {\n *       process.stdout.write(String(remark().processSync(buf)))\n *     })\n *   )\n *   ```\n *\n * @returns\n *   New *unfrozen* processor (`processor`).\n *\n *   This processor is configured to work the same as its ancestor.\n *   When the descendant processor is configured in the future it does not\n *   affect the ancestral processor.\n */ const unified = new Processor().freeze();\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function assertParser(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `parser`\");\n    }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function assertCompiler(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `compiler`\");\n    }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n    }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node) || typeof node.type !== \"string\") {\n        throw new TypeError(\"Expected node, got `\" + node + \"`\");\n    // Fine.\n    }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n/**\n * @param {Compatible | undefined} [value]\n * @returns {VFile}\n */ function vfile(value) {\n    return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_6__.VFile(value);\n}\n/**\n * @param {Compatible | undefined} [value]\n * @returns {value is VFile}\n */ function looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is Value}\n */ function looksLikeAValue(value) {\n    return typeof value === \"string\" || isUint8Array(value);\n}\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */ function isUint8Array(value) {\n    return Boolean(value && typeof value === \"object\" && \"byteLength\" in value && \"byteOffset\" in value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL25vZGVfbW9kdWxlcy91bmlmaWVkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7O0NBR0MsR0FFRCw0REFBNEQ7QUFDNUQsMkRBQTJEO0FBQzNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOENDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQkMsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFRDs7Ozs7Ozs7Ozs7OztDQWFDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMENDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0RDLEdBRUQ7Ozs7Ozs7Ozs7OztDQVlDLEdBRXdCO0FBQ0U7QUFDUTtBQUNFO0FBQ1I7QUFDRjtBQUM0QjtBQUV2RCxrRUFBa0U7QUFFbEUsNEVBQTRFO0FBQzVFLHFCQUFxQjtBQUNyQiw2RUFBNkU7QUFFN0UsTUFBTVEsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0I7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUMsa0JBQWtCSCxtRUFBZ0JBO0lBQzdDOztHQUVDLEdBQ0RJLGFBQWM7UUFDWixrRUFBa0U7UUFDbEUsS0FBSyxDQUFDO1FBRU47Ozs7Ozs7Ozs7OztLQVlDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdDO1FBRWhCOzs7Ozs7Ozs7S0FTQyxHQUNELElB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LElBQUk2RCxNQUNSLGtCQUNFVSxPQUNBO0lBRU47QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU3ZCLFdBQVd3QixJQUFJO0lBQ3RCLDhEQUE4RDtJQUM5RCxpQ0FBaUM7SUFDakMsSUFBSSxDQUFDdEYsd0RBQVVBLENBQUNzRixTQUFTLE9BQU9BLEtBQUtDLElBQUksS0FBSyxVQUFVO1FBQ3RELE1BQU0sSUFBSWYsVUFBVSx5QkFBeUJjLE9BQU87SUFDcEQsUUFBUTtJQUNWO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3pCLFdBQVd3QixJQUFJLEVBQUVHLFNBQVMsRUFBRTVCLFFBQVE7SUFDM0MsSUFBSSxDQUFDQSxVQUFVO1FBQ2IsTUFBTSxJQUFJZSxNQUNSLE1BQU1VLE9BQU8sNEJBQTRCRyxZQUFZO0lBRXpEO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTakQsTUFBTWIsS0FBSztJQUNsQixPQUFPK0QsZ0JBQWdCL0QsU0FBU0EsUUFBUSxJQUFJeEIsd0NBQUtBLENBQUN3QjtBQUNwRDtBQUVBOzs7Q0FHQyxHQUNELFNBQVMrRCxnQkFBZ0IvRCxLQUFLO0lBQzVCLE9BQU9nRSxRQUNMaEUsU0FDRSxPQUFPQSxVQUFVLFlBQ2pCLGFBQWFBLFNBQ2IsY0FBY0E7QUFFcEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTK0IsZ0JBQWdCL0IsS0FBSztJQUM1QixPQUFPLE9BQU9BLFVBQVUsWUFBWWlFLGFBQWFqRTtBQUNuRDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUUsYUFBYWpFLEtBQUs7SUFDekIsT0FBT2dFLFFBQ0xoRSxTQUNFLE9BQU9BLFVBQVUsWUFDakIsZ0JBQWdCQSxTQUNoQixnQkFBZ0JBO0FBRXRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvbm9kZV9tb2R1bGVzL3VuaWZpZWQvbGliL2luZGV4LmpzPzAwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd0cm91Z2gnKS5QaXBlbGluZX0gUGlwZWxpbmVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd2ZmlsZScpLkNvbXBhdGlibGV9IENvbXBhdGlibGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVmFsdWV9IFZhbHVlXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vaW5kZXguanMnKS5Db21waWxlUmVzdWx0TWFwfSBDb21waWxlUmVzdWx0TWFwXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9pbmRleC5qcycpLkRhdGF9IERhdGFcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuU2V0dGluZ3N9IFNldHRpbmdzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q29tcGlsZVJlc3VsdE1hcFtrZXlvZiBDb21waWxlUmVzdWx0TWFwXX0gQ29tcGlsZVJlc3VsdHNcbiAqICAgQWNjZXB0YWJsZSByZXN1bHRzIGZyb20gY29tcGlsZXJzLlxuICpcbiAqICAgVG8gcmVnaXN0ZXIgY3VzdG9tIHJlc3VsdHMsIGFkZCB0aGVtIHRvXG4gKiAgIHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IFtUcmVlPU5vZGVdXG4gKiAgIFRoZSBub2RlIHRoYXQgdGhlIGNvbXBpbGVyIHJlY2VpdmVzIChkZWZhdWx0OiBgTm9kZWApLlxuICogQHRlbXBsYXRlIHtDb21waWxlUmVzdWx0c30gW1Jlc3VsdD1Db21waWxlUmVzdWx0c11cbiAqICAgVGhlIHRoaW5nIHRoYXQgdGhlIGNvbXBpbGVyIHlpZWxkcyAoZGVmYXVsdDogYENvbXBpbGVSZXN1bHRzYCkuXG4gKiBAY2FsbGJhY2sgQ29tcGlsZXJcbiAqICAgQSAqKmNvbXBpbGVyKiogaGFuZGxlcyB0aGUgY29tcGlsaW5nIG9mIGEgc3ludGF4IHRyZWUgdG8gc29tZXRoaW5nIGVsc2VcbiAqICAgKGluIG1vc3QgY2FzZXMsIHRleHQpIChUeXBlU2NyaXB0IHR5cGUpLlxuICpcbiAqICAgSXQgaXMgdXNlZCBpbiB0aGUgc3RyaW5naWZ5IHBoYXNlIGFuZCBjYWxsZWQgd2l0aCBhIHtAbGlua2NvZGUgTm9kZX1cbiAqICAgYW5kIHtAbGlua2NvZGUgVkZpbGV9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkb2N1bWVudCB0byBjb21waWxlLlxuICogICBJdCBzaG91bGQgcmV0dXJuIHRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB0cmVlICh0eXBpY2FsbHlcbiAqICAgYHN0cmluZ2ApLlxuICpcbiAqICAgPiAqKk5vdGUqKjogdW5pZmllZCB0eXBpY2FsbHkgY29tcGlsZXMgYnkgc2VyaWFsaXppbmc6IG1vc3QgY29tcGlsZXJzXG4gKiAgID4gcmV0dXJuIGBzdHJpbmdgIChvciBgVWludDhBcnJheWApLlxuICogICA+IFNvbWUgY29tcGlsZXJzLCBzdWNoIGFzIHRoZSBvbmUgY29uZmlndXJlZCB3aXRoXG4gKiAgID4gW2ByZWh5cGUtcmVhY3RgXVtyZWh5cGUtcmVhY3RdLCByZXR1cm4gb3RoZXIgdmFsdWVzIChpbiB0aGlzIGNhc2UsIGFcbiAqICAgPiBSZWFjdCB0cmVlKS5cbiAqICAgPiBJZiB5b3XigJlyZSB1c2luZyBhIGNvbXBpbGVyIHRoYXQgZG9lc27igJl0IHNlcmlhbGl6ZSwgZXhwZWN0IGRpZmZlcmVudFxuICogICA+IHJlc3VsdCB2YWx1ZXMuXG4gKiAgID5cbiAqICAgPiBUbyByZWdpc3RlciBjdXN0b20gcmVzdWx0cyBpbiBUeXBlU2NyaXB0LCBhZGQgdGhlbSB0b1xuICogICA+IHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uXG4gKlxuICogICBbcmVoeXBlLXJlYWN0XTogaHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdFxuICogQHBhcmFtIHtUcmVlfSB0cmVlXG4gKiAgIFRyZWUgdG8gY29tcGlsZS5cbiAqIEBwYXJhbSB7VkZpbGV9IGZpbGVcbiAqICAgRmlsZSBhc3NvY2lhdGVkIHdpdGggYHRyZWVgLlxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqICAgTmV3IGNvbnRlbnQ6IGNvbXBpbGVkIHRleHQgKGBzdHJpbmdgIG9yIGBVaW50OEFycmF5YCwgZm9yIGBmaWxlLnZhbHVlYCkgb3JcbiAqICAgc29tZXRoaW5nIGVsc2UgKGZvciBgZmlsZS5yZXN1bHRgKS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gW1RyZWU9Tm9kZV1cbiAqICAgVGhlIG5vZGUgdGhhdCB0aGUgcGFyc2VyIHlpZWxkcyAoZGVmYXVsdDogYE5vZGVgKVxuICogQGNhbGxiYWNrIFBhcnNlclxuICogICBBICoqcGFyc2VyKiogaGFuZGxlcyB0aGUgcGFyc2luZyBvZiB0ZXh0IHRvIGEgc3ludGF4IHRyZWUuXG4gKlxuICogICBJdCBpcyB1c2VkIGluIHRoZSBwYXJzZSBwaGFzZSBhbmQgaXMgY2FsbGVkIHdpdGggYSBgc3RyaW5nYCBhbmRcbiAqICAge0BsaW5rY29kZSBWRmlsZX0gb2YgdGhlIGRvY3VtZW50IHRvIHBhcnNlLlxuICogICBJdCBtdXN0IHJldHVybiB0aGUgc3ludGF4IHRyZWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGZpbGVcbiAqICAgKHtAbGlua2NvZGUgTm9kZX0pLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvY3VtZW50XG4gKiAgIERvY3VtZW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtWRmlsZX0gZmlsZVxuICogICBGaWxlIGFzc29jaWF0ZWQgd2l0aCBgZG9jdW1lbnRgLlxuICogQHJldHVybnMge1RyZWV9XG4gKiAgIE5vZGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBmaWxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgUGx1Z2luPEFycmF5PGFueT4sIGFueSwgYW55PiB8XG4gKiAgIFBsdWdpblR1cGxlPEFycmF5PGFueT4sIGFueSwgYW55PiB8XG4gKiAgIFByZXNldFxuICogKX0gUGx1Z2dhYmxlXG4gKiAgIFVuaW9uIG9mIHRoZSBkaWZmZXJlbnQgd2F5cyB0byBhZGQgcGx1Z2lucyBhbmQgc2V0dGluZ3MuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGx1Z2dhYmxlPn0gUGx1Z2dhYmxlTGlzdFxuICogICBMaXN0IG9mIHBsdWdpbnMgYW5kIHByZXNldHMuXG4gKi9cblxuLy8gTm90ZTogd2UgY2Fu4oCZdCB1c2UgYGNhbGxiYWNrYCB5ZXQgYXMgaXQgbWVzc2VzIHVwIGB0aGlzYDpcbi8vICA8aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy81NTE5Nz4uXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QXJyYXk8dW5rbm93bj59IFtQbHVnaW5QYXJhbWV0ZXJzPVtdXVxuICogICBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwbHVnaW4gKGRlZmF1bHQ6IGBbXWAsIHRoZSBlbXB0eSB0dXBsZSkuXG4gKiBAdGVtcGxhdGUge05vZGUgfCBzdHJpbmcgfCB1bmRlZmluZWR9IFtJbnB1dD1Ob2RlXVxuICogICBWYWx1ZSB0aGF0IGlzIGV4cGVjdGVkIGFzIGlucHV0IChkZWZhdWx0OiBgTm9kZWApLlxuICpcbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gcmV0dXJucyBhIHtAbGlua2NvZGUgVHJhbnNmb3JtZXJ9LCB0aGlzXG4gKiAgICAgICBzaG91bGQgYmUgdGhlIG5vZGUgaXQgZXhwZWN0cy5cbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gc2V0cyBhIHtAbGlua2NvZGUgUGFyc2VyfSwgdGhpcyBzaG91bGQgYmVcbiAqICAgICAgIGBzdHJpbmdgLlxuICogICAqICAgSWYgdGhlIHBsdWdpbiBzZXRzIGEge0BsaW5rY29kZSBDb21waWxlcn0sIHRoaXMgc2hvdWxkIGJlIHRoZVxuICogICAgICAgbm9kZSBpdCBleHBlY3RzLlxuICogQHRlbXBsYXRlIFtPdXRwdXQ9SW5wdXRdXG4gKiAgIFZhbHVlIHRoYXQgaXMgeWllbGRlZCBhcyBvdXRwdXQgKGRlZmF1bHQ6IGBJbnB1dGApLlxuICpcbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gcmV0dXJucyBhIHtAbGlua2NvZGUgVHJhbnNmb3JtZXJ9LCB0aGlzXG4gKiAgICAgICBzaG91bGQgYmUgdGhlIG5vZGUgdGhhdCB0aGF0IHlpZWxkcy5cbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gc2V0cyBhIHtAbGlua2NvZGUgUGFyc2VyfSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gKiAgICAgICBub2RlIHRoYXQgaXQgeWllbGRzLlxuICogICAqICAgSWYgdGhlIHBsdWdpbiBzZXRzIGEge0BsaW5rY29kZSBDb21waWxlcn0sIHRoaXMgc2hvdWxkIGJlXG4gKiAgICAgICByZXN1bHQgaXQgeWllbGRzLlxuICogQHR5cGVkZWYgeyhcbiAqICAgKHRoaXM6IFByb2Nlc3NvciwgLi4ucGFyYW1ldGVyczogUGx1Z2luUGFyYW1ldGVycykgPT5cbiAqICAgICBJbnB1dCBleHRlbmRzIHN0cmluZyA/IC8vIFBhcnNlci5cbiAqICAgICAgICBPdXRwdXQgZXh0ZW5kcyBOb2RlIHwgdW5kZWZpbmVkID8gdW5kZWZpbmVkIHwgdm9pZCA6IG5ldmVyIDpcbiAqICAgICBPdXRwdXQgZXh0ZW5kcyBDb21waWxlUmVzdWx0cyA/IC8vIENvbXBpbGVyLlxuICogICAgICAgIElucHV0IGV4dGVuZHMgTm9kZSB8IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCB8IHZvaWQgOiBuZXZlciA6XG4gKiAgICAgVHJhbnNmb3JtZXI8XG4gKiAgICAgICBJbnB1dCBleHRlbmRzIE5vZGUgPyBJbnB1dCA6IE5vZGUsXG4gKiAgICAgICBPdXRwdXQgZXh0ZW5kcyBOb2RlID8gT3V0cHV0IDogTm9kZVxuICogICAgID4gfCB1bmRlZmluZWQgfCB2b2lkXG4gKiApfSBQbHVnaW5cbiAqICAgU2luZ2xlIHBsdWdpbi5cbiAqXG4gKiAgIFBsdWdpbnMgY29uZmlndXJlIHRoZSBwcm9jZXNzb3JzIHRoZXkgYXJlIGFwcGxpZWQgb24gaW4gdGhlIGZvbGxvd2luZ1xuICogICB3YXlzOlxuICpcbiAqICAgKiAgIHRoZXkgY2hhbmdlIHRoZSBwcm9jZXNzb3IsIHN1Y2ggYXMgdGhlIHBhcnNlciwgdGhlIGNvbXBpbGVyLCBvciBieVxuICogICAgICAgY29uZmlndXJpbmcgZGF0YVxuICogICAqICAgdGhleSBzcGVjaWZ5IGhvdyB0byBoYW5kbGUgdHJlZXMgYW5kIGZpbGVzXG4gKlxuICogICBJbiBwcmFjdGljZSwgdGhleSBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHJlY2VpdmUgb3B0aW9ucyBhbmQgY29uZmlndXJlIHRoZVxuICogICBwcm9jZXNzb3IgKGB0aGlzYCkuXG4gKlxuICogICA+ICoqTm90ZSoqOiBwbHVnaW5zIGFyZSBjYWxsZWQgd2hlbiB0aGUgcHJvY2Vzc29yIGlzICpmcm96ZW4qLCBub3Qgd2hlblxuICogICA+IHRoZXkgYXJlIGFwcGxpZWQuXG4gKi9cblxuLyoqXG4gKiBUdXBsZSBvZiBhIHBsdWdpbiBhbmQgaXRzIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhlIGZpcnN0IGl0ZW0gaXMgYSBwbHVnaW4sIHRoZSByZXN0IGFyZSBpdHMgcGFyYW1ldGVycy5cbiAqXG4gKiBAdGVtcGxhdGUge0FycmF5PHVua25vd24+fSBbVHVwbGVQYXJhbWV0ZXJzPVtdXVxuICogICBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwbHVnaW4gKGRlZmF1bHQ6IGBbXWAsIHRoZSBlbXB0eSB0dXBsZSkuXG4gKiBAdGVtcGxhdGUge05vZGUgfCBzdHJpbmcgfCB1bmRlZmluZWR9IFtJbnB1dD11bmRlZmluZWRdXG4gKiAgIFZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgYXMgaW5wdXQgKG9wdGlvbmFsKS5cbiAqXG4gKiAgICogICBJZiB0aGUgcGx1Z2luIHJldHVybnMgYSB7QGxpbmtjb2RlIFRyYW5zZm9ybWVyfSwgdGhpc1xuICogICAgICAgc2hvdWxkIGJlIHRoZSBub2RlIGl0IGV4cGVjdHMuXG4gKiAgICogICBJZiB0aGUgcGx1Z2luIHNldHMgYSB7QGxpbmtjb2RlIFBhcnNlcn0sIHRoaXMgc2hvdWxkIGJlXG4gKiAgICAgICBgc3RyaW5nYC5cbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gc2V0cyBhIHtAbGlua2NvZGUgQ29tcGlsZXJ9LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAqICAgICAgIG5vZGUgaXQgZXhwZWN0cy5cbiAqIEB0ZW1wbGF0ZSBbT3V0cHV0PXVuZGVmaW5lZF0gKG9wdGlvbmFsKS5cbiAqICAgVmFsdWUgdGhhdCBpcyB5aWVsZGVkIGFzIG91dHB1dC5cbiAqXG4gKiAgICogICBJZiB0aGUgcGx1Z2luIHJldHVybnMgYSB7QGxpbmtjb2RlIFRyYW5zZm9ybWVyfSwgdGhpc1xuICogICAgICAgc2hvdWxkIGJlIHRoZSBub2RlIHRoYXQgdGhhdCB5aWVsZHMuXG4gKiAgICogICBJZiB0aGUgcGx1Z2luIHNldHMgYSB7QGxpbmtjb2RlIFBhcnNlcn0sIHRoaXMgc2hvdWxkIGJlIHRoZVxuICogICAgICAgbm9kZSB0aGF0IGl0IHlpZWxkcy5cbiAqICAgKiAgIElmIHRoZSBwbHVnaW4gc2V0cyBhIHtAbGlua2NvZGUgQ29tcGlsZXJ9LCB0aGlzIHNob3VsZCBiZVxuICogICAgICAgcmVzdWx0IGl0IHlpZWxkcy5cbiAqIEB0eXBlZGVmIHsoXG4gKiAgIFtcbiAqICAgICBwbHVnaW46IFBsdWdpbjxUdXBsZVBhcmFtZXRlcnMsIElucHV0LCBPdXRwdXQ+LFxuICogICAgIC4uLnBhcmFtZXRlcnM6IFR1cGxlUGFyYW1ldGVyc1xuICogICBdXG4gKiApfSBQbHVnaW5UdXBsZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgUHJlc2V0XG4gKiAgIFNoYXJhYmxlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogICBUaGV5IGNhbiBjb250YWluIHBsdWdpbnMgYW5kIHNldHRpbmdzLlxuICogQHByb3BlcnR5IHtQbHVnZ2FibGVMaXN0IHwgdW5kZWZpbmVkfSBbcGx1Z2luc11cbiAqICAgTGlzdCBvZiBwbHVnaW5zIGFuZCBwcmVzZXRzIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge1NldHRpbmdzIHwgdW5kZWZpbmVkfSBbc2V0dGluZ3NdXG4gKiAgIFNoYXJlZCBzZXR0aW5ncyBmb3IgcGFyc2VycyBhbmQgY29tcGlsZXJzIChvcHRpb25hbCkuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge1ZGaWxlfSBbRmlsZT1WRmlsZV1cbiAqICAgVGhlIGZpbGUgdGhhdCB0aGUgY2FsbGJhY2sgcmVjZWl2ZXMgKGRlZmF1bHQ6IGBWRmlsZWApLlxuICogQGNhbGxiYWNrIFByb2Nlc3NDYWxsYmFja1xuICogICBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcHJvY2VzcyBpcyBkb25lLlxuICpcbiAqICAgQ2FsbGVkIHdpdGggZWl0aGVyIGFuIGVycm9yIG9yIGEgcmVzdWx0LlxuICogQHBhcmFtIHtFcnJvciB8IHVuZGVmaW5lZH0gW2Vycm9yXVxuICogICBGYXRhbCBlcnJvciAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtGaWxlIHwgdW5kZWZpbmVkfSBbZmlsZV1cbiAqICAgUHJvY2Vzc2VkIGZpbGUgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IFtUcmVlPU5vZGVdXG4gKiAgIFRoZSB0cmVlIHRoYXQgdGhlIGNhbGxiYWNrIHJlY2VpdmVzIChkZWZhdWx0OiBgTm9kZWApLlxuICogQGNhbGxiYWNrIFJ1bkNhbGxiYWNrXG4gKiAgIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRyYW5zZm9ybWVycyBhcmUgZG9uZS5cbiAqXG4gKiAgIENhbGxlZCB3aXRoIGVpdGhlciBhbiBlcnJvciBvciByZXN1bHRzLlxuICogQHBhcmFtIHtFcnJvciB8IHVuZGVmaW5lZH0gW2Vycm9yXVxuICogICBGYXRhbCBlcnJvciAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtUcmVlIHwgdW5kZWZpbmVkfSBbdHJlZV1cbiAqICAgVHJhbnNmb3JtZWQgdHJlZSAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtWRmlsZSB8IHVuZGVmaW5lZH0gW2ZpbGVdXG4gKiAgIEZpbGUgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IFtPdXRwdXQ9Tm9kZV1cbiAqICAgTm9kZSB0eXBlIHRoYXQgdGhlIHRyYW5zZm9ybWVyIHlpZWxkcyAoZGVmYXVsdDogYE5vZGVgKS5cbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1DYWxsYmFja1xuICogICBDYWxsYmFjayBwYXNzZWQgdG8gdHJhbnNmb3Jtcy5cbiAqXG4gKiAgIElmIHRoZSBzaWduYXR1cmUgb2YgYSBgdHJhbnNmb3JtZXJgIGFjY2VwdHMgYSB0aGlyZCBhcmd1bWVudCwgdGhlXG4gKiAgIHRyYW5zZm9ybWVyIG1heSBwZXJmb3JtIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLCBhbmQgbXVzdCBjYWxsIGl0LlxuICogQHBhcmFtIHtFcnJvciB8IHVuZGVmaW5lZH0gW2Vycm9yXVxuICogICBGYXRhbCBlcnJvciB0byBzdG9wIHRoZSBwcm9jZXNzIChvcHRpb25hbCkuXG4gKiBAcGFyYW0ge091dHB1dCB8IHVuZGVmaW5lZH0gW3RyZWVdXG4gKiAgIE5ldywgY2hhbmdlZCwgdHJlZSAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtWRmlsZSB8IHVuZGVmaW5lZH0gW2ZpbGVdXG4gKiAgIE5ldywgY2hhbmdlZCwgZmlsZSAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gW0lucHV0PU5vZGVdXG4gKiAgIE5vZGUgdHlwZSB0aGF0IHRoZSB0cmFuc2Zvcm1lciBleHBlY3RzIChkZWZhdWx0OiBgTm9kZWApLlxuICogQHRlbXBsYXRlIHtOb2RlfSBbT3V0cHV0PUlucHV0XVxuICogICBOb2RlIHR5cGUgdGhhdCB0aGUgdHJhbnNmb3JtZXIgeWllbGRzIChkZWZhdWx0OiBgSW5wdXRgKS5cbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1lclxuICogICBUcmFuc2Zvcm1lcnMgaGFuZGxlIHN5bnRheCB0cmVlcyBhbmQgZmlsZXMuXG4gKlxuICogICBUaGV5IGFyZSBmdW5jdGlvbnMgdGhhdCBhcmUgY2FsbGVkIGVhY2ggdGltZSBhIHN5bnRheCB0cmVlIGFuZCBmaWxlIGFyZVxuICogICBwYXNzZWQgdGhyb3VnaCB0aGUgcnVuIHBoYXNlLlxuICogICBXaGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGVtIChlaXRoZXIgYmVjYXVzZSBpdOKAmXMgdGhyb3duLCByZXR1cm5lZCxcbiAqICAgcmVqZWN0ZWQsIG9yIHBhc3NlZCB0byBgbmV4dGApLCB0aGUgcHJvY2VzcyBzdG9wcy5cbiAqXG4gKiAgIFRoZSBydW4gcGhhc2UgaXMgaGFuZGxlZCBieSBbYHRyb3VnaGBdW3Ryb3VnaF0sIHNlZSBpdHMgZG9jdW1lbnRhdGlvbiBmb3JcbiAqICAgdGhlIGV4YWN0IHNlbWFudGljcyBvZiB0aGVzZSBmdW5jdGlvbnMuXG4gKlxuICogICA+ICoqTm90ZSoqOiB5b3Ugc2hvdWxkIGxpa2VseSBpZ25vcmUgYG5leHRgOiBkb27igJl0IGFjY2VwdCBpdC5cbiAqICAgPiBpdCBzdXBwb3J0cyBjYWxsYmFjay1zdHlsZSBhc3luYyB3b3JrLlxuICogICA+IEJ1dCBwcm9taXNlcyBhcmUgbGlrZWx5IGVhc2llciB0byByZWFzb24gYWJvdXQuXG4gKlxuICogICBbdHJvdWdoXTogaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS90cm91Z2gjZnVuY3Rpb24tZm5pbnB1dC1uZXh0XG4gKiBAcGFyYW0ge0lucHV0fSB0cmVlXG4gKiAgIFRyZWUgdG8gaGFuZGxlLlxuICogQHBhcmFtIHtWRmlsZX0gZmlsZVxuICogICBGaWxlIHRvIGhhbmRsZS5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtQ2FsbGJhY2s8T3V0cHV0Pn0gbmV4dFxuICogICBDYWxsYmFjay5cbiAqIEByZXR1cm5zIHsoXG4gKiAgIFByb21pc2U8T3V0cHV0IHwgdW5kZWZpbmVkIHwgdm9pZD4gfFxuICogICBQcm9taXNlPG5ldmVyPiB8IC8vIEZvciBzb21lIHJlYXNvbiB0aGlzIGlzIG5lZWRlZCBzZXBhcmF0ZWx5LlxuICogICBPdXRwdXQgfFxuICogICBFcnJvciB8XG4gKiAgIHVuZGVmaW5lZCB8XG4gKiAgIHZvaWRcbiAqICl9XG4gKiAgIElmIHlvdSBhY2NlcHQgYG5leHRgLCBub3RoaW5nLlxuICogICBPdGhlcndpc2U6XG4gKlxuICogICAqICAgYEVycm9yYCDigJQgZmF0YWwgZXJyb3IgdG8gc3RvcCB0aGUgcHJvY2Vzc1xuICogICAqICAgYFByb21pc2U8dW5kZWZpbmVkPmAgb3IgYHVuZGVmaW5lZGAg4oCUIHRoZSBuZXh0IHRyYW5zZm9ybWVyIGtlZXBzIHVzaW5nXG4gKiAgICAgICBzYW1lIHRyZWVcbiAqICAgKiAgIGBQcm9taXNlPE5vZGU+YCBvciBgTm9kZWAg4oCUIG5ldywgY2hhbmdlZCwgdHJlZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlIHwgdW5kZWZpbmVkfSBQYXJzZVRyZWVcbiAqICAgT3V0cHV0IG9mIGBwYXJzZWAuXG4gKiBAdGVtcGxhdGUge05vZGUgfCB1bmRlZmluZWR9IEhlYWRUcmVlXG4gKiAgIElucHV0IGZvciBgcnVuYC5cbiAqIEB0ZW1wbGF0ZSB7Tm9kZSB8IHVuZGVmaW5lZH0gVGFpbFRyZWVcbiAqICAgT3V0cHV0IGZvciBgcnVuYC5cbiAqIEB0ZW1wbGF0ZSB7Tm9kZSB8IHVuZGVmaW5lZH0gQ29tcGlsZVRyZWVcbiAqICAgSW5wdXQgb2YgYHN0cmluZ2lmeWAuXG4gKiBAdGVtcGxhdGUge0NvbXBpbGVSZXN1bHRzIHwgdW5kZWZpbmVkfSBDb21waWxlUmVzdWx0XG4gKiAgIE91dHB1dCBvZiBgc3RyaW5naWZ5YC5cbiAqIEB0ZW1wbGF0ZSB7Tm9kZSB8IHN0cmluZyB8IHVuZGVmaW5lZH0gSW5wdXRcbiAqICAgSW5wdXQgb2YgcGx1Z2luLlxuICogQHRlbXBsYXRlIE91dHB1dFxuICogICBPdXRwdXQgb2YgcGx1Z2luIChvcHRpb25hbCkuXG4gKiBAdHlwZWRlZiB7KFxuICogICBJbnB1dCBleHRlbmRzIHN0cmluZ1xuICogICAgID8gT3V0cHV0IGV4dGVuZHMgTm9kZSB8IHVuZGVmaW5lZFxuICogICAgICAgPyAvLyBQYXJzZXIuXG4gKiAgICAgICAgIFByb2Nlc3NvcjxcbiAqICAgICAgICAgICBPdXRwdXQgZXh0ZW5kcyB1bmRlZmluZWQgPyBQYXJzZVRyZWUgOiBPdXRwdXQsXG4gKiAgICAgICAgICAgSGVhZFRyZWUsXG4gKiAgICAgICAgICAgVGFpbFRyZWUsXG4gKiAgICAgICAgICAgQ29tcGlsZVRyZWUsXG4gKiAgICAgICAgICAgQ29tcGlsZVJlc3VsdFxuICogICAgICAgICA+XG4gKiAgICAgICA6IC8vIFVua25vd24uXG4gKiAgICAgICAgIFByb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+XG4gKiAgICAgOiBPdXRwdXQgZXh0ZW5kcyBDb21waWxlUmVzdWx0c1xuICogICAgID8gSW5wdXQgZXh0ZW5kcyBOb2RlIHwgdW5kZWZpbmVkXG4gKiAgICAgICA/IC8vIENvbXBpbGVyLlxuICogICAgICAgICBQcm9jZXNzb3I8XG4gKiAgICAgICAgICAgUGFyc2VUcmVlLFxuICogICAgICAgICAgIEhlYWRUcmVlLFxuICogICAgICAgICAgIFRhaWxUcmVlLFxuICogICAgICAgICAgIElucHV0IGV4dGVuZHMgdW5kZWZpbmVkID8gQ29tcGlsZVRyZWUgOiBJbnB1dCxcbiAqICAgICAgICAgICBPdXRwdXQgZXh0ZW5kcyB1bmRlZmluZWQgPyBDb21waWxlUmVzdWx0IDogT3V0cHV0XG4gKiAgICAgICAgID5cbiAqICAgICAgIDogLy8gVW5rbm93bi5cbiAqICAgICAgICAgUHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD5cbiAqICAgICA6IElucHV0IGV4dGVuZHMgTm9kZSB8IHVuZGVmaW5lZFxuICogICAgID8gT3V0cHV0IGV4dGVuZHMgTm9kZSB8IHVuZGVmaW5lZFxuICogICAgICAgPyAvLyBUcmFuc2Zvcm0uXG4gKiAgICAgICAgIFByb2Nlc3NvcjxcbiAqICAgICAgICAgICBQYXJzZVRyZWUsXG4gKiAgICAgICAgICAgSGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBJbnB1dCA6IEhlYWRUcmVlLFxuICogICAgICAgICAgIE91dHB1dCBleHRlbmRzIHVuZGVmaW5lZCA/IFRhaWxUcmVlIDogT3V0cHV0LFxuICogICAgICAgICAgIENvbXBpbGVUcmVlLFxuICogICAgICAgICAgIENvbXBpbGVSZXN1bHRcbiAqICAgICAgICAgPlxuICogICAgICAgOiAvLyBVbmtub3duLlxuICogICAgICAgICBQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0PlxuICogICAgIDogLy8gVW5rbm93bi5cbiAqICAgICAgIFByb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+XG4gKiApfSBVc2VQbHVnaW5cbiAqICAgQ3JlYXRlIGEgcHJvY2Vzc29yIGJhc2VkIG9uIHRoZSBpbnB1dC9vdXRwdXQgb2YgYSB7QGxpbmsgUGx1Z2luIHBsdWdpbn0uXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NvbXBpbGVSZXN1bHRzIHwgdW5kZWZpbmVkfSBSZXN1bHRcbiAqICAgTm9kZSB0eXBlIHRoYXQgdGhlIHRyYW5zZm9ybWVyIHlpZWxkcy5cbiAqIEB0eXBlZGVmIHsoXG4gKiAgIFJlc3VsdCBleHRlbmRzIFZhbHVlIHwgdW5kZWZpbmVkID9cbiAqICAgICBWRmlsZSA6XG4gKiAgICAgVkZpbGUgJiB7cmVzdWx0OiBSZXN1bHR9XG4gKiAgICl9IFZGaWxlV2l0aE91dHB1dFxuICogICBUeXBlIHRvIGdlbmVyYXRlIGEge0BsaW5rY29kZSBWRmlsZX0gY29ycmVzcG9uZGluZyB0byBhIGNvbXBpbGVyIHJlc3VsdC5cbiAqXG4gKiAgIElmIGEgcmVzdWx0IHRoYXQgaXMgbm90IGFjY2VwdGFibGUgb24gYSBgVkZpbGVgIGlzIHVzZWQsIHRoYXQgd2lsbFxuICogICBiZSBzdG9yZWQgb24gdGhlIGByZXN1bHRgIGZpZWxkIG9mIHtAbGlua2NvZGUgVkZpbGV9LlxuICovXG5cbmltcG9ydCB7YmFpbH0gZnJvbSAnYmFpbCdcbmltcG9ydCBleHRlbmQgZnJvbSAnZXh0ZW5kJ1xuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCBpc1BsYWluT2JqIGZyb20gJ2lzLXBsYWluLW9iaidcbmltcG9ydCB7dHJvdWdofSBmcm9tICd0cm91Z2gnXG5pbXBvcnQge1ZGaWxlfSBmcm9tICd2ZmlsZSdcbmltcG9ydCB7Q2FsbGFibGVJbnN0YW5jZX0gZnJvbSAnLi9jYWxsYWJsZS1pbnN0YW5jZS5qcydcblxuLy8gVG8gZG86IG5leHQgbWFqb3I6IGRyb3AgYENvbXBpbGVyYCwgYFBhcnNlcmA6IHByZWZlciBsb3dlcmNhc2UuXG5cbi8vIFRvIGRvOiB3ZSBjb3VsZCBzdGFydCB5aWVsZGluZyBgbmV2ZXJgIGluIFRTIHdoZW4gYSBwYXJzZXIgaXMgbWlzc2luZyBhbmRcbi8vIGBwYXJzZWAgaXMgY2FsbGVkLlxuLy8gQ3VycmVudGx5LCB3ZSBhbGxvdyBkaXJlY3RseSBzZXR0aW5nIGBwcm9jZXNzb3IucGFyc2VyYCwgd2hpY2ggaXMgdW50eXBlZC5cblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGUgfCB1bmRlZmluZWR9IFtQYXJzZVRyZWU9dW5kZWZpbmVkXVxuICogICBPdXRwdXQgb2YgYHBhcnNlYCAob3B0aW9uYWwpLlxuICogQHRlbXBsYXRlIHtOb2RlIHwgdW5kZWZpbmVkfSBbSGVhZFRyZWU9dW5kZWZpbmVkXVxuICogICBJbnB1dCBmb3IgYHJ1bmAgKG9wdGlvbmFsKS5cbiAqIEB0ZW1wbGF0ZSB7Tm9kZSB8IHVuZGVmaW5lZH0gW1RhaWxUcmVlPXVuZGVmaW5lZF1cbiAqICAgT3V0cHV0IGZvciBgcnVuYCAob3B0aW9uYWwpLlxuICogQHRlbXBsYXRlIHtOb2RlIHwgdW5kZWZpbmVkfSBbQ29tcGlsZVRyZWU9dW5kZWZpbmVkXVxuICogICBJbnB1dCBvZiBgc3RyaW5naWZ5YCAob3B0aW9uYWwpLlxuICogQHRlbXBsYXRlIHtDb21waWxlUmVzdWx0cyB8IHVuZGVmaW5lZH0gW0NvbXBpbGVSZXN1bHQ9dW5kZWZpbmVkXVxuICogICBPdXRwdXQgb2YgYHN0cmluZ2lmeWAgKG9wdGlvbmFsKS5cbiAqIEBleHRlbmRzIHtDYWxsYWJsZUluc3RhbmNlPFtdLCBQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0Pj59XG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzb3IgZXh0ZW5kcyBDYWxsYWJsZUluc3RhbmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHByb2Nlc3Nvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIElmIGBQcm9jZXNzb3IoKWAgaXMgY2FsbGVkICh3L28gbmV3KSwgYGNvcHlgIGlzIGNhbGxlZCBpbnN0ZWFkLlxuICAgIHN1cGVyKCdjb3B5JylcblxuICAgIC8qKlxuICAgICAqIENvbXBpbGVyIHRvIHVzZSAoZGVwcmVjYXRlZCkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqICAgVXNlIGBjb21waWxlcmAgaW5zdGVhZC5cbiAgICAgKiBAdHlwZSB7KFxuICAgICAqICAgQ29tcGlsZXI8XG4gICAgICogICAgIENvbXBpbGVUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IENvbXBpbGVUcmVlLFxuICAgICAqICAgICBDb21waWxlUmVzdWx0IGV4dGVuZHMgdW5kZWZpbmVkID8gQ29tcGlsZVJlc3VsdHMgOiBDb21waWxlUmVzdWx0XG4gICAgICogICA+IHxcbiAgICAgKiAgIHVuZGVmaW5lZFxuICAgICAqICl9XG4gICAgICovXG4gICAgdGhpcy5Db21waWxlciA9IHVuZGVmaW5lZFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VyIHRvIHVzZSAoZGVwcmVjYXRlZCkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqICAgVXNlIGBwYXJzZXJgIGluc3RlYWQuXG4gICAgICogQHR5cGUgeyhcbiAgICAgKiAgIFBhcnNlcjxQYXJzZVRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogUGFyc2VUcmVlPiB8XG4gICAgICogICB1bmRlZmluZWRcbiAgICAgKiApfVxuICAgICAqL1xuICAgIHRoaXMuUGFyc2VyID0gdW5kZWZpbmVkXG5cbiAgICAvLyBOb3RlOiB0aGUgZm9sbG93aW5nIGZpZWxkcyBhcmUgY29uc2lkZXJlZCBwcml2YXRlLlxuICAgIC8vIEhvd2V2ZXIsIHRoZXkgYXJlIG5lZWRlZCBmb3IgdGVzdHMsIGFuZCBUU0MgZ2VuZXJhdGVzIGFuIHVudHlwZWRcbiAgICAvLyBgcHJpdmF0ZSBmcmVlemVJbmRleGAgZmllbGQgZm9yLCB3aGljaCB0cmlwcyBgdHlwZS1jb3ZlcmFnZWAgdXAuXG4gICAgLy8gSW5zdGVhZCwgd2UgdXNlIGBAZGVwcmVjYXRlZGAgdG8gdmlzdWFsaXplIHRoYXQgdGhleSBzaG91bGRu4oCZdCBiZSB1c2VkLlxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGxpc3Qgb2YgY29uZmlndXJlZCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiAgIFRoaXMgaXMgYSBwcml2YXRlIGludGVybmFsIHByb3BlcnR5IGFuZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICogQHR5cGUge0FycmF5PFBsdWdpblR1cGxlPEFycmF5PHVua25vd24+Pj59XG4gICAgICovXG4gICAgdGhpcy5hdHRhY2hlcnMgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZXIgdG8gdXNlLlxuICAgICAqXG4gICAgICogQHR5cGUgeyhcbiAgICAgKiAgIENvbXBpbGVyPFxuICAgICAqICAgICBDb21waWxlVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBDb21waWxlVHJlZSxcbiAgICAgKiAgICAgQ29tcGlsZVJlc3VsdCBleHRlbmRzIHVuZGVmaW5lZCA/IENvbXBpbGVSZXN1bHRzIDogQ29tcGlsZVJlc3VsdFxuICAgICAqICAgPiB8XG4gICAgICogICB1bmRlZmluZWRcbiAgICAgKiApfVxuICAgICAqL1xuICAgIHRoaXMuY29tcGlsZXIgPSB1bmRlZmluZWRcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHN0YXRlIHRvIHRyYWNrIHdoZXJlIHdlIGFyZSB3aGlsZSBmcmVlemluZy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogICBUaGlzIGlzIGEgcHJpdmF0ZSBpbnRlcm5hbCBwcm9wZXJ0eSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmVlemVJbmRleCA9IC0xXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBzdGF0ZSB0byB0cmFjayB3aGV0aGVyIHdl4oCZcmUgZnJvemVuLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiAgIFRoaXMgaXMgYSBwcml2YXRlIGludGVybmFsIHByb3BlcnR5IGFuZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mcm96ZW4gPSB1bmRlZmluZWRcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiAgIFRoaXMgaXMgYSBwcml2YXRlIGludGVybmFsIHByb3BlcnR5IGFuZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICogQHR5cGUge0RhdGF9XG4gICAgICovXG4gICAgdGhpcy5uYW1lc3BhY2UgPSB7fVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VyIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHsoXG4gICAgICogICBQYXJzZXI8UGFyc2VUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFBhcnNlVHJlZT4gfFxuICAgICAqICAgdW5kZWZpbmVkXG4gICAgICogKX1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlciA9IHVuZGVmaW5lZFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbGlzdCBvZiBjb25maWd1cmVkIHRyYW5zZm9ybWVycy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogICBUaGlzIGlzIGEgcHJpdmF0ZSBpbnRlcm5hbCBwcm9wZXJ0eSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqIEB0eXBlIHtQaXBlbGluZX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybWVycyA9IHRyb3VnaCgpXG4gIH1cblxuICAvKipcbiAgICogQ29weSBhIHByb2Nlc3Nvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogICBUaGlzIGlzIGEgcHJpdmF0ZSBpbnRlcm5hbCBtZXRob2QgYW5kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fVxuICAgKiAgIE5ldyAqdW5mcm96ZW4qIHByb2Nlc3NvciAoe0BsaW5rY29kZSBQcm9jZXNzb3J9KSB0aGF0IGlzXG4gICAqICAgY29uZmlndXJlZCB0byB3b3JrIHRoZSBzYW1lIGFzIGl0cyBhbmNlc3Rvci5cbiAgICogICBXaGVuIHRoZSBkZXNjZW5kYW50IHByb2Nlc3NvciBpcyBjb25maWd1cmVkIGluIHRoZSBmdXR1cmUgaXQgZG9lcyBub3RcbiAgICogICBhZmZlY3QgdGhlIGFuY2VzdHJhbCBwcm9jZXNzb3IuXG4gICAqL1xuICBjb3B5KCkge1xuICAgIC8vIENhc3QgYXMgdGhlIHR5cGUgcGFyYW1ldGVycyB3aWxsIGJlIHRoZSBzYW1lIGFmdGVyIGF0dGFjaGluZy5cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9XG4gICAgICAvKiogQHR5cGUge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fSAqLyAoXG4gICAgICAgIG5ldyBQcm9jZXNzb3IoKVxuICAgICAgKVxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHRoaXMuYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgYXR0YWNoZXIgPSB0aGlzLmF0dGFjaGVyc1tpbmRleF1cbiAgICAgIGRlc3RpbmF0aW9uLnVzZSguLi5hdHRhY2hlcilcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5kYXRhKGV4dGVuZCh0cnVlLCB7fSwgdGhpcy5uYW1lc3BhY2UpKVxuXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBwcm9jZXNzb3Igd2l0aCBpbmZvIGF2YWlsYWJsZSB0byBhbGwgcGx1Z2lucy5cbiAgICogSW5mb3JtYXRpb24gaXMgc3RvcmVkIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogVHlwaWNhbGx5LCBvcHRpb25zIGNhbiBiZSBnaXZlbiB0byBhIHNwZWNpZmljIHBsdWdpbiwgYnV0IHNvbWV0aW1lcyBpdFxuICAgKiBtYWtlcyBzZW5zZSB0byBoYXZlIGluZm9ybWF0aW9uIHNoYXJlZCB3aXRoIHNldmVyYWwgcGx1Z2lucy5cbiAgICogRm9yIGV4YW1wbGUsIGEgbGlzdCBvZiBIVE1MIGVsZW1lbnRzIHRoYXQgYXJlIHNlbGYtY2xvc2luZywgd2hpY2ggaXNcbiAgICogbmVlZGVkIGR1cmluZyBhbGwgcGhhc2VzLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiBzZXR0aW5nIGluZm9ybWF0aW9uIGNhbm5vdCBvY2N1ciBvbiAqZnJvemVuKiBwcm9jZXNzb3JzLlxuICAgKiA+IENhbGwgdGhlIHByb2Nlc3NvciBmaXJzdCB0byBjcmVhdGUgYSBuZXcgdW5mcm96ZW4gcHJvY2Vzc29yLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiB0byByZWdpc3RlciBjdXN0b20gZGF0YSBpbiBUeXBlU2NyaXB0LCBhdWdtZW50IHRoZVxuICAgKiA+IHtAbGlua2NvZGUgRGF0YX0gaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIFRoaXMgZXhhbXBsZSBzaG93IGhvdyB0byBnZXQgYW5kIHNldCBpbmZvOlxuICAgKlxuICAgKiAgIGBgYGpzXG4gICAqICAgaW1wb3J0IHt1bmlmaWVkfSBmcm9tICd1bmlmaWVkJ1xuICAgKlxuICAgKiAgIGNvbnN0IHByb2Nlc3NvciA9IHVuaWZpZWQoKS5kYXRhKCdhbHBoYScsICdicmF2bycpXG4gICAqXG4gICAqICAgcHJvY2Vzc29yLmRhdGEoJ2FscGhhJykgLy8gPT4gJ2JyYXZvJ1xuICAgKlxuICAgKiAgIHByb2Nlc3Nvci5kYXRhKCkgLy8gPT4ge2FscGhhOiAnYnJhdm8nfVxuICAgKlxuICAgKiAgIHByb2Nlc3Nvci5kYXRhKHtjaGFybGllOiAnZGVsdGEnfSlcbiAgICpcbiAgICogICBwcm9jZXNzb3IuZGF0YSgpIC8vID0+IHtjaGFybGllOiAnZGVsdGEnfVxuICAgKiAgIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIERhdGF9IEtleVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHJldHVybnMge0RhdGF9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0RhdGF9IGRhdGFzZXRcbiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiBAcmV0dXJucyB7RGF0YVtLZXldfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtLZXl9IGtleVxuICAgKiBAcGFyYW0ge0RhdGFbS2V5XX0gdmFsdWVcbiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fVxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGEgfCBLZXl9IFtrZXldXG4gICAqICAgS2V5IHRvIGdldCBvciBzZXQsIG9yIGVudGlyZSBkYXRhc2V0IHRvIHNldCwgb3Igbm90aGluZyB0byBnZXQgdGhlXG4gICAqICAgZW50aXJlIGRhdGFzZXQgKG9wdGlvbmFsKS5cbiAgICogQHBhcmFtIHtEYXRhW0tleV19IFt2YWx1ZV1cbiAgICogICBWYWx1ZSB0byBzZXQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybnMge3Vua25vd259XG4gICAqICAgVGhlIGN1cnJlbnQgcHJvY2Vzc29yIHdoZW4gc2V0dGluZywgdGhlIHZhbHVlIGF0IGBrZXlgIHdoZW4gZ2V0dGluZywgb3JcbiAgICogICB0aGUgZW50aXJlIGRhdGFzZXQgd2hlbiBnZXR0aW5nIHdpdGhvdXQga2V5LlxuICAgKi9cbiAgZGF0YShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBTZXQgYGtleWAuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBhc3NlcnRVbmZyb3plbignZGF0YScsIHRoaXMuZnJvemVuKVxuICAgICAgICB0aGlzLm5hbWVzcGFjZVtrZXldID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGBrZXlgLlxuICAgICAgcmV0dXJuIChvd24uY2FsbCh0aGlzLm5hbWVzcGFjZSwga2V5KSAmJiB0aGlzLm5hbWVzcGFjZVtrZXldKSB8fCB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvLyBTZXQgc3BhY2UuXG4gICAgaWYgKGtleSkge1xuICAgICAgYXNzZXJ0VW5mcm96ZW4oJ2RhdGEnLCB0aGlzLmZyb3plbilcbiAgICAgIHRoaXMubmFtZXNwYWNlID0ga2V5XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIEdldCBzcGFjZS5cbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmVlemUgYSBwcm9jZXNzb3IuXG4gICAqXG4gICAqIEZyb3plbiBwcm9jZXNzb3JzIGFyZSBtZWFudCB0byBiZSBleHRlbmRlZCBhbmQgbm90IHRvIGJlIGNvbmZpZ3VyZWRcbiAgICogZGlyZWN0bHkuXG4gICAqXG4gICAqIFdoZW4gYSBwcm9jZXNzb3IgaXMgZnJvemVuIGl0IGNhbm5vdCBiZSB1bmZyb3plbi5cbiAgICogTmV3IHByb2Nlc3NvcnMgd29ya2luZyB0aGUgc2FtZSB3YXkgY2FuIGJlIGNyZWF0ZWQgYnkgY2FsbGluZyB0aGVcbiAgICogcHJvY2Vzc29yLlxuICAgKlxuICAgKiBJdOKAmXMgcG9zc2libGUgdG8gZnJlZXplIHByb2Nlc3NvcnMgZXhwbGljaXRseSBieSBjYWxsaW5nIGAuZnJlZXplKClgLlxuICAgKiBQcm9jZXNzb3JzIGZyZWV6ZSBhdXRvbWF0aWNhbGx5IHdoZW4gYC5wYXJzZSgpYCwgYC5ydW4oKWAsIGAucnVuU3luYygpYCxcbiAgICogYC5zdHJpbmdpZnkoKWAsIGAucHJvY2VzcygpYCwgb3IgYC5wcm9jZXNzU3luYygpYCBhcmUgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD59XG4gICAqICAgVGhlIGN1cnJlbnQgcHJvY2Vzc29yLlxuICAgKi9cbiAgZnJlZXplKCkge1xuICAgIGlmICh0aGlzLmZyb3plbikge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBDYXN0IHNvIHRoYXQgd2UgY2FuIHR5cGUgcGx1Z2lucyBlYXNpZXIuXG4gICAgLy8gUGx1Z2lucyBhcmUgc3VwcG9zZWQgdG8gYmUgdXNhYmxlIG9uIGRpZmZlcmVudCBwcm9jZXNzb3JzLCBub3QganVzdCBvblxuICAgIC8vIHRoaXMgZXhhY3QgcHJvY2Vzc29yLlxuICAgIGNvbnN0IHNlbGYgPSAvKiogQHR5cGUge1Byb2Nlc3Nvcn0gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKHRoaXMpKVxuXG4gICAgd2hpbGUgKCsrdGhpcy5mcmVlemVJbmRleCA8IHRoaXMuYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgW2F0dGFjaGVyLCAuLi5vcHRpb25zXSA9IHRoaXMuYXR0YWNoZXJzW3RoaXMuZnJlZXplSW5kZXhdXG5cbiAgICAgIGlmIChvcHRpb25zWzBdID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uc1swXSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zWzBdID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gYXR0YWNoZXIuY2FsbChzZWxmLCAuLi5vcHRpb25zKVxuXG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXJzLnVzZSh0cmFuc2Zvcm1lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyb3plbiA9IHRydWVcbiAgICB0aGlzLmZyZWV6ZUluZGV4ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRleHQgdG8gYSBzeW50YXggdHJlZS5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHBhcnNlYCBmcmVlemVzIHRoZSBwcm9jZXNzb3IgaWYgbm90IGFscmVhZHkgKmZyb3plbiouXG4gICAqXG4gICAqID4gKipOb3RlKio6IGBwYXJzZWAgcGVyZm9ybXMgdGhlIHBhcnNlIHBoYXNlLCBub3QgdGhlIHJ1biBwaGFzZSBvciBvdGhlclxuICAgKiA+IHBoYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBbZmlsZV1cbiAgICogICBmaWxlIHRvIHBhcnNlIChvcHRpb25hbCk7IHR5cGljYWxseSBgc3RyaW5nYCBvciBgVkZpbGVgOyBhbnkgdmFsdWVcbiAgICogICBhY2NlcHRlZCBhcyBgeGAgaW4gYG5ldyBWRmlsZSh4KWAuXG4gICAqIEByZXR1cm5zIHtQYXJzZVRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogUGFyc2VUcmVlfVxuICAgKiAgIFN5bnRheCB0cmVlIHJlcHJlc2VudGluZyBgZmlsZWAuXG4gICAqL1xuICBwYXJzZShmaWxlKSB7XG4gICAgdGhpcy5mcmVlemUoKVxuICAgIGNvbnN0IHJlYWxGaWxlID0gdmZpbGUoZmlsZSlcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlciB8fCB0aGlzLlBhcnNlclxuICAgIGFzc2VydFBhcnNlcigncGFyc2UnLCBwYXJzZXIpXG4gICAgcmV0dXJuIHBhcnNlcihTdHJpbmcocmVhbEZpbGUpLCByZWFsRmlsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBnaXZlbiBmaWxlIGFzIGNvbmZpZ3VyZWQgb24gdGhlIHByb2Nlc3Nvci5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHByb2Nlc3NgIGZyZWV6ZXMgdGhlIHByb2Nlc3NvciBpZiBub3QgYWxyZWFkeSAqZnJvemVuKi5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHByb2Nlc3NgIHBlcmZvcm1zIHRoZSBwYXJzZSwgcnVuLCBhbmQgc3RyaW5naWZ5IHBoYXNlcy5cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gZmlsZVxuICAgKiBAcGFyYW0ge1Byb2Nlc3NDYWxsYmFjazxWRmlsZVdpdGhPdXRwdXQ8Q29tcGlsZVJlc3VsdD4+fSBkb25lXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWRmlsZVdpdGhPdXRwdXQ8Q29tcGlsZVJlc3VsdD4+fVxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXVxuICAgKiAgIEZpbGUgKG9wdGlvbmFsKTsgdHlwaWNhbGx5IGBzdHJpbmdgIG9yIGBWRmlsZWBdOyBhbnkgdmFsdWUgYWNjZXB0ZWQgYXNcbiAgICogICBgeGAgaW4gYG5ldyBWRmlsZSh4KWAuXG4gICAqIEBwYXJhbSB7UHJvY2Vzc0NhbGxiYWNrPFZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0Pj4gfCB1bmRlZmluZWR9IFtkb25lXVxuICAgKiAgIENhbGxiYWNrIChvcHRpb25hbCkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZGaWxlPiB8IHVuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nIGlmIGBkb25lYCBpcyBnaXZlbi5cbiAgICogICBPdGhlcndpc2UgYSBwcm9taXNlLCByZWplY3RlZCB3aXRoIGEgZmF0YWwgZXJyb3Igb3IgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgICogICBwcm9jZXNzZWQgZmlsZS5cbiAgICpcbiAgICogICBUaGUgcGFyc2VkLCB0cmFuc2Zvcm1lZCwgYW5kIGNvbXBpbGVkIHZhbHVlIGlzIGF2YWlsYWJsZSBhdFxuICAgKiAgIGBmaWxlLnZhbHVlYCAoc2VlIG5vdGUpLlxuICAgKlxuICAgKiAgID4gKipOb3RlKio6IHVuaWZpZWQgdHlwaWNhbGx5IGNvbXBpbGVzIGJ5IHNlcmlhbGl6aW5nOiBtb3N0XG4gICAqICAgPiBjb21waWxlcnMgcmV0dXJuIGBzdHJpbmdgIChvciBgVWludDhBcnJheWApLlxuICAgKiAgID4gU29tZSBjb21waWxlcnMsIHN1Y2ggYXMgdGhlIG9uZSBjb25maWd1cmVkIHdpdGhcbiAgICogICA+IFtgcmVoeXBlLXJlYWN0YF1bcmVoeXBlLXJlYWN0XSwgcmV0dXJuIG90aGVyIHZhbHVlcyAoaW4gdGhpcyBjYXNlLCBhXG4gICAqICAgPiBSZWFjdCB0cmVlKS5cbiAgICogICA+IElmIHlvdeKAmXJlIHVzaW5nIGEgY29tcGlsZXIgdGhhdCBkb2VzbuKAmXQgc2VyaWFsaXplLCBleHBlY3QgZGlmZmVyZW50XG4gICAqICAgPiByZXN1bHQgdmFsdWVzLlxuICAgKiAgID5cbiAgICogICA+IFRvIHJlZ2lzdGVyIGN1c3RvbSByZXN1bHRzIGluIFR5cGVTY3JpcHQsIGFkZCB0aGVtIHRvXG4gICAqICAgPiB7QGxpbmtjb2RlIENvbXBpbGVSZXN1bHRNYXB9LlxuICAgKlxuICAgKiAgIFtyZWh5cGUtcmVhY3RdOiBodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0XG4gICAqL1xuICBwcm9jZXNzKGZpbGUsIGRvbmUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuXG4gICAgdGhpcy5mcmVlemUoKVxuICAgIGFzc2VydFBhcnNlcigncHJvY2VzcycsIHRoaXMucGFyc2VyIHx8IHRoaXMuUGFyc2VyKVxuICAgIGFzc2VydENvbXBpbGVyKCdwcm9jZXNzJywgdGhpcy5jb21waWxlciB8fCB0aGlzLkNvbXBpbGVyKVxuXG4gICAgcmV0dXJuIGRvbmUgPyBleGVjdXRvcih1bmRlZmluZWQsIGRvbmUpIDogbmV3IFByb21pc2UoZXhlY3V0b3IpXG5cbiAgICAvLyBOb3RlOiBgdm9pZGBzIG5lZWRlZCBmb3IgVFMuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsoKGZpbGU6IFZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0PikgPT4gdW5kZWZpbmVkIHwgdm9pZCkgfCB1bmRlZmluZWR9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQpID0+IHVuZGVmaW5lZCB8IHZvaWR9IHJlamVjdFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjb25zdCByZWFsRmlsZSA9IHZmaWxlKGZpbGUpXG4gICAgICAvLyBBc3N1bWUgYFBhcnNlVHJlZWAgKHRoZSByZXN1bHQgb2YgdGhlIHBhcnNlcikgbWF0Y2hlcyBgSGVhZFRyZWVgICh0aGVcbiAgICAgIC8vIGlucHV0IG9mIHRoZSBmaXJzdCB0cmFuc2Zvcm0pLlxuICAgICAgY29uc3QgcGFyc2VUcmVlID1cbiAgICAgICAgLyoqIEB0eXBlIHtIZWFkVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBIZWFkVHJlZX0gKi8gKFxuICAgICAgICAgIC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKHNlbGYucGFyc2UocmVhbEZpbGUpKVxuICAgICAgICApXG5cbiAgICAgIHNlbGYucnVuKHBhcnNlVHJlZSwgcmVhbEZpbGUsIGZ1bmN0aW9uIChlcnJvciwgdHJlZSwgZmlsZSkge1xuICAgICAgICBpZiAoZXJyb3IgfHwgIXRyZWUgfHwgIWZpbGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVhbERvbmUoZXJyb3IpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBc3N1bWUgYFRhaWxUcmVlYCAodGhlIG91dHB1dCBvZiB0aGUgbGFzdCB0cmFuc2Zvcm0pIG1hdGNoZXNcbiAgICAgICAgLy8gYENvbXBpbGVUcmVlYCAodGhlIGlucHV0IG9mIHRoZSBjb21waWxlcikuXG4gICAgICAgIGNvbnN0IGNvbXBpbGVUcmVlID1cbiAgICAgICAgICAvKiogQHR5cGUge0NvbXBpbGVUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IENvbXBpbGVUcmVlfSAqLyAoXG4gICAgICAgICAgICAvKiogQHR5cGUge3Vua25vd259ICovICh0cmVlKVxuICAgICAgICAgIClcblxuICAgICAgICBjb25zdCBjb21waWxlUmVzdWx0ID0gc2VsZi5zdHJpbmdpZnkoY29tcGlsZVRyZWUsIGZpbGUpXG5cbiAgICAgICAgaWYgKGxvb2tzTGlrZUFWYWx1ZShjb21waWxlUmVzdWx0KSkge1xuICAgICAgICAgIGZpbGUudmFsdWUgPSBjb21waWxlUmVzdWx0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZS5yZXN1bHQgPSBjb21waWxlUmVzdWx0XG4gICAgICAgIH1cblxuICAgICAgICByZWFsRG9uZShlcnJvciwgLyoqIEB0eXBlIHtWRmlsZVdpdGhPdXRwdXQ8Q29tcGlsZVJlc3VsdD59ICovIChmaWxlKSlcbiAgICAgIH0pXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFcnJvciB8IHVuZGVmaW5lZH0gZXJyb3JcbiAgICAgICAqIEBwYXJhbSB7VkZpbGVXaXRoT3V0cHV0PENvbXBpbGVSZXN1bHQ+IHwgdW5kZWZpbmVkfSBbZmlsZV1cbiAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlYWxEb25lKGVycm9yLCBmaWxlKSB7XG4gICAgICAgIGlmIChlcnJvciB8fCAhZmlsZSkge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShmaWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydChkb25lLCAnYGRvbmVgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdCcpXG4gICAgICAgICAgZG9uZSh1bmRlZmluZWQsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZ2l2ZW4gZmlsZSBhcyBjb25maWd1cmVkIG9uIHRoZSBwcm9jZXNzb3IuXG4gICAqXG4gICAqIEFuIGVycm9yIGlzIHRocm93biBpZiBhc3luY2hyb25vdXMgdHJhbnNmb3JtcyBhcmUgY29uZmlndXJlZC5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHByb2Nlc3NTeW5jYCBmcmVlemVzIHRoZSBwcm9jZXNzb3IgaWYgbm90IGFscmVhZHkgKmZyb3plbiouXG4gICAqXG4gICAqID4gKipOb3RlKio6IGBwcm9jZXNzU3luY2AgcGVyZm9ybXMgdGhlIHBhcnNlLCBydW4sIGFuZCBzdHJpbmdpZnkgcGhhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXVxuICAgKiAgIEZpbGUgKG9wdGlvbmFsKTsgdHlwaWNhbGx5IGBzdHJpbmdgIG9yIGBWRmlsZWA7IGFueSB2YWx1ZSBhY2NlcHRlZCBhc1xuICAgKiAgIGB4YCBpbiBgbmV3IFZGaWxlKHgpYC5cbiAgICogQHJldHVybnMge1ZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0Pn1cbiAgICogICBUaGUgcHJvY2Vzc2VkIGZpbGUuXG4gICAqXG4gICAqICAgVGhlIHBhcnNlZCwgdHJhbnNmb3JtZWQsIGFuZCBjb21waWxlZCB2YWx1ZSBpcyBhdmFpbGFibGUgYXRcbiAgICogICBgZmlsZS52YWx1ZWAgKHNlZSBub3RlKS5cbiAgICpcbiAgICogICA+ICoqTm90ZSoqOiB1bmlmaWVkIHR5cGljYWxseSBjb21waWxlcyBieSBzZXJpYWxpemluZzogbW9zdFxuICAgKiAgID4gY29tcGlsZXJzIHJldHVybiBgc3RyaW5nYCAob3IgYFVpbnQ4QXJyYXlgKS5cbiAgICogICA+IFNvbWUgY29tcGlsZXJzLCBzdWNoIGFzIHRoZSBvbmUgY29uZmlndXJlZCB3aXRoXG4gICAqICAgPiBbYHJlaHlwZS1yZWFjdGBdW3JlaHlwZS1yZWFjdF0sIHJldHVybiBvdGhlciB2YWx1ZXMgKGluIHRoaXMgY2FzZSwgYVxuICAgKiAgID4gUmVhY3QgdHJlZSkuXG4gICAqICAgPiBJZiB5b3XigJlyZSB1c2luZyBhIGNvbXBpbGVyIHRoYXQgZG9lc27igJl0IHNlcmlhbGl6ZSwgZXhwZWN0IGRpZmZlcmVudFxuICAgKiAgID4gcmVzdWx0IHZhbHVlcy5cbiAgICogICA+XG4gICAqICAgPiBUbyByZWdpc3RlciBjdXN0b20gcmVzdWx0cyBpbiBUeXBlU2NyaXB0LCBhZGQgdGhlbSB0b1xuICAgKiAgID4ge0BsaW5rY29kZSBDb21waWxlUmVzdWx0TWFwfS5cbiAgICpcbiAgICogICBbcmVoeXBlLXJlYWN0XTogaHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdFxuICAgKi9cbiAgcHJvY2Vzc1N5bmMoZmlsZSkge1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICBsZXQgY29tcGxldGUgPSBmYWxzZVxuICAgIC8qKiBAdHlwZSB7VkZpbGVXaXRoT3V0cHV0PENvbXBpbGVSZXN1bHQ+IHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXN1bHRcblxuICAgIHRoaXMuZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3NTeW5jJywgdGhpcy5wYXJzZXIgfHwgdGhpcy5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3NTeW5jJywgdGhpcy5jb21waWxlciB8fCB0aGlzLkNvbXBpbGVyKVxuXG4gICAgdGhpcy5wcm9jZXNzKGZpbGUsIHJlYWxEb25lKVxuICAgIGFzc2VydERvbmUoJ3Byb2Nlc3NTeW5jJywgJ3Byb2Nlc3MnLCBjb21wbGV0ZSlcbiAgICBhc3NlcnQocmVzdWx0LCAnd2UgZWl0aGVyIGJhaWxlZCBvbiBhbiBlcnJvciBvciBoYXZlIGEgdHJlZScpXG5cbiAgICByZXR1cm4gcmVzdWx0XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvY2Vzc0NhbGxiYWNrPFZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0Pj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhbERvbmUoZXJyb3IsIGZpbGUpIHtcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZVxuICAgICAgYmFpbChlcnJvcilcbiAgICAgIHJlc3VsdCA9IGZpbGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVuICp0cmFuc2Zvcm1lcnMqIG9uIGEgc3ludGF4IHRyZWUuXG4gICAqXG4gICAqID4gKipOb3RlKio6IGBydW5gIGZyZWV6ZXMgdGhlIHByb2Nlc3NvciBpZiBub3QgYWxyZWFkeSAqZnJvemVuKi5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHJ1bmAgcGVyZm9ybXMgdGhlIHJ1biBwaGFzZSwgbm90IG90aGVyIHBoYXNlcy5cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7SGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogSGVhZFRyZWV9IHRyZWVcbiAgICogQHBhcmFtIHtSdW5DYWxsYmFjazxUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZT59IGRvbmVcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7SGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogSGVhZFRyZWV9IHRyZWVcbiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBmaWxlXG4gICAqIEBwYXJhbSB7UnVuQ2FsbGJhY2s8VGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWU+fSBkb25lXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0hlYWRUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IEhlYWRUcmVlfSB0cmVlXG4gICAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gW2ZpbGVdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlPn1cbiAgICpcbiAgICogQHBhcmFtIHtIZWFkVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBIZWFkVHJlZX0gdHJlZVxuICAgKiAgIFRyZWUgdG8gdHJhbnNmb3JtIGFuZCBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyhcbiAgICogICBSdW5DYWxsYmFjazxUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZT4gfFxuICAgKiAgIENvbXBhdGlibGVcbiAgICogKX0gW2ZpbGVdXG4gICAqICAgRmlsZSBhc3NvY2lhdGVkIHdpdGggYG5vZGVgIChvcHRpb25hbCk7IGFueSB2YWx1ZSBhY2NlcHRlZCBhcyBgeGAgaW5cbiAgICogICBgbmV3IFZGaWxlKHgpYC5cbiAgICogQHBhcmFtIHtSdW5DYWxsYmFjazxUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZT59IFtkb25lXVxuICAgKiAgIENhbGxiYWNrIChvcHRpb25hbCkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlPiB8IHVuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nIGlmIGBkb25lYCBpcyBnaXZlbi5cbiAgICogICBPdGhlcndpc2UsIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIGEgZmF0YWwgZXJyb3Igb3IgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgICogICB0cmFuc2Zvcm1lZCB0cmVlLlxuICAgKi9cbiAgcnVuKHRyZWUsIGZpbGUsIGRvbmUpIHtcbiAgICBhc3NlcnROb2RlKHRyZWUpXG4gICAgdGhpcy5mcmVlemUoKVxuXG4gICAgY29uc3QgdHJhbnNmb3JtZXJzID0gdGhpcy50cmFuc2Zvcm1lcnNcblxuICAgIGlmICghZG9uZSAmJiB0eXBlb2YgZmlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9uZSA9IGZpbGVcbiAgICAgIGZpbGUgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZSA/IGV4ZWN1dG9yKHVuZGVmaW5lZCwgZG9uZSkgOiBuZXcgUHJvbWlzZShleGVjdXRvcilcblxuICAgIC8vIE5vdGU6IGB2b2lkYHMgbmVlZGVkIGZvciBUUy5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyhcbiAgICAgKiAgICgodHJlZTogVGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWUpID0+IHVuZGVmaW5lZCB8IHZvaWQpIHxcbiAgICAgKiAgIHVuZGVmaW5lZFxuICAgICAqICl9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcjogRXJyb3IpID0+IHVuZGVmaW5lZCB8IHZvaWR9IHJlamVjdFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiBmaWxlICE9PSAnZnVuY3Rpb24nLFxuICAgICAgICAnYGZpbGVgIGNhbuKAmXQgYmUgYSBgZG9uZWAgYW55bW9yZSwgd2UgY2hlY2tlZCdcbiAgICAgIClcbiAgICAgIGNvbnN0IHJlYWxGaWxlID0gdmZpbGUoZmlsZSlcbiAgICAgIHRyYW5zZm9ybWVycy5ydW4odHJlZSwgcmVhbEZpbGUsIHJlYWxEb25lKVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RXJyb3IgfCB1bmRlZmluZWR9IGVycm9yXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG91dHB1dFRyZWVcbiAgICAgICAqIEBwYXJhbSB7VkZpbGV9IGZpbGVcbiAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlYWxEb25lKGVycm9yLCBvdXRwdXRUcmVlLCBmaWxlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ1RyZWUgPVxuICAgICAgICAgIC8qKiBAdHlwZSB7VGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWV9ICovIChcbiAgICAgICAgICAgIG91dHB1dFRyZWUgfHwgdHJlZVxuICAgICAgICAgIClcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0aW5nVHJlZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoZG9uZSwgJ2Bkb25lYCBpcyBkZWZpbmVkIGlmIGByZXNvbHZlYCBpcyBub3QnKVxuICAgICAgICAgIGRvbmUodW5kZWZpbmVkLCByZXN1bHRpbmdUcmVlLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biAqdHJhbnNmb3JtZXJzKiBvbiBhIHN5bnRheCB0cmVlLlxuICAgKlxuICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgYXN5bmNocm9ub3VzIHRyYW5zZm9ybXMgYXJlIGNvbmZpZ3VyZWQuXG4gICAqXG4gICAqID4gKipOb3RlKio6IGBydW5TeW5jYCBmcmVlemVzIHRoZSBwcm9jZXNzb3IgaWYgbm90IGFscmVhZHkgKmZyb3plbiouXG4gICAqXG4gICAqID4gKipOb3RlKio6IGBydW5TeW5jYCBwZXJmb3JtcyB0aGUgcnVuIHBoYXNlLCBub3Qgb3RoZXIgcGhhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IEhlYWRUcmVlfSB0cmVlXG4gICAqICAgVHJlZSB0byB0cmFuc2Zvcm0gYW5kIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gW2ZpbGVdXG4gICAqICAgRmlsZSBhc3NvY2lhdGVkIHdpdGggYG5vZGVgIChvcHRpb25hbCk7IGFueSB2YWx1ZSBhY2NlcHRlZCBhcyBgeGAgaW5cbiAgICogICBgbmV3IFZGaWxlKHgpYC5cbiAgICogQHJldHVybnMge1RhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlfVxuICAgKiAgIFRyYW5zZm9ybWVkIHRyZWUuXG4gICAqL1xuICBydW5TeW5jKHRyZWUsIGZpbGUpIHtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgbGV0IGNvbXBsZXRlID0gZmFsc2VcbiAgICAvKiogQHR5cGUgeyhUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZSkgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IHJlc3VsdFxuXG4gICAgdGhpcy5ydW4odHJlZSwgZmlsZSwgcmVhbERvbmUpXG5cbiAgICBhc3NlcnREb25lKCdydW5TeW5jJywgJ3J1bicsIGNvbXBsZXRlKVxuICAgIGFzc2VydChyZXN1bHQsICd3ZSBlaXRoZXIgYmFpbGVkIG9uIGFuIGVycm9yIG9yIGhhdmUgYSB0cmVlJylcbiAgICByZXR1cm4gcmVzdWx0XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UnVuQ2FsbGJhY2s8VGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWU+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWxEb25lKGVycm9yLCB0cmVlKSB7XG4gICAgICBiYWlsKGVycm9yKVxuICAgICAgcmVzdWx0ID0gdHJlZVxuICAgICAgY29tcGxldGUgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYSBzeW50YXggdHJlZS5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHN0cmluZ2lmeWAgZnJlZXplcyB0aGUgcHJvY2Vzc29yIGlmIG5vdCBhbHJlYWR5ICpmcm96ZW4qLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiBgc3RyaW5naWZ5YCBwZXJmb3JtcyB0aGUgc3RyaW5naWZ5IHBoYXNlLCBub3QgdGhlIHJ1biBwaGFzZVxuICAgKiA+IG9yIG90aGVyIHBoYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21waWxlVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBDb21waWxlVHJlZX0gdHJlZVxuICAgKiAgIFRyZWUgdG8gY29tcGlsZS5cbiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBbZmlsZV1cbiAgICogICBGaWxlIGFzc29jaWF0ZWQgd2l0aCBgbm9kZWAgKG9wdGlvbmFsKTsgYW55IHZhbHVlIGFjY2VwdGVkIGFzIGB4YCBpblxuICAgKiAgIGBuZXcgVkZpbGUoeClgLlxuICAgKiBAcmV0dXJucyB7Q29tcGlsZVJlc3VsdCBleHRlbmRzIHVuZGVmaW5lZCA/IFZhbHVlIDogQ29tcGlsZVJlc3VsdH1cbiAgICogICBUZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmVlIChzZWUgbm90ZSkuXG4gICAqXG4gICAqICAgPiAqKk5vdGUqKjogdW5pZmllZCB0eXBpY2FsbHkgY29tcGlsZXMgYnkgc2VyaWFsaXppbmc6IG1vc3QgY29tcGlsZXJzXG4gICAqICAgPiByZXR1cm4gYHN0cmluZ2AgKG9yIGBVaW50OEFycmF5YCkuXG4gICAqICAgPiBTb21lIGNvbXBpbGVycywgc3VjaCBhcyB0aGUgb25lIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiAgID4gW2ByZWh5cGUtcmVhY3RgXVtyZWh5cGUtcmVhY3RdLCByZXR1cm4gb3RoZXIgdmFsdWVzIChpbiB0aGlzIGNhc2UsIGFcbiAgICogICA+IFJlYWN0IHRyZWUpLlxuICAgKiAgID4gSWYgeW914oCZcmUgdXNpbmcgYSBjb21waWxlciB0aGF0IGRvZXNu4oCZdCBzZXJpYWxpemUsIGV4cGVjdCBkaWZmZXJlbnRcbiAgICogICA+IHJlc3VsdCB2YWx1ZXMuXG4gICAqICAgPlxuICAgKiAgID4gVG8gcmVnaXN0ZXIgY3VzdG9tIHJlc3VsdHMgaW4gVHlwZVNjcmlwdCwgYWRkIHRoZW0gdG9cbiAgICogICA+IHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uXG4gICAqXG4gICAqICAgW3JlaHlwZS1yZWFjdF06IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3RcbiAgICovXG4gIHN0cmluZ2lmeSh0cmVlLCBmaWxlKSB7XG4gICAgdGhpcy5mcmVlemUoKVxuICAgIGNvbnN0IHJlYWxGaWxlID0gdmZpbGUoZmlsZSlcbiAgICBjb25zdCBjb21waWxlciA9IHRoaXMuY29tcGlsZXIgfHwgdGhpcy5Db21waWxlclxuICAgIGFzc2VydENvbXBpbGVyKCdzdHJpbmdpZnknLCBjb21waWxlcilcbiAgICBhc3NlcnROb2RlKHRyZWUpXG5cbiAgICByZXR1cm4gY29tcGlsZXIodHJlZSwgcmVhbEZpbGUpXG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBwcm9jZXNzb3IgdG8gdXNlIGEgcGx1Z2luLCBhIGxpc3Qgb2YgdXNhYmxlIHZhbHVlcywgb3IgYVxuICAgKiBwcmVzZXQuXG4gICAqXG4gICAqIElmIHRoZSBwcm9jZXNzb3IgaXMgYWxyZWFkeSB1c2luZyBhIHBsdWdpbiwgdGhlIHByZXZpb3VzIHBsdWdpblxuICAgKiBjb25maWd1cmF0aW9uIGlzIGNoYW5nZWQgYmFzZWQgb24gdGhlIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIGluLlxuICAgKiBJbiBvdGhlciB3b3JkcywgdGhlIHBsdWdpbiBpcyBub3QgYWRkZWQgYSBzZWNvbmQgdGltZS5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogYHVzZWAgY2Fubm90IGJlIGNhbGxlZCBvbiAqZnJvemVuKiBwcm9jZXNzb3JzLlxuICAgKiA+IENhbGwgdGhlIHByb2Nlc3NvciBmaXJzdCB0byBjcmVhdGUgYSBuZXcgdW5mcm96ZW4gcHJvY2Vzc29yLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIFRoZXJlIGFyZSBtYW55IHdheXMgdG8gcGFzcyBwbHVnaW5zIHRvIGAudXNlKClgLlxuICAgKiAgIFRoaXMgZXhhbXBsZSBnaXZlcyBhbiBvdmVydmlldzpcbiAgICpcbiAgICogICBgYGBqc1xuICAgKiAgIGltcG9ydCB7dW5pZmllZH0gZnJvbSAndW5pZmllZCdcbiAgICpcbiAgICogICB1bmlmaWVkKClcbiAgICogICAgIC8vIFBsdWdpbiB3aXRoIG9wdGlvbnM6XG4gICAqICAgICAudXNlKHBsdWdpbkEsIHt4OiB0cnVlLCB5OiB0cnVlfSlcbiAgICogICAgIC8vIFBhc3NpbmcgdGhlIHNhbWUgcGx1Z2luIGFnYWluIG1lcmdlcyBjb25maWd1cmF0aW9uICh0byBge3g6IHRydWUsIHk6IGZhbHNlLCB6OiB0cnVlfWApOlxuICAgKiAgICAgLnVzZShwbHVnaW5BLCB7eTogZmFsc2UsIHo6IHRydWV9KVxuICAgKiAgICAgLy8gUGx1Z2luczpcbiAgICogICAgIC51c2UoW3BsdWdpbkIsIHBsdWdpbkNdKVxuICAgKiAgICAgLy8gVHdvIHBsdWdpbnMsIHRoZSBzZWNvbmQgd2l0aCBvcHRpb25zOlxuICAgKiAgICAgLnVzZShbcGx1Z2luRCwgW3BsdWdpbkUsIHt9XV0pXG4gICAqICAgICAvLyBQcmVzZXQgd2l0aCBwbHVnaW5zIGFuZCBzZXR0aW5nczpcbiAgICogICAgIC51c2Uoe3BsdWdpbnM6IFtwbHVnaW5GLCBbcGx1Z2luRywge31dXSwgc2V0dGluZ3M6IHtwb3NpdGlvbjogZmFsc2V9fSlcbiAgICogICAgIC8vIFNldHRpbmdzIG9ubHk6XG4gICAqICAgICAudXNlKHtzZXR0aW5nczoge3Bvc2l0aW9uOiBmYWxzZX19KVxuICAgKiAgIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUge0FycmF5PHVua25vd24+fSBbUGFyYW1ldGVycz1bXV1cbiAgICogQHRlbXBsYXRlIHtOb2RlIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSBbSW5wdXQ9dW5kZWZpbmVkXVxuICAgKiBAdGVtcGxhdGUgW091dHB1dD1JbnB1dF1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7UHJlc2V0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByZXNldF1cbiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtQbHVnZ2FibGVMaXN0fSBsaXN0XG4gICAqIEByZXR1cm5zIHtQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0Pn1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7UGx1Z2luPFBhcmFtZXRlcnMsIElucHV0LCBPdXRwdXQ+fSBwbHVnaW5cbiAgICogQHBhcmFtIHsuLi4oUGFyYW1ldGVycyB8IFtib29sZWFuXSl9IHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge1VzZVBsdWdpbjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQsIElucHV0LCBPdXRwdXQ+fVxuICAgKlxuICAgKiBAcGFyYW0ge1BsdWdnYWJsZUxpc3QgfCBQbHVnaW4gfCBQcmVzZXQgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICAgKiAgIFVzYWJsZSB2YWx1ZS5cbiAgICogQHBhcmFtIHsuLi51bmtub3dufSBwYXJhbWV0ZXJzXG4gICAqICAgUGFyYW1ldGVycywgd2hlbiBhIHBsdWdpbiBpcyBnaXZlbiBhcyBhIHVzYWJsZSB2YWx1ZS5cbiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fVxuICAgKiAgIEN1cnJlbnQgcHJvY2Vzc29yLlxuICAgKi9cbiAgdXNlKHZhbHVlLCAuLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYXR0YWNoZXJzID0gdGhpcy5hdHRhY2hlcnNcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZVxuXG4gICAgYXNzZXJ0VW5mcm96ZW4oJ3VzZScsIHRoaXMuZnJvemVuKVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEVtcHR5LlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRQbHVnaW4odmFsdWUsIHBhcmFtZXRlcnMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYWRkTGlzdCh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFByZXNldCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCcgKyB2YWx1ZSArICdgJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQbHVnZ2FibGV9IHZhbHVlXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYWRkUGx1Z2luKHZhbHVlLCBbXSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBbcGx1Z2luLCAuLi5wYXJhbWV0ZXJzXSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge1BsdWdpblR1cGxlPEFycmF5PHVua25vd24+Pn0gKi8gKHZhbHVlKVxuICAgICAgICAgIGFkZFBsdWdpbihwbHVnaW4sIHBhcmFtZXRlcnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgJyArIHZhbHVlICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHJlc2V0fSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFByZXNldChyZXN1bHQpIHtcbiAgICAgIGlmICghKCdwbHVnaW5zJyBpbiByZXN1bHQpICYmICEoJ3NldHRpbmdzJyBpbiByZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgdXNhYmxlIHZhbHVlIGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBwcmVzZXQsIHdoaWNoIGlzIHByb2JhYmx5IGEgbWlzdGFrZTogcHJlc2V0cyB0eXBpY2FsbHkgY29tZSB3aXRoIGBwbHVnaW5zYCBhbmQgc29tZXRpbWVzIHdpdGggYHNldHRpbmdzYCwgYnV0IHRoaXMgaGFzIG5laXRoZXInXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdChyZXN1bHQucGx1Z2lucylcblxuICAgICAgaWYgKHJlc3VsdC5zZXR0aW5ncykge1xuICAgICAgICBuYW1lc3BhY2Uuc2V0dGluZ3MgPSBleHRlbmQodHJ1ZSwgbmFtZXNwYWNlLnNldHRpbmdzLCByZXN1bHQuc2V0dGluZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQbHVnZ2FibGVMaXN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcGx1Z2luc1xuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdChwbHVnaW5zKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAocGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRoaW5nID0gcGx1Z2luc1tpbmRleF1cbiAgICAgICAgICBhZGQodGhpbmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBwbHVnaW5zLCBub3QgYCcgKyBwbHVnaW5zICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5PHVua25vd24+fSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luLCBwYXJhbWV0ZXJzKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuICAgICAgbGV0IGVudHJ5SW5kZXggPSAtMVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGF0dGFjaGVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF0dGFjaGVyc1tpbmRleF1bMF0gPT09IHBsdWdpbikge1xuICAgICAgICAgIGVudHJ5SW5kZXggPSBpbmRleFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGF0dGFjaGVycy5wdXNoKFtwbHVnaW4sIC4uLnBhcmFtZXRlcnNdKVxuICAgICAgfVxuICAgICAgLy8gT25seSBzZXQgaWYgdGhlcmUgd2FzIGF0IGxlYXN0IGEgYHByaW1hcnlgIHZhbHVlLCBvdGhlcndpc2Ugd2XigJlkIGNoYW5nZVxuICAgICAgLy8gYGFyZ3VtZW50cy5sZW5ndGhgLlxuICAgICAgZWxzZSBpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBbcHJpbWFyeSwgLi4ucmVzdF0gPSBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcmltYXJ5ID0gYXR0YWNoZXJzW2VudHJ5SW5kZXhdWzFdXG4gICAgICAgIGlmIChpc1BsYWluT2JqKGN1cnJlbnRQcmltYXJ5KSAmJiBpc1BsYWluT2JqKHByaW1hcnkpKSB7XG4gICAgICAgICAgcHJpbWFyeSA9IGV4dGVuZCh0cnVlLCBjdXJyZW50UHJpbWFyeSwgcHJpbWFyeSlcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaGVyc1tlbnRyeUluZGV4XSA9IFtwbHVnaW4sIHByaW1hcnksIC4uLnJlc3RdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIE5vdGU6IHRoaXMgcmV0dXJucyBhICpjYWxsYWJsZSogaW5zdGFuY2UuXG4vLyBUaGF04oCZcyB3aHkgaXTigJlzIGRvY3VtZW50ZWQgYXMgYSBmdW5jdGlvbi5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHByb2Nlc3Nvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBUaGlzIGV4YW1wbGUgc2hvd3MgaG93IGEgbmV3IHByb2Nlc3NvciBjYW4gYmUgY3JlYXRlZCAoZnJvbSBgcmVtYXJrYCkgYW5kIGxpbmtlZFxuICogICB0byAqKnN0ZGluKiooNCkgYW5kICoqc3Rkb3V0KiooNCkuXG4gKlxuICogICBgYGBqc1xuICogICBpbXBvcnQgcHJvY2VzcyBmcm9tICdub2RlOnByb2Nlc3MnXG4gKiAgIGltcG9ydCBjb25jYXRTdHJlYW0gZnJvbSAnY29uY2F0LXN0cmVhbSdcbiAqICAgaW1wb3J0IHtyZW1hcmt9IGZyb20gJ3JlbWFyaydcbiAqXG4gKiAgIHByb2Nlc3Muc3RkaW4ucGlwZShcbiAqICAgICBjb25jYXRTdHJlYW0oZnVuY3Rpb24gKGJ1Zikge1xuICogICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoU3RyaW5nKHJlbWFyaygpLnByb2Nlc3NTeW5jKGJ1ZikpKVxuICogICAgIH0pXG4gKiAgIClcbiAqICAgYGBgXG4gKlxuICogQHJldHVybnNcbiAqICAgTmV3ICp1bmZyb3plbiogcHJvY2Vzc29yIChgcHJvY2Vzc29yYCkuXG4gKlxuICogICBUaGlzIHByb2Nlc3NvciBpcyBjb25maWd1cmVkIHRvIHdvcmsgdGhlIHNhbWUgYXMgaXRzIGFuY2VzdG9yLlxuICogICBXaGVuIHRoZSBkZXNjZW5kYW50IHByb2Nlc3NvciBpcyBjb25maWd1cmVkIGluIHRoZSBmdXR1cmUgaXQgZG9lcyBub3RcbiAqICAgYWZmZWN0IHRoZSBhbmNlc3RyYWwgcHJvY2Vzc29yLlxuICovXG5leHBvcnQgY29uc3QgdW5pZmllZCA9IG5ldyBQcm9jZXNzb3IoKS5mcmVlemUoKVxuXG4vKipcbiAqIEFzc2VydCBhIHBhcnNlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIFBhcnNlcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGFyc2VyKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgcGFyc2VyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYSBjb21waWxlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIENvbXBpbGVyfVxuICovXG5mdW5jdGlvbiBhc3NlcnRDb21waWxlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGAnICsgbmFtZSArICdgIHdpdGhvdXQgYGNvbXBpbGVyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHByb2Nlc3NvciBpcyBub3QgZnJvemVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3Vua25vd259IGZyb3plblxuICogQHJldHVybnMge2Fzc2VydHMgZnJvemVuIGlzIGZhbHNlfVxuICovXG5mdW5jdGlvbiBhc3NlcnRVbmZyb3plbihuYW1lLCBmcm96ZW4pIHtcbiAgaWYgKGZyb3plbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2FsbCBgJyArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAnYCBvbiBhIGZyb3plbiBwcm9jZXNzb3IuXFxuQ3JlYXRlIGEgbmV3IHByb2Nlc3NvciBmaXJzdCwgYnkgY2FsbGluZyBpdDogdXNlIGBwcm9jZXNzb3IoKWAgaW5zdGVhZCBvZiBgcHJvY2Vzc29yYC4nXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IGBub2RlYCBpcyBhIHVuaXN0IG5vZGUuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBub2RlXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBub2RlIGlzIE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICAvLyBgaXNQbGFpbk9iamAgdW5mb3J0dW5hdGVseSB1c2VzIGBhbnlgIGluc3RlYWQgb2YgYHVua25vd25gLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgaWYgKCFpc1BsYWluT2JqKG5vZGUpIHx8IHR5cGVvZiBub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbm9kZSwgZ290IGAnICsgbm9kZSArICdgJylcbiAgICAvLyBGaW5lLlxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYGNvbXBsZXRlYCBpcyBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3luY05hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gY29tcGxldGVcbiAqIEByZXR1cm5zIHthc3NlcnRzIGNvbXBsZXRlIGlzIHRydWV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydERvbmUobmFtZSwgYXN5bmNOYW1lLCBjb21wbGV0ZSkge1xuICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2AnICsgbmFtZSArICdgIGZpbmlzaGVkIGFzeW5jLiBVc2UgYCcgKyBhc3luY05hbWUgKyAnYCBpbnN0ZWFkJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gW3ZhbHVlXVxuICogQHJldHVybnMge1ZGaWxlfVxuICovXG5mdW5jdGlvbiB2ZmlsZSh2YWx1ZSkge1xuICByZXR1cm4gbG9va3NMaWtlQVZGaWxlKHZhbHVlKSA/IHZhbHVlIDogbmV3IFZGaWxlKHZhbHVlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZhbHVlIGlzIFZGaWxlfVxuICovXG5mdW5jdGlvbiBsb29rc0xpa2VBVkZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgJ21lc3NhZ2VzJyBpbiB2YWx1ZVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgVmFsdWV9XG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUFWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpXG59XG5cbi8qKlxuICogQXNzZXJ0IGB2YWx1ZWAgaXMgYW4gYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqICAgdGhpbmcuXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgVWludDhBcnJheX1cbiAqICAgV2hldGhlciBgdmFsdWVgIGlzIGFuIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAnYnl0ZUxlbmd0aCcgaW4gdmFsdWUgJiZcbiAgICAgICdieXRlT2Zmc2V0JyBpbiB2YWx1ZVxuICApXG59XG4iXSwibmFtZXMiOlsiYmFpbCIsImV4dGVuZCIsIm9rIiwiYXNzZXJ0IiwiaXNQbGFpbk9iaiIsInRyb3VnaCIsIlZGaWxlIiwiQ2FsbGFibGVJbnN0YW5jZSIsIm93biIsImhhc093blByb3BlcnR5IiwiUHJvY2Vzc29yIiwiY29uc3RydWN0b3IiLCJDb21waWxlciIsInVuZGVmaW5lZCIsIlBhcnNlciIsImF0dGFjaGVycyIsImNvbXBpbGVyIiwiZnJlZXplSW5kZXgiLCJmcm96ZW4iLCJuYW1lc3BhY2UiLCJwYXJzZXIiLCJ0cmFuc2Zvcm1lcnMiLCJjb3B5IiwiZGVzdGluYXRpb24iLCJpbmRleCIsImxlbmd0aCIsImF0dGFjaGVyIiwidXNlIiwiZGF0YSIsImtleSIsInZhbHVlIiwiYXJndW1lbnRzIiwiYXNzZXJ0VW5mcm96ZW4iLCJjYWxsIiwiZnJlZXplIiwic2VsZiIsIm9wdGlvbnMiLCJ0cmFuc2Zvcm1lciIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwicGFyc2UiLCJmaWxlIiwicmVhbEZpbGUiLCJ2ZmlsZSIsImFzc2VydFBhcnNlciIsIlN0cmluZyIsInByb2Nlc3MiLCJkb25lIiwiYXNzZXJ0Q29tcGlsZXIiLCJleGVjdXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicGFyc2VUcmVlIiwicnVuIiwiZXJyb3IiLCJ0cmVlIiwicmVhbERvbmUiLCJjb21waWxlVHJlZSIsImNvbXBpbGVSZXN1bHQiLCJzdHJpbmdpZnkiLCJsb29rc0xpa2VBVmFsdWUiLCJyZXN1bHQiLCJwcm9jZXNzU3luYyIsImNvbXBsZXRlIiwiYXNzZXJ0RG9uZSIsImFzc2VydE5vZGUiLCJvdXRwdXRUcmVlIiwicmVzdWx0aW5nVHJlZSIsInJ1blN5bmMiLCJwYXJhbWV0ZXJzIiwiYWRkUGx1Z2luIiwiQXJyYXkiLCJpc0FycmF5IiwiYWRkTGlzdCIsImFkZFByZXNldCIsIlR5cGVFcnJvciIsImFkZCIsInBsdWdpbiIsIkVycm9yIiwicGx1Z2lucyIsInNldHRpbmdzIiwidGhpbmciLCJlbnRyeUluZGV4IiwicHVzaCIsInByaW1hcnkiLCJyZXN0IiwiY3VycmVudFByaW1hcnkiLCJ1bmlmaWVkIiwibmFtZSIsIm5vZGUiLCJ0eXBlIiwiYXN5bmNOYW1lIiwibG9va3NMaWtlQVZGaWxlIiwiQm9vbGVhbiIsImlzVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/node_modules/unified/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rehype-pretty-code/node_modules/unist-util-visit/lib/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/node_modules/unist-util-visit/lib/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTINUE: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),\n/* harmony export */   EXIT: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.EXIT),\n/* harmony export */   SKIP: () => (/* reexport safe */ unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.SKIP),\n/* harmony export */   visit: () => (/* binding */ visit)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit-parents */ \"(rsc)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */ /**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */ // To do: use types from `unist-util-visit-parents` when its released.\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */ /**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */ /**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */ /**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */ /**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */ /**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */ /**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */ /**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */ /**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */ /**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */ /**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */ /**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */ /**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */ \n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */ function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n    /** @type {boolean | null | undefined} */ let reverse;\n    /** @type {Test} */ let test;\n    /** @type {Visitor} */ let visitor;\n    if (typeof testOrVisitor === \"function\" && typeof visitorOrReverse !== \"function\") {\n        test = undefined;\n        visitor = testOrVisitor;\n        reverse = visitorOrReverse;\n    } else {\n        // @ts-expect-error: assume the overload with test was given.\n        test = testOrVisitor;\n        // @ts-expect-error: assume the overload with test was given.\n        visitor = visitorOrReverse;\n        reverse = maybeReverse;\n    }\n    (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__.visitParents)(tree, test, overload, reverse);\n    /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */ function overload(node, parents) {\n        const parent = parents[parents.length - 1];\n        const index = parent ? parent.children.indexOf(node) : undefined;\n        return visitor(node, index, parent);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7Ozs7OztDQU9DLEdBRUQsdUVBQXVFO0FBRXZFOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FFRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEOzs7Q0FHQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQ0MsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUVEOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBRW9EO0FBRVE7QUFFN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4Q0MsR0FDTSxTQUFTSSxNQUFNQyxJQUFJLEVBQUVDLGFBQWEsRUFBRUMsZ0JBQWdCLEVBQUVDLFlBQVk7SUFDdkUsdUNBQXVDLEdBQ3ZDLElBQUlDO0lBQ0osaUJBQWlCLEdBQ2pCLElBQUlDO0lBQ0osb0JBQW9CLEdBQ3BCLElBQUlDO0lBRUosSUFDRSxPQUFPTCxrQkFBa0IsY0FDekIsT0FBT0MscUJBQXFCLFlBQzVCO1FBQ0FHLE9BQU9FO1FBQ1BELFVBQVVMO1FBQ1ZHLFVBQVVGO0lBQ1osT0FBTztRQUNMLDZEQUE2RDtRQUM3REcsT0FBT0o7UUFDUCw2REFBNkQ7UUFDN0RLLFVBQVVKO1FBQ1ZFLFVBQVVEO0lBQ1o7SUFFQVIsc0VBQVlBLENBQUNLLE1BQU1LLE1BQU1HLFVBQVVKO0lBRW5DOzs7R0FHQyxHQUNELFNBQVNJLFNBQVNDLElBQUksRUFBRUMsT0FBTztRQUM3QixNQUFNQyxTQUFTRCxPQUFPLENBQUNBLFFBQVFFLE1BQU0sR0FBRyxFQUFFO1FBQzFDLE1BQU1DLFFBQVFGLFNBQVNBLE9BQU9HLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDTixRQUFRRjtRQUN2RCxPQUFPRCxRQUFRRyxNQUFNSSxPQUFPRjtJQUM5QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvbm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtdmlzaXQvbGliL2luZGV4LmpzP2YzYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IFVuaXN0Tm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFVuaXN0UGFyZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnKS5WaXNpdG9yUmVzdWx0fSBWaXNpdG9yUmVzdWx0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXhjbHVkZTxpbXBvcnQoJ3VuaXN0LXV0aWwtaXMnKS5UZXN0LCB1bmRlZmluZWQ+IHwgdW5kZWZpbmVkfSBUZXN0XG4gKiAgIFRlc3QgZnJvbSBgdW5pc3QtdXRpbC1pc2AuXG4gKlxuICogICBOb3RlOiB3ZSBoYXZlIHJlbW92ZSBhbmQgYWRkIGB1bmRlZmluZWRgLCBiZWNhdXNlIG90aGVyd2lzZSB3aGVuIGdlbmVyYXRpbmdcbiAqICAgYXV0b21hdGljIGAuZC50c2AgZmlsZXMsIFRTIHRyaWVzIHRvIGZsYXR0ZW4gcGF0aHMgZnJvbSBhIGxvY2FsIHBlcnNwZWN0aXZlLFxuICogICB3aGljaCBkb2VzbuKAmXQgd29yayB3aGVuIHB1Ymxpc2hpbmcgb24gbnBtLlxuICovXG5cbi8vIFRvIGRvOiB1c2UgdHlwZXMgZnJvbSBgdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzYCB3aGVuIGl04oCZcyByZWxlYXNlZC5cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBGbiBleHRlbmRzICh2YWx1ZTogYW55KSA9PiB2YWx1ZSBpcyBpbmZlciBUaGluZ1xuICogICA/IFRoaW5nXG4gKiAgIDogRmFsbGJhY2tcbiAqICl9IFByZWRpY2F0ZVxuICogICBHZXQgdGhlIHZhbHVlIG9mIGEgdHlwZSBndWFyZCBgRm5gLlxuICogQHRlbXBsYXRlIEZuXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgZnVuY3Rpb24gdGhhdCBpcyBhIHR5cGUgZ3VhcmQgKHN1Y2ggYXMgYCh4KTogeCBpcyBZYCkuXG4gKiBAdGVtcGxhdGUgRmFsbGJhY2tcbiAqICAgVmFsdWUgdG8geWllbGQgaWYgYEZuYCBpcyBub3QgYSB0eXBlIGd1YXJkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQ2hlY2sgZXh0ZW5kcyBudWxsIHwgdW5kZWZpbmVkIC8vIE5vIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBWYWx1ZSBleHRlbmRzIHt0eXBlOiBDaGVja30gLy8gU3RyaW5nICh0eXBlKSB0ZXN0LlxuICogICA/IFZhbHVlXG4gKiAgIDogVmFsdWUgZXh0ZW5kcyBDaGVjayAvLyBQYXJ0aWFsIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBDaGVjayBleHRlbmRzIEZ1bmN0aW9uIC8vIEZ1bmN0aW9uIHRlc3QuXG4gKiAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT4gZXh0ZW5kcyBWYWx1ZVxuICogICAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT5cbiAqICAgICA6IG5ldmVyXG4gKiAgIDogbmV2ZXIgLy8gU29tZSBvdGhlciB0ZXN0P1xuICogKX0gTWF0Y2hlc09uZVxuICogICBDaGVjayB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIGEgcHJpbWl0aXZlIGNoZWNrIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSBWYWx1ZVxuICogICBWYWx1ZTsgdHlwaWNhbGx5IHVuaXN0IGBOb2RlYC5cbiAqIEB0ZW1wbGF0ZSBDaGVja1xuICogICBWYWx1ZTsgdHlwaWNhbGx5IGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QsIGJ1dCBub3QgYXJyYXlzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQ2hlY2sgZXh0ZW5kcyBBcnJheTxhbnk+XG4gKiAgID8gTWF0Y2hlc09uZTxWYWx1ZSwgQ2hlY2tba2V5b2YgQ2hlY2tdPlxuICogICA6IE1hdGNoZXNPbmU8VmFsdWUsIENoZWNrPlxuICogKX0gTWF0Y2hlc1xuICogICBDaGVjayB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIGEgY2hlY2sgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICogQHRlbXBsYXRlIFZhbHVlXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgdW5pc3QgYE5vZGVgLlxuICogQHRlbXBsYXRlIENoZWNrXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHswIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTB9IFVpbnRcbiAqICAgTnVtYmVyOyBjYXBwZWQgcmVhc29uYWJseS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJIGV4dGVuZHMgMCA/IDEgOiBJIGV4dGVuZHMgMSA/IDIgOiBJIGV4dGVuZHMgMiA/IDMgOiBJIGV4dGVuZHMgMyA/IDQgOiBJIGV4dGVuZHMgNCA/IDUgOiBJIGV4dGVuZHMgNSA/IDYgOiBJIGV4dGVuZHMgNiA/IDcgOiBJIGV4dGVuZHMgNyA/IDggOiBJIGV4dGVuZHMgOCA/IDkgOiAxMH0gSW5jcmVtZW50XG4gKiAgIEluY3JlbWVudCBhIG51bWJlciBpbiB0aGUgdHlwZSBzeXN0ZW0uXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtJPTBdXG4gKiAgIEluZGV4LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgTm9kZSBleHRlbmRzIFVuaXN0UGFyZW50XG4gKiAgID8gTm9kZSBleHRlbmRzIHtjaGlsZHJlbjogQXJyYXk8aW5mZXIgQ2hpbGRyZW4+fVxuICogICAgID8gQ2hpbGQgZXh0ZW5kcyBDaGlsZHJlbiA/IE5vZGUgOiBuZXZlclxuICogICAgIDogbmV2ZXJcbiAqICAgOiBuZXZlclxuICogKX0gSW50ZXJuYWxQYXJlbnRcbiAqICAgQ29sbGVjdCBub2RlcyB0aGF0IGNhbiBiZSBwYXJlbnRzIG9mIGBDaGlsZGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gTm9kZVxuICogICBBbGwgbm9kZSB0eXBlcyBpbiBhIHRyZWUuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gQ2hpbGRcbiAqICAgTm9kZSB0byBzZWFyY2ggZm9yLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0ludGVybmFsUGFyZW50PEluY2x1c2l2ZURlc2NlbmRhbnQ8VHJlZT4sIENoaWxkPn0gUGFyZW50XG4gKiAgIENvbGxlY3Qgbm9kZXMgaW4gYFRyZWVgIHRoYXQgY2FuIGJlIHBhcmVudHMgb2YgYENoaWxkYC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBUcmVlXG4gKiAgIEFsbCBub2RlIHR5cGVzIGluIGEgdHJlZS5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBDaGlsZFxuICogICBOb2RlIHRvIHNlYXJjaCBmb3IuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBEZXB0aCBleHRlbmRzIE1heFxuICogICA/IG5ldmVyXG4gKiAgIDpcbiAqICAgICB8IEludGVybmFsUGFyZW50PE5vZGUsIENoaWxkPlxuICogICAgIHwgSW50ZXJuYWxBbmNlc3RvcjxOb2RlLCBJbnRlcm5hbFBhcmVudDxOb2RlLCBDaGlsZD4sIE1heCwgSW5jcmVtZW50PERlcHRoPj5cbiAqICl9IEludGVybmFsQW5jZXN0b3JcbiAqICAgQ29sbGVjdCBub2RlcyBpbiBgVHJlZWAgdGhhdCBjYW4gYmUgYW5jZXN0b3JzIG9mIGBDaGlsZGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gTm9kZVxuICogICBBbGwgbm9kZSB0eXBlcyBpbiBhIHRyZWUuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gQ2hpbGRcbiAqICAgTm9kZSB0byBzZWFyY2ggZm9yLlxuICogQHRlbXBsYXRlIHtVaW50fSBbTWF4PTEwXVxuICogICBNYXg7IHNlYXJjaGVzIHVwIHRvIHRoaXMgZGVwdGguXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtEZXB0aD0wXVxuICogICBDdXJyZW50IGRlcHRoLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgVHJlZSBleHRlbmRzIFVuaXN0UGFyZW50XG4gKiAgICAgPyBEZXB0aCBleHRlbmRzIE1heFxuICogICAgICAgPyBUcmVlXG4gKiAgICAgICA6IFRyZWUgfCBJbmNsdXNpdmVEZXNjZW5kYW50PFRyZWVbJ2NoaWxkcmVuJ11bbnVtYmVyXSwgTWF4LCBJbmNyZW1lbnQ8RGVwdGg+PlxuICogICAgIDogVHJlZVxuICogKX0gSW5jbHVzaXZlRGVzY2VuZGFudFxuICogICBDb2xsZWN0IGFsbCAoaW5jbHVzaXZlKSBkZXNjZW5kYW50cyBvZiBgVHJlZWAuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBmYXN0ZXN0IHdheSB0b1xuICogICA+IHJlY3Vyc2Ugd2l0aG91dCBhY3R1YWxseSBydW5uaW5nIGludG8gYW4gaW5maW5pdGUgbG9vcCwgd2hpY2ggdGhlXG4gKiAgID4gcHJldmlvdXMgdmVyc2lvbiBkaWQuXG4gKiAgID5cbiAqICAgPiBQcmFjdGljYWxseSwgYSBtYXggb2YgYDJgIGlzIHR5cGljYWxseSBlbm91Z2ggYXNzdW1pbmcgYSBgUm9vdGAgaXNcbiAqICAgPiBwYXNzZWQsIGJ1dCBpdCBkb2VzbuKAmXQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqICAgPiBJdCBnZXRzIGhpZ2hlciB3aXRoIGBMaXN0ID4gTGlzdEl0ZW0gPiBUYWJsZSA+IFRhYmxlUm93ID4gVGFibGVDZWxsYC5cbiAqICAgPiBVc2luZyB1cCB0byBgMTBgIGRvZXNu4oCZdCBodXJ0IG9yIGhlbHAgZWl0aGVyLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IFRyZWVcbiAqICAgVHJlZSB0eXBlLlxuICogQHRlbXBsYXRlIHtVaW50fSBbTWF4PTEwXVxuICogICBNYXg7IHNlYXJjaGVzIHVwIHRvIHRoaXMgZGVwdGguXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtEZXB0aD0wXVxuICogICBDdXJyZW50IGRlcHRoLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFZpc2l0b3JcbiAqICAgSGFuZGxlIGEgbm9kZSAobWF0Y2hpbmcgYHRlc3RgLCBpZiBnaXZlbikuXG4gKlxuICogICBWaXNpdG9ycyBhcmUgZnJlZSB0byB0cmFuc2Zvcm0gYG5vZGVgLlxuICogICBUaGV5IGNhbiBhbHNvIHRyYW5zZm9ybSBgcGFyZW50YC5cbiAqXG4gKiAgIFJlcGxhY2luZyBgbm9kZWAgaXRzZWxmLCBpZiBgU0tJUGAgaXMgbm90IHJldHVybmVkLCBzdGlsbCBjYXVzZXMgaXRzXG4gKiAgIGRlc2NlbmRhbnRzIHRvIGJlIHdhbGtlZCAod2hpY2ggaXMgYSBidWcpLlxuICpcbiAqICAgV2hlbiBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJldmlvdXMgc2libGluZ3Mgb2YgYG5vZGVgIChvciBuZXh0IHNpYmxpbmdzLCBpblxuICogICBjYXNlIG9mIHJldmVyc2UpLCB0aGUgYFZpc2l0b3JgIHNob3VsZCByZXR1cm4gYSBuZXcgYEluZGV4YCB0byBzcGVjaWZ5IHRoZVxuICogICBzaWJsaW5nIHRvIHRyYXZlcnNlIGFmdGVyIGBub2RlYCBpcyB0cmF2ZXJzZWQuXG4gKiAgIEFkZGluZyBvciByZW1vdmluZyBuZXh0IHNpYmxpbmdzIG9mIGBub2RlYCAob3IgcHJldmlvdXMgc2libGluZ3MsIGluIGNhc2VcbiAqICAgb2YgcmV2ZXJzZSkgaXMgaGFuZGxlZCBhcyBleHBlY3RlZCB3aXRob3V0IG5lZWRpbmcgdG8gcmV0dXJuIGEgbmV3IGBJbmRleGAuXG4gKlxuICogICBSZW1vdmluZyB0aGUgY2hpbGRyZW4gcHJvcGVydHkgb2YgYHBhcmVudGAgc3RpbGwgcmVzdWx0cyBpbiB0aGVtIGJlaW5nXG4gKiAgIHRyYXZlcnNlZC5cbiAqIEBwYXJhbSB7VmlzaXRlZH0gbm9kZVxuICogICBGb3VuZCBub2RlLlxuICogQHBhcmFtIHtWaXNpdGVkIGV4dGVuZHMgVW5pc3ROb2RlID8gbnVtYmVyIHwgdW5kZWZpbmVkIDogbmV2ZXJ9IGluZGV4XG4gKiAgIEluZGV4IG9mIGBub2RlYCBpbiBgcGFyZW50YC5cbiAqIEBwYXJhbSB7QW5jZXN0b3IgZXh0ZW5kcyBVbmlzdFBhcmVudCA/IEFuY2VzdG9yIHwgdW5kZWZpbmVkIDogbmV2ZXJ9IHBhcmVudFxuICogICBQYXJlbnQgb2YgYG5vZGVgLlxuICogQHJldHVybnMge1Zpc2l0b3JSZXN1bHR9XG4gKiAgIFdoYXQgdG8gZG8gbmV4dC5cbiAqXG4gKiAgIEFuIGBJbmRleGAgaXMgdHJlYXRlZCBhcyBhIHR1cGxlIG9mIGBbQ09OVElOVUUsIEluZGV4XWAuXG4gKiAgIEFuIGBBY3Rpb25gIGlzIHRyZWF0ZWQgYXMgYSB0dXBsZSBvZiBgW0FjdGlvbl1gLlxuICpcbiAqICAgUGFzc2luZyBhIHR1cGxlIGJhY2sgb25seSBtYWtlcyBzZW5zZSBpZiB0aGUgYEFjdGlvbmAgaXMgYFNLSVBgLlxuICogICBXaGVuIHRoZSBgQWN0aW9uYCBpcyBgRVhJVGAsIHRoYXQgYWN0aW9uIGNhbiBiZSByZXR1cm5lZC5cbiAqICAgV2hlbiB0aGUgYEFjdGlvbmAgaXMgYENPTlRJTlVFYCwgYEluZGV4YCBjYW4gYmUgcmV0dXJuZWQuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gW1Zpc2l0ZWQ9VW5pc3ROb2RlXVxuICogICBWaXNpdGVkIG5vZGUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3RQYXJlbnR9IFtBbmNlc3Rvcj1VbmlzdFBhcmVudF1cbiAqICAgQW5jZXN0b3IgdHlwZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtWaXNpdG9yPFZpc2l0ZWQsIFBhcmVudDxBbmNlc3RvciwgVmlzaXRlZD4+fSBCdWlsZFZpc2l0b3JGcm9tTWF0Y2hcbiAqICAgQnVpbGQgYSB0eXBlZCBgVmlzaXRvcmAgZnVuY3Rpb24gZnJvbSBhIG5vZGUgYW5kIGFsbCBwb3NzaWJsZSBwYXJlbnRzLlxuICpcbiAqICAgSXQgd2lsbCBpbmZlciB3aGljaCB2YWx1ZXMgYXJlIHBhc3NlZCBhcyBgbm9kZWAgYW5kIHdoaWNoIGFzIGBwYXJlbnRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IFZpc2l0ZWRcbiAqICAgTm9kZSB0eXBlLlxuICogQHRlbXBsYXRlIHtVbmlzdFBhcmVudH0gQW5jZXN0b3JcbiAqICAgUGFyZW50IHR5cGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBCdWlsZFZpc2l0b3JGcm9tTWF0Y2g8XG4gKiAgICAgTWF0Y2hlczxEZXNjZW5kYW50LCBDaGVjaz4sXG4gKiAgICAgRXh0cmFjdDxEZXNjZW5kYW50LCBVbmlzdFBhcmVudD5cbiAqICAgPlxuICogKX0gQnVpbGRWaXNpdG9yRnJvbURlc2NlbmRhbnRzXG4gKiAgIEJ1aWxkIGEgdHlwZWQgYFZpc2l0b3JgIGZ1bmN0aW9uIGZyb20gYSBsaXN0IG9mIGRlc2NlbmRhbnRzIGFuZCBhIHRlc3QuXG4gKlxuICogICBJdCB3aWxsIGluZmVyIHdoaWNoIHZhbHVlcyBhcmUgcGFzc2VkIGFzIGBub2RlYCBhbmQgd2hpY2ggYXMgYHBhcmVudGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gRGVzY2VuZGFudFxuICogICBOb2RlIHR5cGUuXG4gKiBAdGVtcGxhdGUge1Rlc3R9IENoZWNrXG4gKiAgIFRlc3QgdHlwZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIEJ1aWxkVmlzaXRvckZyb21EZXNjZW5kYW50czxcbiAqICAgICBJbmNsdXNpdmVEZXNjZW5kYW50PFRyZWU+LFxuICogICAgIENoZWNrXG4gKiAgID5cbiAqICl9IEJ1aWxkVmlzaXRvclxuICogICBCdWlsZCBhIHR5cGVkIGBWaXNpdG9yYCBmdW5jdGlvbiBmcm9tIGEgdHJlZSBhbmQgYSB0ZXN0LlxuICpcbiAqICAgSXQgd2lsbCBpbmZlciB3aGljaCB2YWx1ZXMgYXJlIHBhc3NlZCBhcyBgbm9kZWAgYW5kIHdoaWNoIGFzIGBwYXJlbnRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IFtUcmVlPVVuaXN0Tm9kZV1cbiAqICAgTm9kZSB0eXBlLlxuICogQHRlbXBsYXRlIHtUZXN0fSBbQ2hlY2s9VGVzdF1cbiAqICAgVGVzdCB0eXBlLlxuICovXG5cbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5cbmV4cG9ydCB7Q09OVElOVUUsIEVYSVQsIFNLSVB9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcblxuLyoqXG4gKiBWaXNpdCBub2Rlcy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBwZXJmb3JtcyAqZGVwdGgtZmlyc3QqICp0cmVlIHRyYXZlcnNhbCogaW4gKnByZW9yZGVyKlxuICogKCoqTkxSKiopIG9yIGlmIGByZXZlcnNlYCBpcyBnaXZlbiwgaW4gKnJldmVyc2UgcHJlb3JkZXIqICgqKk5STCoqKS5cbiAqXG4gKiBZb3UgY2FuIGNob29zZSBmb3Igd2hpY2ggbm9kZXMgYHZpc2l0b3JgIGlzIGNhbGxlZCBieSBwYXNzaW5nIGEgYHRlc3RgLlxuICogRm9yIGNvbXBsZXggdGVzdHMsIHlvdSBzaG91bGQgdGVzdCB5b3Vyc2VsZiBpbiBgdmlzaXRvcmAsIGFzIGl0IHdpbGwgYmVcbiAqIGZhc3RlciBhbmQgd2lsbCBoYXZlIGltcHJvdmVkIHR5cGUgaW5mb3JtYXRpb24uXG4gKlxuICogV2Fsa2luZyB0aGUgdHJlZSBpcyBhbiBpbnRlbnNpdmUgdGFzay5cbiAqIE1ha2UgdXNlIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIHRoZSB2aXNpdG9yIHdoZW4gcG9zc2libGUuXG4gKiBJbnN0ZWFkIG9mIHdhbGtpbmcgYSB0cmVlIG11bHRpcGxlIHRpbWVzLCB3YWxrIGl0IG9uY2UsIHVzZSBgdW5pc3QtdXRpbC1pc2BcbiAqIHRvIGNoZWNrIGlmIGEgbm9kZSBtYXRjaGVzLCBhbmQgdGhlbiBwZXJmb3JtIGRpZmZlcmVudCBvcGVyYXRpb25zLlxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIHRoZSB0cmVlLlxuICogU2VlIGBWaXNpdG9yYCBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtUcmVlfSB0cmVlXG4gKiBAcGFyYW0ge0NoZWNrfSBjaGVja1xuICogQHBhcmFtIHtCdWlsZFZpc2l0b3I8VHJlZSwgQ2hlY2s+fSB2aXNpdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcmV2ZXJzZV1cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1RyZWV9IHRyZWVcbiAqIEBwYXJhbSB7QnVpbGRWaXNpdG9yPFRyZWU+fSB2aXNpdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcmV2ZXJzZV1cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKlxuICogQHBhcmFtIHtVbmlzdE5vZGV9IHRyZWVcbiAqICAgVHJlZSB0byB0cmF2ZXJzZS5cbiAqIEBwYXJhbSB7VmlzaXRvciB8IFRlc3R9IHRlc3RPclZpc2l0b3JcbiAqICAgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdCAob3B0aW9uYWwsIG9taXQgdG8gcGFzcyBhIHZpc2l0b3IpLlxuICogQHBhcmFtIHtWaXNpdG9yIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFt2aXNpdG9yT3JSZXZlcnNlXVxuICogICBIYW5kbGUgZWFjaCBub2RlICh3aGVuIHRlc3QgaXMgb21pdHRlZCwgcGFzcyBgcmV2ZXJzZWApLlxuICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW21heWJlUmV2ZXJzZT1mYWxzZV1cbiAqICAgVHJhdmVyc2UgaW4gcmV2ZXJzZSBwcmVvcmRlciAoTlJMKSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHByZW9yZGVyIChOTFIpLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gVHJlZVxuICogICBOb2RlIHR5cGUuXG4gKiBAdGVtcGxhdGUge1Rlc3R9IENoZWNrXG4gKiAgIGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdCh0cmVlLCB0ZXN0T3JWaXNpdG9yLCB2aXNpdG9yT3JSZXZlcnNlLCBtYXliZVJldmVyc2UpIHtcbiAgLyoqIEB0eXBlIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHJldmVyc2VcbiAgLyoqIEB0eXBlIHtUZXN0fSAqL1xuICBsZXQgdGVzdFxuICAvKiogQHR5cGUge1Zpc2l0b3J9ICovXG4gIGxldCB2aXNpdG9yXG5cbiAgaWYgKFxuICAgIHR5cGVvZiB0ZXN0T3JWaXNpdG9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZpc2l0b3JPclJldmVyc2UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdGVzdCA9IHVuZGVmaW5lZFxuICAgIHZpc2l0b3IgPSB0ZXN0T3JWaXNpdG9yXG4gICAgcmV2ZXJzZSA9IHZpc2l0b3JPclJldmVyc2VcbiAgfSBlbHNlIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhc3N1bWUgdGhlIG92ZXJsb2FkIHdpdGggdGVzdCB3YXMgZ2l2ZW4uXG4gICAgdGVzdCA9IHRlc3RPclZpc2l0b3JcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhc3N1bWUgdGhlIG92ZXJsb2FkIHdpdGggdGVzdCB3YXMgZ2l2ZW4uXG4gICAgdmlzaXRvciA9IHZpc2l0b3JPclJldmVyc2VcbiAgICByZXZlcnNlID0gbWF5YmVSZXZlcnNlXG4gIH1cblxuICB2aXNpdFBhcmVudHModHJlZSwgdGVzdCwgb3ZlcmxvYWQsIHJldmVyc2UpXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VW5pc3ROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7QXJyYXk8VW5pc3RQYXJlbnQ+fSBwYXJlbnRzXG4gICAqL1xuICBmdW5jdGlvbiBvdmVybG9hZChub2RlLCBwYXJlbnRzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdXG4gICAgY29uc3QgaW5kZXggPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKSA6IHVuZGVmaW5lZFxuICAgIHJldHVybiB2aXNpdG9yKG5vZGUsIGluZGV4LCBwYXJlbnQpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ2aXNpdFBhcmVudHMiLCJDT05USU5VRSIsIkVYSVQiLCJTS0lQIiwidmlzaXQiLCJ0cmVlIiwidGVzdE9yVmlzaXRvciIsInZpc2l0b3JPclJldmVyc2UiLCJtYXliZVJldmVyc2UiLCJyZXZlcnNlIiwidGVzdCIsInZpc2l0b3IiLCJ1bmRlZmluZWQiLCJvdmVybG9hZCIsIm5vZGUiLCJwYXJlbnRzIiwicGFyZW50IiwibGVuZ3RoIiwiaW5kZXgiLCJjaGlsZHJlbiIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/node_modules/unist-util-visit/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/node_modules/vfile/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VFile: () => (/* binding */ VFile)\n/* harmony export */ });\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vfile-message */ \"(rsc)/./node_modules/vfile-message/lib/index.js\");\n/* harmony import */ var _minpath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! #minpath */ \"node:path\");\n/* harmony import */ var _minproc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! #minproc */ \"node:process\");\n/* harmony import */ var _minurl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! #minurl */ \"(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/minurl.shared.js\");\n/* harmony import */ var _minurl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! #minurl */ \"node:url\");\n/**\n * @import {Node, Point, Position} from 'unist'\n * @import {Options as MessageOptions} from 'vfile-message'\n * @import {Compatible, Data, Map, Options, Value} from 'vfile'\n */ /**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */ \n\n\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n */ const order = /** @type {const} */ [\n    \"history\",\n    \"path\",\n    \"basename\",\n    \"stem\",\n    \"extname\",\n    \"dirname\"\n];\nclass VFile {\n    /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Uint8Array`  `{value: options}`\n   * *   `URL`  `{path: options}`\n   * *   `VFile`  shallow copies its data over to the new file\n   * *   `object`  all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */ constructor(value){\n        /** @type {Options | VFile} */ let options;\n        if (!value) {\n            options = {};\n        } else if ((0,_minurl__WEBPACK_IMPORTED_MODULE_0__.isUrl)(value)) {\n            options = {\n                path: value\n            };\n        } else if (typeof value === \"string\" || isUint8Array(value)) {\n            options = {\n                value\n            };\n        } else {\n            options = value;\n        }\n        /* eslint-disable no-unused-expressions */ /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */ // Prevent calling `cwd` (which could be expensive) if its not needed;\n        // the empty string will be overridden in the next block.\n        this.cwd = \"cwd\" in options ? \"\" : _minproc__WEBPACK_IMPORTED_MODULE_1__.cwd();\n        /**\n     * Place to store custom info (default: `{}`).\n     *\n     * Its OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */ this.data = {};\n        /**\n     * List of file paths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */ this.history = [];\n        /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */ this.messages = [];\n        /**\n     * Raw value.\n     *\n     * @type {Value}\n     */ this.value;\n        // The below are non-standard, they are well-known.\n        // As in, used in several tools.\n        /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */ this.map;\n        /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */ this.result;\n        /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */ this.stored;\n        /* eslint-enable no-unused-expressions */ // Set path related properties in the correct order.\n        let index = -1;\n        while(++index < order.length){\n            const field = order[index];\n            // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n            // `vfile`s too.\n            if (field in options && options[field] !== undefined && options[field] !== null) {\n                // @ts-expect-error: TS doesnt understand basic reality.\n                this[field] = field === \"history\" ? [\n                    ...options[field]\n                ] : options[field];\n            }\n        }\n        /** @type {string} */ let field;\n        // Set non-path related properties.\n        for(field in options){\n            // @ts-expect-error: fine to set other things.\n            if (!order.includes(field)) {\n                // @ts-expect-error: fine to set other things.\n                this[field] = options[field];\n            }\n        }\n    }\n    /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   *\n   * @returns {string | undefined}\n   *   Basename.\n   */ get basename() {\n        return typeof this.path === \"string\" ? _minpath__WEBPACK_IMPORTED_MODULE_2__.basename(this.path) : undefined;\n    }\n    /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} basename\n   *   Basename.\n   * @returns {undefined}\n   *   Nothing.\n   */ set basename(basename) {\n        assertNonEmpty(basename, \"basename\");\n        assertPart(basename, \"basename\");\n        this.path = _minpath__WEBPACK_IMPORTED_MODULE_2__.join(this.dirname || \"\", basename);\n    }\n    /**\n   * Get the parent path (example: `'~'`).\n   *\n   * @returns {string | undefined}\n   *   Dirname.\n   */ get dirname() {\n        return typeof this.path === \"string\" ? _minpath__WEBPACK_IMPORTED_MODULE_2__.dirname(this.path) : undefined;\n    }\n    /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if theres no `path` yet.\n   *\n   * @param {string | undefined} dirname\n   *   Dirname.\n   * @returns {undefined}\n   *   Nothing.\n   */ set dirname(dirname) {\n        assertPath(this.basename, \"dirname\");\n        this.path = _minpath__WEBPACK_IMPORTED_MODULE_2__.join(dirname || \"\", this.basename);\n    }\n    /**\n   * Get the extname (including dot) (example: `'.js'`).\n   *\n   * @returns {string | undefined}\n   *   Extname.\n   */ get extname() {\n        return typeof this.path === \"string\" ? _minpath__WEBPACK_IMPORTED_MODULE_2__.extname(this.path) : undefined;\n    }\n    /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if theres no `path` yet.\n   *\n   * @param {string | undefined} extname\n   *   Extname.\n   * @returns {undefined}\n   *   Nothing.\n   */ set extname(extname) {\n        assertPart(extname, \"extname\");\n        assertPath(this.dirname, \"extname\");\n        if (extname) {\n            if (extname.codePointAt(0) !== 46 /* `.` */ ) {\n                throw new Error(\"`extname` must start with `.`\");\n            }\n            if (extname.includes(\".\", 1)) {\n                throw new Error(\"`extname` cannot contain multiple dots\");\n            }\n        }\n        this.path = _minpath__WEBPACK_IMPORTED_MODULE_2__.join(this.dirname, this.stem + (extname || \"\"));\n    }\n    /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   *   Path.\n   */ get path() {\n        return this.history[this.history.length - 1];\n    }\n    /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {URL | string} path\n   *   Path.\n   * @returns {undefined}\n   *   Nothing.\n   */ set path(path) {\n        if ((0,_minurl__WEBPACK_IMPORTED_MODULE_0__.isUrl)(path)) {\n            path = (0,_minurl__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)(path);\n        }\n        assertNonEmpty(path, \"path\");\n        if (this.path !== path) {\n            this.history.push(path);\n        }\n    }\n    /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * @returns {string | undefined}\n   *   Stem.\n   */ get stem() {\n        return typeof this.path === \"string\" ? _minpath__WEBPACK_IMPORTED_MODULE_2__.basename(this.path, this.extname) : undefined;\n    }\n    /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} stem\n   *   Stem.\n   * @returns {undefined}\n   *   Nothing.\n   */ set stem(stem) {\n        assertNonEmpty(stem, \"stem\");\n        assertPart(stem, \"stem\");\n        this.path = _minpath__WEBPACK_IMPORTED_MODULE_2__.join(this.dirname || \"\", stem + (this.extname || \"\"));\n    }\n    // Normal prototypal methods.\n    /**\n   * Create a fatal message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `true` (error; file not usable)\n   * and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * >  **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Never.\n   * @throws {VFileMessage}\n   *   Message.\n   */ fail(causeOrReason, optionsOrParentOrPlace, origin) {\n        // @ts-expect-error: the overloads are fine.\n        const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);\n        message.fatal = true;\n        throw message;\n    }\n    /**\n   * Create an info message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `undefined` (info; change\n   * likely not needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * >  **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */ info(causeOrReason, optionsOrParentOrPlace, origin) {\n        // @ts-expect-error: the overloads are fine.\n        const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);\n        message.fatal = undefined;\n        return message;\n    }\n    /**\n   * Create a message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `false` (warning; change may be\n   * needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * >  **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */ message(causeOrReason, optionsOrParentOrPlace, origin) {\n        const message = new vfile_message__WEBPACK_IMPORTED_MODULE_4__.VFileMessage(// @ts-expect-error: the overloads are fine.\n        causeOrReason, optionsOrParentOrPlace, origin);\n        if (this.path) {\n            message.name = this.path + \":\" + message.name;\n            message.file = this.path;\n        }\n        message.fatal = false;\n        this.messages.push(message);\n        return message;\n    }\n    /**\n   * Serialize the file.\n   *\n   * > **Note**: which encodings are supported depends on the engine.\n   * > For info on Node.js, see:\n   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\n   *\n   * @param {string | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when its a `Uint8Array`\n   *   (default: `'utf-8'`).\n   * @returns {string}\n   *   Serialized file.\n   */ toString(encoding) {\n        if (this.value === undefined) {\n            return \"\";\n        }\n        if (typeof this.value === \"string\") {\n            return this.value;\n        }\n        const decoder = new TextDecoder(encoding || undefined);\n        return decoder.decode(this.value);\n    }\n}\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {undefined}\n *   Nothing.\n */ function assertPart(part, name) {\n    if (part && part.includes(_minpath__WEBPACK_IMPORTED_MODULE_2__.sep)) {\n        throw new Error(\"`\" + name + \"` cannot be a path: did not expect `\" + _minpath__WEBPACK_IMPORTED_MODULE_2__.sep + \"`\");\n    }\n}\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */ function assertNonEmpty(part, name) {\n    if (!part) {\n        throw new Error(\"`\" + name + \"` cannot be empty\");\n    }\n}\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */ function assertPath(path, name) {\n    if (!path) {\n        throw new Error(\"Setting `\" + name + \"` requires `path` to be set too\");\n    }\n}\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */ function isUint8Array(value) {\n    return Boolean(value && typeof value === \"object\" && \"byteLength\" in value && \"byteOffset\" in value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL25vZGVfbW9kdWxlcy92ZmlsZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRXlDO0FBQ1Y7QUFDQTtBQUNRO0FBRXhDOzs7O0NBSUMsR0FDRCxNQUFNSyxRQUFRLGtCQUFrQixHQUFJO0lBQ2xDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sTUFBTUM7SUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJDLEdBQ0RDLFlBQVlDLEtBQUssQ0FBRTtRQUNqQiw0QkFBNEIsR0FDNUIsSUFBSUM7UUFFSixJQUFJLENBQUNELE9BQU87WUFDVkMsVUFBVSxDQUFDO1FBQ2IsT0FBTyxJQUFJTCw4Q0FBS0EsQ0FBQ0ksUUFBUTtZQUN2QkMsVUFBVTtnQkFBQ0MsTUFBTUY7WUFBSztRQUN4QixPQUFPLElBQUksT0FBT0EsVUFBVSxZQUFZRyxhQUFhSCxRQUFRO1lBQzNEQyxVQUFVO2dCQUFDRDtZQUFLO1FBQ2xCLE9BQU87WUFDTEMsVUFBVUQ7UUFDWjtRQUVBLHdDQUF3QyxHQUV4Qzs7OztLQUlDLEdBQ0QsdUVBQXVFO1FBQ3ZFLHlEQUF5RDtRQUN6RCxJQUFJLENBQUNJLEdBQUcsR0FBRyxTQUFTSCxVQUFVLEtBQUtQLHlDQUFXO1FBRTlDOzs7Ozs7O0tBT0MsR0FDRCxJQUFJLENBQUNXLElBQUksR0FBRyxDQUFDO1FBRWI7Ozs7OztLQU1DLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUVqQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtRQUVsQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDUCxLQUFLO1FBRVYscURBQXFEO1FBQ3JELGdDQUFnQztRQUNoQzs7Ozs7OztLQU9DLEdBQ0QsSUFBSSxDQUFDUSxHQUFHO1FBRVI7Ozs7Ozs7S0FPQyxHQUNELElBQUksQ0FBQ0MsTUFBTTtR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TSxNQUFNVSxPQUFPO0lBQy9CO0FBQ0Y7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTYixXQUFXbkIsSUFBSSxFQUFFZ0MsSUFBSTtJQUM1QixJQUFJLENBQUNoQyxNQUFNO1FBQ1QsTUFBTSxJQUFJc0IsTUFBTSxjQUFjVSxPQUFPO0lBQ3ZDO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBUy9CLGFBQWFILEtBQUs7SUFDekIsT0FBTzJDLFFBQ0wzQyxTQUNFLE9BQU9BLFVBQVUsWUFDakIsZ0JBQWdCQSxTQUNoQixnQkFBZ0JBO0FBRXRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy9yZWh5cGUtcHJldHR5LWNvZGUvbm9kZV9tb2R1bGVzL3ZmaWxlL2xpYi9pbmRleC5qcz9hYTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Tm9kZSwgUG9pbnQsIFBvc2l0aW9ufSBmcm9tICd1bmlzdCdcbiAqIEBpbXBvcnQge09wdGlvbnMgYXMgTWVzc2FnZU9wdGlvbnN9IGZyb20gJ3ZmaWxlLW1lc3NhZ2UnXG4gKiBAaW1wb3J0IHtDb21wYXRpYmxlLCBEYXRhLCBNYXAsIE9wdGlvbnMsIFZhbHVlfSBmcm9tICd2ZmlsZSdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3QgJiB7dHlwZTogc3RyaW5nLCBwb3NpdGlvbj86IFBvc2l0aW9uIHwgdW5kZWZpbmVkfX0gTm9kZUxpa2VcbiAqL1xuXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcbmltcG9ydCB7bWlucGF0aH0gZnJvbSAnI21pbnBhdGgnXG5pbXBvcnQge21pbnByb2N9IGZyb20gJyNtaW5wcm9jJ1xuaW1wb3J0IHt1cmxUb1BhdGgsIGlzVXJsfSBmcm9tICcjbWludXJsJ1xuXG4vKipcbiAqIE9yZGVyIG9mIHNldHRpbmcgKGxlYXN0IHNwZWNpZmljIHRvIG1vc3QpLCB3ZSBuZWVkIHRoaXMgYmVjYXVzZSBvdGhlcndpc2VcbiAqIGB7c3RlbTogJ2EnLCBwYXRoOiAnfi9iLmpzJ31gIHdvdWxkIHRocm93LCBhcyBhIHBhdGggaXMgbmVlZGVkIGJlZm9yZSBhXG4gKiBzdGVtIGNhbiBiZSBzZXQuXG4gKi9cbmNvbnN0IG9yZGVyID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2hpc3RvcnknLFxuICAncGF0aCcsXG4gICdiYXNlbmFtZScsXG4gICdzdGVtJyxcbiAgJ2V4dG5hbWUnLFxuICAnZGlybmFtZSdcbl0pXG5cbmV4cG9ydCBjbGFzcyBWRmlsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmlydHVhbCBmaWxlLlxuICAgKlxuICAgKiBgb3B0aW9uc2AgaXMgdHJlYXRlZCBhczpcbiAgICpcbiAgICogKiAgIGBzdHJpbmdgIG9yIGBVaW50OEFycmF5YCDigJQgYHt2YWx1ZTogb3B0aW9uc31gXG4gICAqICogICBgVVJMYCDigJQgYHtwYXRoOiBvcHRpb25zfWBcbiAgICogKiAgIGBWRmlsZWAg4oCUIHNoYWxsb3cgY29waWVzIGl0cyBkYXRhIG92ZXIgdG8gdGhlIG5ldyBmaWxlXG4gICAqICogICBgb2JqZWN0YCDigJQgYWxsIGZpZWxkcyBhcmUgc2hhbGxvdyBjb3BpZWQgb3ZlciB0byB0aGUgbmV3IGZpbGVcbiAgICpcbiAgICogUGF0aCByZWxhdGVkIGZpZWxkcyBhcmUgc2V0IGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgKGxlYXN0IHNwZWNpZmljIHRvXG4gICAqIG1vc3Qgc3BlY2lmaWMpOiBgaGlzdG9yeWAsIGBwYXRoYCwgYGJhc2VuYW1lYCwgYHN0ZW1gLCBgZXh0bmFtZWAsXG4gICAqIGBkaXJuYW1lYC5cbiAgICpcbiAgICogWW91IGNhbm5vdCBzZXQgYGRpcm5hbWVgIG9yIGBleHRuYW1lYCB3aXRob3V0IHNldHRpbmcgZWl0aGVyIGBoaXN0b3J5YCxcbiAgICogYHBhdGhgLCBgYmFzZW5hbWVgLCBvciBgc3RlbWAgdG9vLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCBudWxsIHwgdW5kZWZpbmVkfSBbdmFsdWVdXG4gICAqICAgRmlsZSB2YWx1ZS5cbiAgICogQHJldHVybnNcbiAgICogICBOZXcgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIC8qKiBAdHlwZSB7T3B0aW9ucyB8IFZGaWxlfSAqL1xuICAgIGxldCBvcHRpb25zXG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9IGVsc2UgaWYgKGlzVXJsKHZhbHVlKSkge1xuICAgICAgb3B0aW9ucyA9IHtwYXRoOiB2YWx1ZX1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgb3B0aW9ucyA9IHt2YWx1ZX1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHZhbHVlXG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIG9mIGBwYXRoYCAoZGVmYXVsdDogYHByb2Nlc3MuY3dkKClgIG9yIGAnLydgIGluIGJyb3dzZXJzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLy8gUHJldmVudCBjYWxsaW5nIGBjd2RgICh3aGljaCBjb3VsZCBiZSBleHBlbnNpdmUpIGlmIGl04oCZcyBub3QgbmVlZGVkO1xuICAgIC8vIHRoZSBlbXB0eSBzdHJpbmcgd2lsbCBiZSBvdmVycmlkZGVuIGluIHRoZSBuZXh0IGJsb2NrLlxuICAgIHRoaXMuY3dkID0gJ2N3ZCcgaW4gb3B0aW9ucyA/ICcnIDogbWlucHJvYy5jd2QoKVxuXG4gICAgLyoqXG4gICAgICogUGxhY2UgdG8gc3RvcmUgY3VzdG9tIGluZm8gKGRlZmF1bHQ6IGB7fWApLlxuICAgICAqXG4gICAgICogSXTigJlzIE9LIHRvIHN0b3JlIGN1c3RvbSBkYXRhIGRpcmVjdGx5IG9uIHRoZSBmaWxlIGJ1dCBtb3ZpbmcgaXQgdG9cbiAgICAgKiBgZGF0YWAgaXMgcmVjb21tZW5kZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RGF0YX1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7fVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBmaWxlIHBhdGhzIHRoZSBmaWxlIG1vdmVkIGJldHdlZW4uXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgaXMgdGhlIG9yaWdpbmFsIHBhdGggYW5kIHRoZSBsYXN0IGlzIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBtZXNzYWdlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8VkZpbGVNZXNzYWdlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2VzID0gW11cblxuICAgIC8qKlxuICAgICAqIFJhdyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtWYWx1ZX1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlXG5cbiAgICAvLyBUaGUgYmVsb3cgYXJlIG5vbi1zdGFuZGFyZCwgdGhleSBhcmUg4oCcd2VsbC1rbm93buKAnS5cbiAgICAvLyBBcyBpbiwgdXNlZCBpbiBzZXZlcmFsIHRvb2xzLlxuICAgIC8qKlxuICAgICAqIFNvdXJjZSBtYXAuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGUgaXMgZXF1aXZhbGVudCB0byB0aGUgYFJhd1NvdXJjZU1hcGAgdHlwZSBmcm9tIHRoZSBgc291cmNlLW1hcGBcbiAgICAgKiBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwIHwgbnVsbCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tLCBub24tc3RyaW5nLCBjb21waWxlZCwgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgdW5pZmllZCB0byBzdG9yZSBub24tc3RyaW5nIHJlc3VsdHMuXG4gICAgICogT25lIGV4YW1wbGUgaXMgd2hlbiB0dXJuaW5nIG1hcmtkb3duIGludG8gUmVhY3Qgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7dW5rbm93bn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhIGZpbGUgd2FzIHNhdmVkIHRvIGRpc2suXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgdmZpbGUgcmVwb3J0ZXJzLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zdG9yZWRcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuXG4gICAgLy8gU2V0IHBhdGggcmVsYXRlZCBwcm9wZXJ0aWVzIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG9yZGVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgZmllbGQgPSBvcmRlcltpbmRleF1cblxuICAgICAgLy8gTm90ZTogd2Ugc3BlY2lmaWNhbGx5IHVzZSBgaW5gIGluc3RlYWQgb2YgYGhhc093blByb3BlcnR5YCB0byBhY2NlcHRcbiAgICAgIC8vIGB2ZmlsZWBzIHRvby5cbiAgICAgIGlmIChcbiAgICAgICAgZmllbGQgaW4gb3B0aW9ucyAmJlxuICAgICAgICBvcHRpb25zW2ZpZWxkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9wdGlvbnNbZmllbGRdICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVFMgZG9lc27igJl0IHVuZGVyc3RhbmQgYmFzaWMgcmVhbGl0eS5cbiAgICAgICAgdGhpc1tmaWVsZF0gPSBmaWVsZCA9PT0gJ2hpc3RvcnknID8gWy4uLm9wdGlvbnNbZmllbGRdXSA6IG9wdGlvbnNbZmllbGRdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IGZpZWxkXG5cbiAgICAvLyBTZXQgbm9uLXBhdGggcmVsYXRlZCBwcm9wZXJ0aWVzLlxuICAgIGZvciAoZmllbGQgaW4gb3B0aW9ucykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogZmluZSB0byBzZXQgb3RoZXIgdGhpbmdzLlxuICAgICAgaWYgKCFvcmRlci5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogZmluZSB0byBzZXQgb3RoZXIgdGhpbmdzLlxuICAgICAgICB0aGlzW2ZpZWxkXSA9IG9wdGlvbnNbZmllbGRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFzZW5hbWUgKGluY2x1ZGluZyBleHRuYW1lKSAoZXhhbXBsZTogYCdpbmRleC5taW4uanMnYCkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAqICAgQmFzZW5hbWUuXG4gICAqL1xuICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT09ICdzdHJpbmcnXG4gICAgICA/IG1pbnBhdGguYmFzZW5hbWUodGhpcy5wYXRoKVxuICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFzZW5hbWUgKGluY2x1ZGluZyBleHRuYW1lKSAoYCdpbmRleC5taW4uanMnYCkuXG4gICAqXG4gICAqIENhbm5vdCBjb250YWluIHBhdGggc2VwYXJhdG9ycyAoYCcvJ2Agb24gdW5peCwgbWFjT1MsIGFuZCBicm93c2VycywgYCdcXCdgXG4gICAqIG9uIHdpbmRvd3MpLlxuICAgKiBDYW5ub3QgYmUgbnVsbGlmaWVkICh1c2UgYGZpbGUucGF0aCA9IGZpbGUuZGlybmFtZWAgaW5zdGVhZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlbmFtZVxuICAgKiAgIEJhc2VuYW1lLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICBzZXQgYmFzZW5hbWUoYmFzZW5hbWUpIHtcbiAgICBhc3NlcnROb25FbXB0eShiYXNlbmFtZSwgJ2Jhc2VuYW1lJylcbiAgICBhc3NlcnRQYXJ0KGJhc2VuYW1lLCAnYmFzZW5hbWUnKVxuICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbih0aGlzLmRpcm5hbWUgfHwgJycsIGJhc2VuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICogICBEaXJuYW1lLlxuICAgKi9cbiAgZ2V0IGRpcm5hbWUoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT09ICdzdHJpbmcnXG4gICAgICA/IG1pbnBhdGguZGlybmFtZSh0aGlzLnBhdGgpXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS5cbiAgICpcbiAgICogQ2Fubm90IGJlIHNldCBpZiB0aGVyZeKAmXMgbm8gYHBhdGhgIHlldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGRpcm5hbWVcbiAgICogICBEaXJuYW1lLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICBzZXQgZGlybmFtZShkaXJuYW1lKSB7XG4gICAgYXNzZXJ0UGF0aCh0aGlzLmJhc2VuYW1lLCAnZGlybmFtZScpXG4gICAgdGhpcy5wYXRoID0gbWlucGF0aC5qb2luKGRpcm5hbWUgfHwgJycsIHRoaXMuYmFzZW5hbWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRuYW1lIChpbmNsdWRpbmcgZG90KSAoZXhhbXBsZTogYCcuanMnYCkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAqICAgRXh0bmFtZS5cbiAgICovXG4gIGdldCBleHRuYW1lKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09PSAnc3RyaW5nJ1xuICAgICAgPyBtaW5wYXRoLmV4dG5hbWUodGhpcy5wYXRoKVxuICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGV4dG5hbWUgKGluY2x1ZGluZyBkb3QpIChleGFtcGxlOiBgJy5qcydgKS5cbiAgICpcbiAgICogQ2Fubm90IGNvbnRhaW4gcGF0aCBzZXBhcmF0b3JzIChgJy8nYCBvbiB1bml4LCBtYWNPUywgYW5kIGJyb3dzZXJzLCBgJ1xcJ2BcbiAgICogb24gd2luZG93cykuXG4gICAqIENhbm5vdCBiZSBzZXQgaWYgdGhlcmXigJlzIG5vIGBwYXRoYCB5ZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBleHRuYW1lXG4gICAqICAgRXh0bmFtZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgc2V0IGV4dG5hbWUoZXh0bmFtZSkge1xuICAgIGFzc2VydFBhcnQoZXh0bmFtZSwgJ2V4dG5hbWUnKVxuICAgIGFzc2VydFBhdGgodGhpcy5kaXJuYW1lLCAnZXh0bmFtZScpXG5cbiAgICBpZiAoZXh0bmFtZSkge1xuICAgICAgaWYgKGV4dG5hbWUuY29kZVBvaW50QXQoMCkgIT09IDQ2IC8qIGAuYCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHRuYW1lYCBtdXN0IHN0YXJ0IHdpdGggYC5gJylcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dG5hbWUuaW5jbHVkZXMoJy4nLCAxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHRuYW1lYCBjYW5ub3QgY29udGFpbiBtdWx0aXBsZSBkb3RzJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhdGggPSBtaW5wYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0aGlzLnN0ZW0gKyAoZXh0bmFtZSB8fCAnJykpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmdWxsIHBhdGggKGV4YW1wbGU6IGAnfi9pbmRleC5taW4uanMnYCkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqICAgUGF0aC5cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmdWxsIHBhdGggKGV4YW1wbGU6IGAnfi9pbmRleC5taW4uanMnYCkuXG4gICAqXG4gICAqIENhbm5vdCBiZSBudWxsaWZpZWQuXG4gICAqIFlvdSBjYW4gc2V0IGEgZmlsZSBVUkwgKGEgYFVSTGAgb2JqZWN0IHdpdGggYSBgZmlsZTpgIHByb3RvY29sKSB3aGljaCB3aWxsXG4gICAqIGJlIHR1cm5lZCBpbnRvIGEgcGF0aCB3aXRoIGB1cmwuZmlsZVVSTFRvUGF0aGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VVJMIHwgc3RyaW5nfSBwYXRoXG4gICAqICAgUGF0aC5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogICBOb3RoaW5nLlxuICAgKi9cbiAgc2V0IHBhdGgocGF0aCkge1xuICAgIGlmIChpc1VybChwYXRoKSkge1xuICAgICAgcGF0aCA9IHVybFRvUGF0aChwYXRoKVxuICAgIH1cblxuICAgIGFzc2VydE5vbkVtcHR5KHBhdGgsICdwYXRoJylcblxuICAgIGlmICh0aGlzLnBhdGggIT09IHBhdGgpIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHBhdGgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RlbSAoYmFzZW5hbWUgdy9vIGV4dG5hbWUpIChleGFtcGxlOiBgJ2luZGV4Lm1pbidgKS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAgICogICBTdGVtLlxuICAgKi9cbiAgZ2V0IHN0ZW0oKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT09ICdzdHJpbmcnXG4gICAgICA/IG1pbnBhdGguYmFzZW5hbWUodGhpcy5wYXRoLCB0aGlzLmV4dG5hbWUpXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RlbSAoYmFzZW5hbWUgdy9vIGV4dG5hbWUpIChleGFtcGxlOiBgJ2luZGV4Lm1pbidgKS5cbiAgICpcbiAgICogQ2Fubm90IGNvbnRhaW4gcGF0aCBzZXBhcmF0b3JzIChgJy8nYCBvbiB1bml4LCBtYWNPUywgYW5kIGJyb3dzZXJzLCBgJ1xcJ2BcbiAgICogb24gd2luZG93cykuXG4gICAqIENhbm5vdCBiZSBudWxsaWZpZWQgKHVzZSBgZmlsZS5wYXRoID0gZmlsZS5kaXJuYW1lYCBpbnN0ZWFkKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ZW1cbiAgICogICBTdGVtLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICBzZXQgc3RlbShzdGVtKSB7XG4gICAgYXNzZXJ0Tm9uRW1wdHkoc3RlbSwgJ3N0ZW0nKVxuICAgIGFzc2VydFBhcnQoc3RlbSwgJ3N0ZW0nKVxuICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbih0aGlzLmRpcm5hbWUgfHwgJycsIHN0ZW0gKyAodGhpcy5leHRuYW1lIHx8ICcnKSlcbiAgfVxuXG4gIC8vIE5vcm1hbCBwcm90b3R5cGFsIG1ldGhvZHMuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmYXRhbCBtZXNzYWdlIGZvciBgcmVhc29uYCBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gICAqXG4gICAqIFRoZSBgZmF0YWxgIGZpZWxkIG9mIHRoZSBtZXNzYWdlIGlzIHNldCB0byBgdHJ1ZWAgKGVycm9yOyBmaWxlIG5vdCB1c2FibGUpXG4gICAqIGFuZCB0aGUgYGZpbGVgIGZpZWxkIGlzIHNldCB0byB0aGUgY3VycmVudCBmaWxlIHBhdGguXG4gICAqIFRoZSBtZXNzYWdlIGlzIGFkZGVkIHRvIHRoZSBgbWVzc2FnZXNgIGZpZWxkIG9uIGBmaWxlYC5cbiAgICpcbiAgICogPiDwn6qmICoqTm90ZSoqOiBhbHNvIGhhcyBvYnNvbGV0ZSBzaWduYXR1cmVzLlxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKiBAcGFyYW0ge01lc3NhZ2VPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtuZXZlcn1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7bmV2ZXJ9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAqIEBwYXJhbSB7UG9pbnQgfCBQb3NpdGlvbiB8IG51bGwgfCB1bmRlZmluZWR9IHBsYWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogQHJldHVybnMge25ldmVyfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtuZXZlcn1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2V9IGNhdXNlXG4gICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFyZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogQHJldHVybnMge25ldmVyfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2VcbiAgICogQHBhcmFtIHtQb2ludCB8IFBvc2l0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGxhY2VcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7bmV2ZXJ9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtuZXZlcn1cbiAgICpcbiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZSB8IHN0cmluZ30gY2F1c2VPclJlYXNvblxuICAgKiAgIFJlYXNvbiBmb3IgbWVzc2FnZSwgc2hvdWxkIHVzZSBtYXJrZG93bi5cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBNZXNzYWdlT3B0aW9ucyB8IFBvaW50IHwgUG9zaXRpb24gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc09yUGFyZW50T3JQbGFjZV1cbiAgICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6XG4gICAqICAgYCdteS1wYWNrYWdlOm15LXJ1bGUnYCBvciBgJ215LXJ1bGUnYCkuXG4gICAqIEByZXR1cm5zIHtuZXZlcn1cbiAgICogICBOZXZlci5cbiAgICogQHRocm93cyB7VkZpbGVNZXNzYWdlfVxuICAgKiAgIE1lc3NhZ2UuXG4gICAqL1xuICBmYWlsKGNhdXNlT3JSZWFzb24sIG9wdGlvbnNPclBhcmVudE9yUGxhY2UsIG9yaWdpbikge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBvdmVybG9hZHMgYXJlIGZpbmUuXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZShjYXVzZU9yUmVhc29uLCBvcHRpb25zT3JQYXJlbnRPclBsYWNlLCBvcmlnaW4pXG5cbiAgICBtZXNzYWdlLmZhdGFsID0gdHJ1ZVxuXG4gICAgdGhyb3cgbWVzc2FnZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbmZvIG1lc3NhZ2UgZm9yIGByZWFzb25gIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS5cbiAgICpcbiAgICogVGhlIGBmYXRhbGAgZmllbGQgb2YgdGhlIG1lc3NhZ2UgaXMgc2V0IHRvIGB1bmRlZmluZWRgIChpbmZvOyBjaGFuZ2VcbiAgICogbGlrZWx5IG5vdCBuZWVkZWQpIGFuZCB0aGUgYGZpbGVgIGZpZWxkIGlzIHNldCB0byB0aGUgY3VycmVudCBmaWxlIHBhdGguXG4gICAqIFRoZSBtZXNzYWdlIGlzIGFkZGVkIHRvIHRoZSBgbWVzc2FnZXNgIGZpZWxkIG9uIGBmaWxlYC5cbiAgICpcbiAgICogPiDwn6qmICoqTm90ZSoqOiBhbHNvIGhhcyBvYnNvbGV0ZSBzaWduYXR1cmVzLlxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKiBAcGFyYW0ge01lc3NhZ2VPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFyZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICogQHBhcmFtIHtQb2ludCB8IFBvc2l0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGxhY2VcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZVxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZVxuICAgKiBAcGFyYW0ge1BvaW50IHwgUG9zaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkfSBwbGFjZVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2UgfCBzdHJpbmd9IGNhdXNlT3JSZWFzb25cbiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHNob3VsZCB1c2UgbWFya2Rvd24uXG4gICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgTWVzc2FnZU9wdGlvbnMgfCBQb2ludCB8IFBvc2l0aW9uIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNPclBhcmVudE9yUGxhY2VdXG4gICAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqICAgUGxhY2UgaW4gY29kZSB3aGVyZSB0aGUgbWVzc2FnZSBvcmlnaW5hdGVzIChleGFtcGxlOlxuICAgKiAgIGAnbXktcGFja2FnZTpteS1ydWxlJ2Agb3IgYCdteS1ydWxlJ2ApLlxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKiAgIE1lc3NhZ2UuXG4gICAqL1xuICBpbmZvKGNhdXNlT3JSZWFzb24sIG9wdGlvbnNPclBhcmVudE9yUGxhY2UsIG9yaWdpbikge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBvdmVybG9hZHMgYXJlIGZpbmUuXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZShjYXVzZU9yUmVhc29uLCBvcHRpb25zT3JQYXJlbnRPclBsYWNlLCBvcmlnaW4pXG5cbiAgICBtZXNzYWdlLmZhdGFsID0gdW5kZWZpbmVkXG5cbiAgICByZXR1cm4gbWVzc2FnZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UgZm9yIGByZWFzb25gIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS5cbiAgICpcbiAgICogVGhlIGBmYXRhbGAgZmllbGQgb2YgdGhlIG1lc3NhZ2UgaXMgc2V0IHRvIGBmYWxzZWAgKHdhcm5pbmc7IGNoYW5nZSBtYXkgYmVcbiAgICogbmVlZGVkKSBhbmQgdGhlIGBmaWxlYCBmaWVsZCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZmlsZSBwYXRoLlxuICAgKiBUaGUgbWVzc2FnZSBpcyBhZGRlZCB0byB0aGUgYG1lc3NhZ2VzYCBmaWVsZCBvbiBgZmlsZWAuXG4gICAqXG4gICAqID4g8J+qpiAqKk5vdGUqKjogYWxzbyBoYXMgb2Jzb2xldGUgc2lnbmF0dXJlcy5cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICogQHBhcmFtIHtNZXNzYWdlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAqIEBwYXJhbSB7UG9pbnQgfCBQb3NpdGlvbiB8IG51bGwgfCB1bmRlZmluZWR9IHBsYWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2VcbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2VcbiAgICogQHBhcmFtIHtQb2ludCB8IFBvc2l0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGxhY2VcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2VcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlIHwgc3RyaW5nfSBjYXVzZU9yUmVhc29uXG4gICAqICAgUmVhc29uIGZvciBtZXNzYWdlLCBzaG91bGQgdXNlIG1hcmtkb3duLlxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IE1lc3NhZ2VPcHRpb25zIHwgUG9pbnQgfCBQb3NpdGlvbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zT3JQYXJlbnRPclBsYWNlXVxuICAgKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiAgIFBsYWNlIGluIGNvZGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb3JpZ2luYXRlcyAoZXhhbXBsZTpcbiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS5cbiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX1cbiAgICogICBNZXNzYWdlLlxuICAgKi9cbiAgbWVzc2FnZShjYXVzZU9yUmVhc29uLCBvcHRpb25zT3JQYXJlbnRPclBsYWNlLCBvcmlnaW4pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZShcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBvdmVybG9hZHMgYXJlIGZpbmUuXG4gICAgICBjYXVzZU9yUmVhc29uLFxuICAgICAgb3B0aW9uc09yUGFyZW50T3JQbGFjZSxcbiAgICAgIG9yaWdpblxuICAgIClcblxuICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgIG1lc3NhZ2UubmFtZSA9IHRoaXMucGF0aCArICc6JyArIG1lc3NhZ2UubmFtZVxuICAgICAgbWVzc2FnZS5maWxlID0gdGhpcy5wYXRoXG4gICAgfVxuXG4gICAgbWVzc2FnZS5mYXRhbCA9IGZhbHNlXG5cbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSlcblxuICAgIHJldHVybiBtZXNzYWdlXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBmaWxlLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiB3aGljaCBlbmNvZGluZ3MgYXJlIHN1cHBvcnRlZCBkZXBlbmRzIG9uIHRoZSBlbmdpbmUuXG4gICAqID4gRm9yIGluZm8gb24gTm9kZS5qcywgc2VlOlxuICAgKiA+IDxodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN3aGF0d2ctc3VwcG9ydGVkLWVuY29kaW5ncz4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nPSd1dGY4J11cbiAgICogICBDaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdW5kZXJzdGFuZCBgdmFsdWVgIGFzIHdoZW4gaXTigJlzIGEgYFVpbnQ4QXJyYXlgXG4gICAqICAgKGRlZmF1bHQ6IGAndXRmLTgnYCkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqICAgU2VyaWFsaXplZCBmaWxlLlxuICAgKi9cbiAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcgfHwgdW5kZWZpbmVkKVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZSh0aGlzLnZhbHVlKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYHBhcnRgIGlzIG5vdCBhIHBhdGggKGFzIGluLCBkb2VzIG5vdCBjb250YWluIGBwYXRoLnNlcGApLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFydFxuICogICBGaWxlIHBhdGggcGFydC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgIFBhcnQgbmFtZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFBhcnQocGFydCwgbmFtZSkge1xuICBpZiAocGFydCAmJiBwYXJ0LmluY2x1ZGVzKG1pbnBhdGguc2VwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgJyArIG5hbWUgKyAnYCBjYW5ub3QgYmUgYSBwYXRoOiBkaWQgbm90IGV4cGVjdCBgJyArIG1pbnBhdGguc2VwICsgJ2AnXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYHBhcnRgIGlzIG5vdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcGFydFxuICogICBUaGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgIFBhcnQgbmFtZS5cbiAqIEByZXR1cm5zIHthc3NlcnRzIHBhcnQgaXMgc3RyaW5nfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnROb25FbXB0eShwYXJ0LCBuYW1lKSB7XG4gIGlmICghcGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBuYW1lICsgJ2AgY2Fubm90IGJlIGVtcHR5JylcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCBgcGF0aGAgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBwYXRoXG4gKiAgIFBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICBEZXBlbmRlbmN5IG5hbWUuXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBwYXRoIGlzIHN0cmluZ31cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoLCBuYW1lKSB7XG4gIGlmICghcGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2V0dGluZyBgJyArIG5hbWUgKyAnYCByZXF1aXJlcyBgcGF0aGAgdG8gYmUgc2V0IHRvbycpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYHZhbHVlYCBpcyBhbiBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogICB0aGluZy5cbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBVaW50OEFycmF5fVxuICogICBXaGV0aGVyIGB2YWx1ZWAgaXMgYW4gYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdieXRlTGVuZ3RoJyBpbiB2YWx1ZSAmJlxuICAgICAgJ2J5dGVPZmZzZXQnIGluIHZhbHVlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJWRmlsZU1lc3NhZ2UiLCJtaW5wYXRoIiwibWlucHJvYyIsInVybFRvUGF0aCIsImlzVXJsIiwib3JkZXIiLCJWRmlsZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJvcHRpb25zIiwicGF0aCIsImlzVWludDhBcnJheSIsImN3ZCIsImRhdGEiLCJoaXN0b3J5IiwibWVzc2FnZXMiLCJtYXAiLCJyZXN1bHQiLCJzdG9yZWQiLCJpbmRleCIsImxlbmd0aCIsImZpZWxkIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJiYXNlbmFtZSIsImFzc2VydE5vbkVtcHR5IiwiYXNzZXJ0UGFydCIsImpvaW4iLCJkaXJuYW1lIiwiYXNzZXJ0UGF0aCIsImV4dG5hbWUiLCJjb2RlUG9pbnRBdCIsIkVycm9yIiwic3RlbSIsInB1c2giLCJmYWlsIiwiY2F1c2VPclJlYXNvbiIsIm9wdGlvbnNPclBhcmVudE9yUGxhY2UiLCJvcmlnaW4iLCJtZXNzYWdlIiwiZmF0YWwiLCJpbmZvIiwibmFtZSIsImZpbGUiLCJ0b1N0cmluZyIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicGFydCIsInNlcCIsIkJvb2xlYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/minurl.shared.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rehype-pretty-code/node_modules/vfile/lib/minurl.shared.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isUrl: () => (/* binding */ isUrl)\n/* harmony export */ });\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * We check for auth attribute to distinguish legacy url instance with\n * WHATWG URL instance.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether its a URL.\n */ // From: <https://github.com/nodejs/node/blob/6a3403c/lib/internal/url.js#L720>\nfunction isUrl(fileUrlOrPath) {\n    return Boolean(fileUrlOrPath !== null && typeof fileUrlOrPath === \"object\" && \"href\" in fileUrlOrPath && fileUrlOrPath.href && \"protocol\" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.\n    fileUrlOrPath.auth === undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL25vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWludXJsLnNoYXJlZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsK0VBQStFO0FBQ3hFLFNBQVNBLE1BQU1DLGFBQWE7SUFDakMsT0FBT0MsUUFDTEQsa0JBQWtCLFFBQ2hCLE9BQU9BLGtCQUFrQixZQUN6QixVQUFVQSxpQkFDVkEsY0FBY0UsSUFBSSxJQUNsQixjQUFjRixpQkFDZEEsY0FBY0csUUFBUSxJQUN0QixzQ0FBc0M7SUFDdENILGNBQWNJLElBQUksS0FBS0M7QUFFN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWN1cml0eS1ibG9nLy4vbm9kZV9tb2R1bGVzL3JlaHlwZS1wcmV0dHktY29kZS9ub2RlX21vZHVsZXMvdmZpbGUvbGliL21pbnVybC5zaGFyZWQuanM/NjM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGhhcyB0aGUgc2hhcGUgb2YgYSBXSEFUV0cgVVJMIG9iamVjdC5cbiAqXG4gKiBVc2luZyBhIHN5bWJvbCBvciBpbnN0YW5jZW9mIHdvdWxkIG5vdCBiZSBhYmxlIHRvIHJlY29nbml6ZSBVUkwgb2JqZWN0c1xuICogY29taW5nIGZyb20gb3RoZXIgaW1wbGVtZW50YXRpb25zIChlLmcuIGluIEVsZWN0cm9uKSwgc28gaW5zdGVhZCB3ZSBhcmVcbiAqIGNoZWNraW5nIHNvbWUgd2VsbCBrbm93biBwcm9wZXJ0aWVzIGZvciBhIGxhY2sgb2YgYSBiZXR0ZXIgdGVzdC5cbiAqXG4gKiBXZSB1c2UgYGhyZWZgIGFuZCBgcHJvdG9jb2xgIGFzIHRoZXkgYXJlIHRoZSBvbmx5IHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIGVhc3kgdG8gcmV0cmlldmUgYW5kIGNhbGN1bGF0ZSBkdWUgdG8gdGhlIGxhenkgbmF0dXJlIG9mIHRoZSBnZXR0ZXJzLlxuICpcbiAqIFdlIGNoZWNrIGZvciBhdXRoIGF0dHJpYnV0ZSB0byBkaXN0aW5ndWlzaCBsZWdhY3kgdXJsIGluc3RhbmNlIHdpdGhcbiAqIFdIQVRXRyBVUkwgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBmaWxlVXJsT3JQYXRoXG4gKiAgIEZpbGUgcGF0aCBvciBVUkwuXG4gKiBAcmV0dXJucyB7ZmlsZVVybE9yUGF0aCBpcyBVUkx9XG4gKiAgIFdoZXRoZXIgaXTigJlzIGEgVVJMLlxuICovXG4vLyBGcm9tOiA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNmEzNDAzYy9saWIvaW50ZXJuYWwvdXJsLmpzI0w3MjA+XG5leHBvcnQgZnVuY3Rpb24gaXNVcmwoZmlsZVVybE9yUGF0aCkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBmaWxlVXJsT3JQYXRoICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgZmlsZVVybE9yUGF0aCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdocmVmJyBpbiBmaWxlVXJsT3JQYXRoICYmXG4gICAgICBmaWxlVXJsT3JQYXRoLmhyZWYgJiZcbiAgICAgICdwcm90b2NvbCcgaW4gZmlsZVVybE9yUGF0aCAmJlxuICAgICAgZmlsZVVybE9yUGF0aC5wcm90b2NvbCAmJlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhpbmcgaXMgZmluZS5cbiAgICAgIGZpbGVVcmxPclBhdGguYXV0aCA9PT0gdW5kZWZpbmVkXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJpc1VybCIsImZpbGVVcmxPclBhdGgiLCJCb29sZWFuIiwiaHJlZiIsInByb3RvY29sIiwiYXV0aCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/node_modules/vfile/lib/minurl.shared.js\n");

/***/ })

};
;