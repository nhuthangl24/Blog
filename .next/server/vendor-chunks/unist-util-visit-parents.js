"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unist-util-visit-parents";
exports.ids = ["vendor-chunks/unist-util-visit-parents"];
exports.modules = {

/***/ "(rsc)/./node_modules/unist-util-visit-parents/lib/color.node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/color.node.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color)\n/* harmony export */ });\n/**\n * @param {string} d\n * @returns {string}\n */ function color(d) {\n    return \"\\x1b[33m\" + d + \"\\x1b[39m\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2xpYi9jb2xvci5ub2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDTSxTQUFTQSxNQUFNQyxDQUFDO0lBQ3JCLE9BQU8sYUFBZUEsSUFBSTtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlY3VyaXR5LWJsb2cvLi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2xpYi9jb2xvci5ub2RlLmpzP2VhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKGQpIHtcbiAgcmV0dXJuICdcXHUwMDFCWzMzbScgKyBkICsgJ1xcdTAwMUJbMzltJ1xufVxuIl0sIm5hbWVzIjpbImNvbG9yIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unist-util-visit-parents/lib/color.node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/unist-util-visit-parents/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTINUE: () => (/* binding */ CONTINUE),\n/* harmony export */   EXIT: () => (/* binding */ EXIT),\n/* harmony export */   SKIP: () => (/* binding */ SKIP),\n/* harmony export */   visitParents: () => (/* binding */ visitParents)\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"(rsc)/./node_modules/unist-util-visit-parents/node_modules/unist-util-is/lib/index.js\");\n/* harmony import */ var unist_util_visit_parents_do_not_use_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit-parents/do-not-use-color */ \"(rsc)/./node_modules/unist-util-visit-parents/lib/color.node.js\");\n/**\n * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\n */ /**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */ /**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */ /**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */ /**\n * @typedef {(\n *   Check extends ReadonlyArray<infer T>\n *   ? MatchesOne<Value, T>\n *   : Check extends Array<infer T>\n *   ? MatchesOne<Value, T>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */ /**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */ /**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */ /**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */ /**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */ /**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */ /**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */ /**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */ /**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */ /**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */ /**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */ \n\n/** @type {Readonly<ActionTuple>} */ const empty = [];\n/**\n * Continue traversing as normal.\n */ const CONTINUE = true;\n/**\n * Stop traversing immediately.\n */ const EXIT = false;\n/**\n * Do not traverse this nodeâ€™s children.\n */ const SKIP = \"skip\";\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */ function visitParents(tree, test, visitor, reverse) {\n    /** @type {Test} */ let check;\n    if (typeof test === \"function\" && typeof visitor !== \"function\") {\n        reverse = visitor;\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test;\n    } else {\n        // @ts-expect-error visitor given, so `test` isnâ€™t a visitor.\n        check = test;\n    }\n    const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(check);\n    const step = reverse ? -1 : 1;\n    factory(tree, undefined, [])();\n    /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */ function factory(node, index, parents) {\n        const value = /** @type {Record<string, unknown>} */ node && typeof node === \"object\" ? node : {};\n        if (typeof value.type === \"string\") {\n            const name = // `hast`\n            typeof value.tagName === \"string\" ? value.tagName : typeof value.name === \"string\" ? value.name : undefined;\n            Object.defineProperty(visit, \"name\", {\n                value: \"node (\" + (0,unist_util_visit_parents_do_not_use_color__WEBPACK_IMPORTED_MODULE_1__.color)(node.type + (name ? \"<\" + name + \">\" : \"\")) + \")\"\n            });\n        }\n        return visit;\n        function visit() {\n            /** @type {Readonly<ActionTuple>} */ let result = empty;\n            /** @type {Readonly<ActionTuple>} */ let subresult;\n            /** @type {number} */ let offset;\n            /** @type {Array<UnistParent>} */ let grandparents;\n            if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n                // @ts-expect-error: `visitor` is now a visitor.\n                result = toResult(visitor(node, parents));\n                if (result[0] === EXIT) {\n                    return result;\n                }\n            }\n            if (\"children\" in node && node.children) {\n                const nodeAsParent = /** @type {UnistParent} */ node;\n                if (nodeAsParent.children && result[0] !== SKIP) {\n                    offset = (reverse ? nodeAsParent.children.length : -1) + step;\n                    grandparents = parents.concat(nodeAsParent);\n                    while(offset > -1 && offset < nodeAsParent.children.length){\n                        const child = nodeAsParent.children[offset];\n                        subresult = factory(child, offset, grandparents)();\n                        if (subresult[0] === EXIT) {\n                            return subresult;\n                        }\n                        offset = typeof subresult[1] === \"number\" ? subresult[1] : offset + step;\n                    }\n                }\n            }\n            return result;\n        }\n    }\n}\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */ function toResult(value) {\n    if (Array.isArray(value)) {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return [\n            CONTINUE,\n            value\n        ];\n    }\n    return value === null || value === undefined ? empty : [\n        value\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVEOzs7Q0FHQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFRDs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFb0M7QUFDMEI7QUFFL0Qsa0NBQWtDLEdBQ2xDLE1BQU1FLFFBQVEsRUFBRTtBQUVoQjs7Q0FFQyxHQUNNLE1BQU1DLFdBQVcsS0FBSTtBQUU1Qjs7Q0FFQyxHQUNNLE1BQU1DLE9BQU8sTUFBSztBQUV6Qjs7Q0FFQyxHQUNNLE1BQU1DLE9BQU8sT0FBTTtBQUUxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThDQyxHQUNNLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDdkQsaUJBQWlCLEdBQ2pCLElBQUlDO0lBRUosSUFBSSxPQUFPSCxTQUFTLGNBQWMsT0FBT0MsWUFBWSxZQUFZO1FBQy9EQyxVQUFVRDtRQUNWLDJEQUEyRDtRQUMzREEsVUFBVUQ7SUFDWixPQUFPO1FBQ0wsNkRBQTZEO1FBQzdERyxRQUFRSDtJQUNWO0lBRUEsTUFBTUksS0FBS1osc0RBQU9BLENBQUNXO0lBQ25CLE1BQU1FLE9BQU9ILFVBQVUsQ0FBQyxJQUFJO0lBRTVCSSxRQUFRUCxNQUFNUSxXQUFXLEVBQUU7SUFFM0I7Ozs7R0FJQyxHQUNELFNBQVNELFFBQVFFLElBQUksRUFBRUMsS0FBSyxFQUFFQyxPQUFPO1FBQ25DLE1BQU1DLFFBQVEsb0NBQW9DLEdBQ2hESCxRQUFRLE9BQU9BLFNBQVMsV0FBV0EsT0FBTyxDQUFDO1FBRzdDLElBQUksT0FBT0csTUFBTUMsSUFBSSxLQUFLLFVBQVU7WUFDbEMsTUFBTUMsT0FDSixTQUFTO1lBQ1QsT0FBT0YsTUFBTUcsT0FBTyxLQUFLLFdBQ3JCSCxNQUFNRyxPQUFPLEdBRWIsT0FBT0gsTUFBTUUsSUFBSSxLQUFLLFdBQ3BCRixNQUFNRSxJQUFJLEdBQ1ZOO1lBRVJRLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxRQUFRO2dCQUNuQ04sT0FDRSxXQUFXbEIsZ0ZBQUtBLENBQUNlLEtBQUtJLElBQUksR0FBSUMsQ0FBQUEsT0FBTyxNQUFNQSxPQUFPLE1BQU0sRUFBQyxLQUFNO1lBQ25FO1FBQ0Y7UUFFQSxPQUFPSTtRQUVQLFNBQVNBO1lBQ1Asa0NBQWtDLEdBQ2xDLElBQUlDLFNBQVN4QjtZQUNiLGtDQUFrQyxHQUNsQyxJQUFJeUI7WUFDSixtQkFBbUIsR0FDbkIsSUFBSUM7WUFDSiwrQkFBK0IsR0FDL0IsSUFBSUM7WUFFSixJQUFJLENBQUNyQixRQUFRSSxHQUFHSSxNQUFNQyxPQUFPQyxPQUFPLENBQUNBLFFBQVFZLE1BQU0sR0FBRyxFQUFFLElBQUlmLFlBQVk7Z0JBQ3RFLGdEQUFnRDtnQkFDaERXLFNBQVNLLFNBQVN0QixRQUFRTyxNQUFNRTtnQkFFaEMsSUFBSVEsTUFBTSxDQUFDLEVBQUUsS0FBS3RCLE1BQU07b0JBQ3RCLE9BQU9zQjtnQkFDVDtZQUNGO1lBRUEsSUFBSSxjQUFjVixRQUFRQSxLQUFLZ0IsUUFBUSxFQUFFO2dCQUN2QyxNQUFNQyxlQUFlLHdCQUF3QixHQUFJakI7Z0JBRWpELElBQUlpQixhQUFhRCxRQUFRLElBQUlOLE1BQU0sQ0FBQyxFQUFFLEtBQUtyQixNQUFNO29CQUMvQ3VCLFNBQVMsQ0FBQ2xCLFVBQVV1QixhQUFhRCxRQUFRLENBQUNGLE1BQU0sR0FBRyxDQUFDLEtBQUtqQjtvQkFDekRnQixlQUFlWCxRQUFRZ0IsTUFBTSxDQUFDRDtvQkFFOUIsTUFBT0wsU0FBUyxDQUFDLEtBQUtBLFNBQVNLLGFBQWFELFFBQVEsQ0FBQ0YsTUFBTSxDQUFFO3dCQUMzRCxNQUFNSyxRQUFRRixhQUFhRCxRQUFRLENBQUNKLE9BQU87d0JBRTNDRCxZQUFZYixRQUFRcUIsT0FBT1AsUUFBUUM7d0JBRW5DLElBQUlGLFNBQVMsQ0FBQyxFQUFFLEtBQUt2QixNQUFNOzRCQUN6QixPQUFPdUI7d0JBQ1Q7d0JBRUFDLFNBQ0UsT0FBT0QsU0FBUyxDQUFDLEVBQUUsS0FBSyxXQUFXQSxTQUFTLENBQUMsRUFBRSxHQUFHQyxTQUFTZjtvQkFDL0Q7Z0JBQ0Y7WUFDRjtZQUVBLE9BQU9hO1FBQ1Q7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNLLFNBQVNaLEtBQUs7SUFDckIsSUFBSWlCLE1BQU1DLE9BQU8sQ0FBQ2xCLFFBQVE7UUFDeEIsT0FBT0E7SUFDVDtJQUVBLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE9BQU87WUFBQ2hCO1lBQVVnQjtTQUFNO0lBQzFCO0lBRUEsT0FBT0EsVUFBVSxRQUFRQSxVQUFVSixZQUFZYixRQUFRO1FBQUNpQjtLQUFNO0FBQ2hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktYmxvZy8uL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvbGliL2luZGV4LmpzP2EwM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtOb2RlIGFzIFVuaXN0Tm9kZSwgUGFyZW50IGFzIFVuaXN0UGFyZW50fSBmcm9tICd1bmlzdCdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFeGNsdWRlPGltcG9ydCgndW5pc3QtdXRpbC1pcycpLlRlc3QsIHVuZGVmaW5lZD4gfCB1bmRlZmluZWR9IFRlc3RcbiAqICAgVGVzdCBmcm9tIGB1bmlzdC11dGlsLWlzYC5cbiAqXG4gKiAgIE5vdGU6IHdlIGhhdmUgcmVtb3ZlIGFuZCBhZGQgYHVuZGVmaW5lZGAsIGJlY2F1c2Ugb3RoZXJ3aXNlIHdoZW4gZ2VuZXJhdGluZ1xuICogICBhdXRvbWF0aWMgYC5kLnRzYCBmaWxlcywgVFMgdHJpZXMgdG8gZmxhdHRlbiBwYXRocyBmcm9tIGEgbG9jYWwgcGVyc3BlY3RpdmUsXG4gKiAgIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdoZW4gcHVibGlzaGluZyBvbiBucG0uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBGbiBleHRlbmRzICh2YWx1ZTogYW55KSA9PiB2YWx1ZSBpcyBpbmZlciBUaGluZ1xuICogICA/IFRoaW5nXG4gKiAgIDogRmFsbGJhY2tcbiAqICl9IFByZWRpY2F0ZVxuICogICBHZXQgdGhlIHZhbHVlIG9mIGEgdHlwZSBndWFyZCBgRm5gLlxuICogQHRlbXBsYXRlIEZuXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgZnVuY3Rpb24gdGhhdCBpcyBhIHR5cGUgZ3VhcmQgKHN1Y2ggYXMgYCh4KTogeCBpcyBZYCkuXG4gKiBAdGVtcGxhdGUgRmFsbGJhY2tcbiAqICAgVmFsdWUgdG8geWllbGQgaWYgYEZuYCBpcyBub3QgYSB0eXBlIGd1YXJkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQ2hlY2sgZXh0ZW5kcyBudWxsIHwgdW5kZWZpbmVkIC8vIE5vIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBWYWx1ZSBleHRlbmRzIHt0eXBlOiBDaGVja30gLy8gU3RyaW5nICh0eXBlKSB0ZXN0LlxuICogICA/IFZhbHVlXG4gKiAgIDogVmFsdWUgZXh0ZW5kcyBDaGVjayAvLyBQYXJ0aWFsIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBDaGVjayBleHRlbmRzIEZ1bmN0aW9uIC8vIEZ1bmN0aW9uIHRlc3QuXG4gKiAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT4gZXh0ZW5kcyBWYWx1ZVxuICogICAgID8gUHJlZGljYXRlPENoZWNrLCBWYWx1ZT5cbiAqICAgICA6IG5ldmVyXG4gKiAgIDogbmV2ZXIgLy8gU29tZSBvdGhlciB0ZXN0P1xuICogKX0gTWF0Y2hlc09uZVxuICogICBDaGVjayB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIGEgcHJpbWl0aXZlIGNoZWNrIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSBWYWx1ZVxuICogICBWYWx1ZTsgdHlwaWNhbGx5IHVuaXN0IGBOb2RlYC5cbiAqIEB0ZW1wbGF0ZSBDaGVja1xuICogICBWYWx1ZTsgdHlwaWNhbGx5IGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QsIGJ1dCBub3QgYXJyYXlzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgQ2hlY2sgZXh0ZW5kcyBSZWFkb25seUFycmF5PGluZmVyIFQ+XG4gKiAgID8gTWF0Y2hlc09uZTxWYWx1ZSwgVD5cbiAqICAgOiBDaGVjayBleHRlbmRzIEFycmF5PGluZmVyIFQ+XG4gKiAgID8gTWF0Y2hlc09uZTxWYWx1ZSwgVD5cbiAqICAgOiBNYXRjaGVzT25lPFZhbHVlLCBDaGVjaz5cbiAqICl9IE1hdGNoZXNcbiAqICAgQ2hlY2sgd2hldGhlciBhIG5vZGUgbWF0Y2hlcyBhIGNoZWNrIGluIHRoZSB0eXBlIHN5c3RlbS5cbiAqIEB0ZW1wbGF0ZSBWYWx1ZVxuICogICBWYWx1ZTsgdHlwaWNhbGx5IHVuaXN0IGBOb2RlYC5cbiAqIEB0ZW1wbGF0ZSBDaGVja1xuICogICBWYWx1ZTsgdHlwaWNhbGx5IGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3QuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7MCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwfSBVaW50XG4gKiAgIE51bWJlcjsgY2FwcGVkIHJlYXNvbmFibHkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SSBleHRlbmRzIDAgPyAxIDogSSBleHRlbmRzIDEgPyAyIDogSSBleHRlbmRzIDIgPyAzIDogSSBleHRlbmRzIDMgPyA0IDogSSBleHRlbmRzIDQgPyA1IDogSSBleHRlbmRzIDUgPyA2IDogSSBleHRlbmRzIDYgPyA3IDogSSBleHRlbmRzIDcgPyA4IDogSSBleHRlbmRzIDggPyA5IDogMTB9IEluY3JlbWVudFxuICogICBJbmNyZW1lbnQgYSBudW1iZXIgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICogQHRlbXBsYXRlIHtVaW50fSBbST0wXVxuICogICBJbmRleC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIE5vZGUgZXh0ZW5kcyBVbmlzdFBhcmVudFxuICogICA/IE5vZGUgZXh0ZW5kcyB7Y2hpbGRyZW46IEFycmF5PGluZmVyIENoaWxkcmVuPn1cbiAqICAgICA/IENoaWxkIGV4dGVuZHMgQ2hpbGRyZW4gPyBOb2RlIDogbmV2ZXJcbiAqICAgICA6IG5ldmVyXG4gKiAgIDogbmV2ZXJcbiAqICl9IEludGVybmFsUGFyZW50XG4gKiAgIENvbGxlY3Qgbm9kZXMgdGhhdCBjYW4gYmUgcGFyZW50cyBvZiBgQ2hpbGRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IE5vZGVcbiAqICAgQWxsIG5vZGUgdHlwZXMgaW4gYSB0cmVlLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IENoaWxkXG4gKiAgIE5vZGUgdG8gc2VhcmNoIGZvci5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJbnRlcm5hbFBhcmVudDxJbmNsdXNpdmVEZXNjZW5kYW50PFRyZWU+LCBDaGlsZD59IFBhcmVudFxuICogICBDb2xsZWN0IG5vZGVzIGluIGBUcmVlYCB0aGF0IGNhbiBiZSBwYXJlbnRzIG9mIGBDaGlsZGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gVHJlZVxuICogICBBbGwgbm9kZSB0eXBlcyBpbiBhIHRyZWUuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gQ2hpbGRcbiAqICAgTm9kZSB0byBzZWFyY2ggZm9yLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgRGVwdGggZXh0ZW5kcyBNYXhcbiAqICAgPyBuZXZlclxuICogICA6XG4gKiAgICAgfCBJbnRlcm5hbFBhcmVudDxOb2RlLCBDaGlsZD5cbiAqICAgICB8IEludGVybmFsQW5jZXN0b3I8Tm9kZSwgSW50ZXJuYWxQYXJlbnQ8Tm9kZSwgQ2hpbGQ+LCBNYXgsIEluY3JlbWVudDxEZXB0aD4+XG4gKiApfSBJbnRlcm5hbEFuY2VzdG9yXG4gKiAgIENvbGxlY3Qgbm9kZXMgaW4gYFRyZWVgIHRoYXQgY2FuIGJlIGFuY2VzdG9ycyBvZiBgQ2hpbGRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IE5vZGVcbiAqICAgQWxsIG5vZGUgdHlwZXMgaW4gYSB0cmVlLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IENoaWxkXG4gKiAgIE5vZGUgdG8gc2VhcmNoIGZvci5cbiAqIEB0ZW1wbGF0ZSB7VWludH0gW01heD0xMF1cbiAqICAgTWF4OyBzZWFyY2hlcyB1cCB0byB0aGlzIGRlcHRoLlxuICogQHRlbXBsYXRlIHtVaW50fSBbRGVwdGg9MF1cbiAqICAgQ3VycmVudCBkZXB0aC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtJbnRlcm5hbEFuY2VzdG9yPEluY2x1c2l2ZURlc2NlbmRhbnQ8VHJlZT4sIENoaWxkPn0gQW5jZXN0b3JcbiAqICAgQ29sbGVjdCBub2RlcyBpbiBgVHJlZWAgdGhhdCBjYW4gYmUgYW5jZXN0b3JzIG9mIGBDaGlsZGAuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gVHJlZVxuICogICBBbGwgbm9kZSB0eXBlcyBpbiBhIHRyZWUuXG4gKiBAdGVtcGxhdGUge1VuaXN0Tm9kZX0gQ2hpbGRcbiAqICAgTm9kZSB0byBzZWFyY2ggZm9yLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgVHJlZSBleHRlbmRzIFVuaXN0UGFyZW50XG4gKiAgICAgPyBEZXB0aCBleHRlbmRzIE1heFxuICogICAgICAgPyBUcmVlXG4gKiAgICAgICA6IFRyZWUgfCBJbmNsdXNpdmVEZXNjZW5kYW50PFRyZWVbJ2NoaWxkcmVuJ11bbnVtYmVyXSwgTWF4LCBJbmNyZW1lbnQ8RGVwdGg+PlxuICogICAgIDogVHJlZVxuICogKX0gSW5jbHVzaXZlRGVzY2VuZGFudFxuICogICBDb2xsZWN0IGFsbCAoaW5jbHVzaXZlKSBkZXNjZW5kYW50cyBvZiBgVHJlZWAuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBmYXN0ZXN0IHdheSB0b1xuICogICA+IHJlY3Vyc2Ugd2l0aG91dCBhY3R1YWxseSBydW5uaW5nIGludG8gYW4gaW5maW5pdGUgbG9vcCwgd2hpY2ggdGhlXG4gKiAgID4gcHJldmlvdXMgdmVyc2lvbiBkaWQuXG4gKiAgID5cbiAqICAgPiBQcmFjdGljYWxseSwgYSBtYXggb2YgYDJgIGlzIHR5cGljYWxseSBlbm91Z2ggYXNzdW1pbmcgYSBgUm9vdGAgaXNcbiAqICAgPiBwYXNzZWQsIGJ1dCBpdCBkb2VzbuKAmXQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqICAgPiBJdCBnZXRzIGhpZ2hlciB3aXRoIGBMaXN0ID4gTGlzdEl0ZW0gPiBUYWJsZSA+IFRhYmxlUm93ID4gVGFibGVDZWxsYC5cbiAqICAgPiBVc2luZyB1cCB0byBgMTBgIGRvZXNu4oCZdCBodXJ0IG9yIGhlbHAgZWl0aGVyLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IFRyZWVcbiAqICAgVHJlZSB0eXBlLlxuICogQHRlbXBsYXRlIHtVaW50fSBbTWF4PTEwXVxuICogICBNYXg7IHNlYXJjaGVzIHVwIHRvIHRoaXMgZGVwdGguXG4gKiBAdGVtcGxhdGUge1VpbnR9IFtEZXB0aD0wXVxuICogICBDdXJyZW50IGRlcHRoLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydza2lwJyB8IGJvb2xlYW59IEFjdGlvblxuICogICBVbmlvbiBvZiB0aGUgYWN0aW9uIHR5cGVzLlxuICpcbiAqIEB0eXBlZGVmIHtudW1iZXJ9IEluZGV4XG4gKiAgIE1vdmUgdG8gdGhlIHNpYmxpbmcgYXQgYGluZGV4YCBuZXh0IChhZnRlciBub2RlIGl0c2VsZiBpcyBjb21wbGV0ZWx5XG4gKiAgIHRyYXZlcnNlZCkuXG4gKlxuICogICBVc2VmdWwgaWYgbXV0YXRpbmcgdGhlIHRyZWUsIHN1Y2ggYXMgcmVtb3ZpbmcgdGhlIG5vZGUgdGhlIHZpc2l0b3IgaXNcbiAqICAgY3VycmVudGx5IG9uLCBvciBhbnkgb2YgaXRzIHByZXZpb3VzIHNpYmxpbmdzLlxuICogICBSZXN1bHRzIGxlc3MgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgY2hpbGRyZW4ubGVuZ3RoYCBzdG9wXG4gKiAgIHRyYXZlcnNpbmcgdGhlIHBhcmVudC5cbiAqXG4gKiBAdHlwZWRlZiB7WyhBY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCk/LCAoSW5kZXggfCBudWxsIHwgdW5kZWZpbmVkKT9dfSBBY3Rpb25UdXBsZVxuICogICBMaXN0IHdpdGggb25lIG9yIHR3byB2YWx1ZXMsIHRoZSBmaXJzdCBhbiBhY3Rpb24sIHRoZSBzZWNvbmQgYW4gaW5kZXguXG4gKlxuICogQHR5cGVkZWYge0FjdGlvbiB8IEFjdGlvblR1cGxlIHwgSW5kZXggfCBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZH0gVmlzaXRvclJlc3VsdFxuICogICBBbnkgdmFsdWUgdGhhdCBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIHZpc2l0b3IuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVmlzaXRvclxuICogICBIYW5kbGUgYSBub2RlIChtYXRjaGluZyBgdGVzdGAsIGlmIGdpdmVuKS5cbiAqXG4gKiAgIFZpc2l0b3JzIGFyZSBmcmVlIHRvIHRyYW5zZm9ybSBgbm9kZWAuXG4gKiAgIFRoZXkgY2FuIGFsc28gdHJhbnNmb3JtIHRoZSBwYXJlbnQgb2Ygbm9kZSAodGhlIGxhc3Qgb2YgYGFuY2VzdG9yc2ApLlxuICpcbiAqICAgUmVwbGFjaW5nIGBub2RlYCBpdHNlbGYsIGlmIGBTS0lQYCBpcyBub3QgcmV0dXJuZWQsIHN0aWxsIGNhdXNlcyBpdHNcbiAqICAgZGVzY2VuZGFudHMgdG8gYmUgd2Fsa2VkICh3aGljaCBpcyBhIGJ1ZykuXG4gKlxuICogICBXaGVuIGFkZGluZyBvciByZW1vdmluZyBwcmV2aW91cyBzaWJsaW5ncyBvZiBgbm9kZWAgKG9yIG5leHQgc2libGluZ3MsIGluXG4gKiAgIGNhc2Ugb2YgcmV2ZXJzZSksIHRoZSBgVmlzaXRvcmAgc2hvdWxkIHJldHVybiBhIG5ldyBgSW5kZXhgIHRvIHNwZWNpZnkgdGhlXG4gKiAgIHNpYmxpbmcgdG8gdHJhdmVyc2UgYWZ0ZXIgYG5vZGVgIGlzIHRyYXZlcnNlZC5cbiAqICAgQWRkaW5nIG9yIHJlbW92aW5nIG5leHQgc2libGluZ3Mgb2YgYG5vZGVgIChvciBwcmV2aW91cyBzaWJsaW5ncywgaW4gY2FzZVxuICogICBvZiByZXZlcnNlKSBpcyBoYW5kbGVkIGFzIGV4cGVjdGVkIHdpdGhvdXQgbmVlZGluZyB0byByZXR1cm4gYSBuZXcgYEluZGV4YC5cbiAqXG4gKiAgIFJlbW92aW5nIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSBvZiBhbiBhbmNlc3RvciBzdGlsbCByZXN1bHRzIGluIHRoZW0gYmVpbmdcbiAqICAgdHJhdmVyc2VkLlxuICogQHBhcmFtIHtWaXNpdGVkfSBub2RlXG4gKiAgIEZvdW5kIG5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PFZpc2l0ZWRQYXJlbnRzPn0gYW5jZXN0b3JzXG4gKiAgIEFuY2VzdG9ycyBvZiBgbm9kZWAuXG4gKiBAcmV0dXJucyB7VmlzaXRvclJlc3VsdH1cbiAqICAgV2hhdCB0byBkbyBuZXh0LlxuICpcbiAqICAgQW4gYEluZGV4YCBpcyB0cmVhdGVkIGFzIGEgdHVwbGUgb2YgYFtDT05USU5VRSwgSW5kZXhdYC5cbiAqICAgQW4gYEFjdGlvbmAgaXMgdHJlYXRlZCBhcyBhIHR1cGxlIG9mIGBbQWN0aW9uXWAuXG4gKlxuICogICBQYXNzaW5nIGEgdHVwbGUgYmFjayBvbmx5IG1ha2VzIHNlbnNlIGlmIHRoZSBgQWN0aW9uYCBpcyBgU0tJUGAuXG4gKiAgIFdoZW4gdGhlIGBBY3Rpb25gIGlzIGBFWElUYCwgdGhhdCBhY3Rpb24gY2FuIGJlIHJldHVybmVkLlxuICogICBXaGVuIHRoZSBgQWN0aW9uYCBpcyBgQ09OVElOVUVgLCBgSW5kZXhgIGNhbiBiZSByZXR1cm5lZC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBbVmlzaXRlZD1VbmlzdE5vZGVdXG4gKiAgIFZpc2l0ZWQgbm9kZSB0eXBlLlxuICogQHRlbXBsYXRlIHtVbmlzdFBhcmVudH0gW1Zpc2l0ZWRQYXJlbnRzPVVuaXN0UGFyZW50XVxuICogICBBbmNlc3RvciB0eXBlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1Zpc2l0b3I8TWF0Y2hlczxJbmNsdXNpdmVEZXNjZW5kYW50PFRyZWU+LCBDaGVjaz4sIEFuY2VzdG9yPFRyZWUsIE1hdGNoZXM8SW5jbHVzaXZlRGVzY2VuZGFudDxUcmVlPiwgQ2hlY2s+Pj59IEJ1aWxkVmlzaXRvclxuICogICBCdWlsZCBhIHR5cGVkIGBWaXNpdG9yYCBmdW5jdGlvbiBmcm9tIGEgdHJlZSBhbmQgYSB0ZXN0LlxuICpcbiAqICAgSXQgd2lsbCBpbmZlciB3aGljaCB2YWx1ZXMgYXJlIHBhc3NlZCBhcyBgbm9kZWAgYW5kIHdoaWNoIGFzIGBwYXJlbnRzYC5cbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBbVHJlZT1VbmlzdE5vZGVdXG4gKiAgIFRyZWUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VGVzdH0gW0NoZWNrPVRlc3RdXG4gKiAgIFRlc3QgdHlwZS5cbiAqL1xuXG5pbXBvcnQge2NvbnZlcnR9IGZyb20gJ3VuaXN0LXV0aWwtaXMnXG5pbXBvcnQge2NvbG9yfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMvZG8tbm90LXVzZS1jb2xvcidcblxuLyoqIEB0eXBlIHtSZWFkb25seTxBY3Rpb25UdXBsZT59ICovXG5jb25zdCBlbXB0eSA9IFtdXG5cbi8qKlxuICogQ29udGludWUgdHJhdmVyc2luZyBhcyBub3JtYWwuXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IHRydWVcblxuLyoqXG4gKiBTdG9wIHRyYXZlcnNpbmcgaW1tZWRpYXRlbHkuXG4gKi9cbmV4cG9ydCBjb25zdCBFWElUID0gZmFsc2VcblxuLyoqXG4gKiBEbyBub3QgdHJhdmVyc2UgdGhpcyBub2Rl4oCZcyBjaGlsZHJlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IFNLSVAgPSAnc2tpcCdcblxuLyoqXG4gKiBWaXNpdCBub2Rlcywgd2l0aCBhbmNlc3RyYWwgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyBhbGdvcml0aG0gcGVyZm9ybXMgKmRlcHRoLWZpcnN0KiAqdHJlZSB0cmF2ZXJzYWwqIGluICpwcmVvcmRlcipcbiAqICgqKk5MUioqKSBvciBpZiBgcmV2ZXJzZWAgaXMgZ2l2ZW4sIGluICpyZXZlcnNlIHByZW9yZGVyKiAoKipOUkwqKikuXG4gKlxuICogWW91IGNhbiBjaG9vc2UgZm9yIHdoaWNoIG5vZGVzIGB2aXNpdG9yYCBpcyBjYWxsZWQgYnkgcGFzc2luZyBhIGB0ZXN0YC5cbiAqIEZvciBjb21wbGV4IHRlc3RzLCB5b3Ugc2hvdWxkIHRlc3QgeW91cnNlbGYgaW4gYHZpc2l0b3JgLCBhcyBpdCB3aWxsIGJlXG4gKiBmYXN0ZXIgYW5kIHdpbGwgaGF2ZSBpbXByb3ZlZCB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIFdhbGtpbmcgdGhlIHRyZWUgaXMgYW4gaW50ZW5zaXZlIHRhc2suXG4gKiBNYWtlIHVzZSBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgdmlzaXRvciB3aGVuIHBvc3NpYmxlLlxuICogSW5zdGVhZCBvZiB3YWxraW5nIGEgdHJlZSBtdWx0aXBsZSB0aW1lcywgd2FsayBpdCBvbmNlLCB1c2UgYHVuaXN0LXV0aWwtaXNgXG4gKiB0byBjaGVjayBpZiBhIG5vZGUgbWF0Y2hlcywgYW5kIHRoZW4gcGVyZm9ybSBkaWZmZXJlbnQgb3BlcmF0aW9ucy5cbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGUgdHJlZS5cbiAqIFNlZSBgVmlzaXRvcmAgZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7VHJlZX0gdHJlZVxuICogQHBhcmFtIHtDaGVja30gY2hlY2tcbiAqIEBwYXJhbSB7QnVpbGRWaXNpdG9yPFRyZWUsIENoZWNrPn0gdmlzaXRvclxuICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3JldmVyc2VdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtUcmVlfSB0cmVlXG4gKiBAcGFyYW0ge0J1aWxkVmlzaXRvcjxUcmVlPn0gdmlzaXRvclxuICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3JldmVyc2VdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICpcbiAqIEBwYXJhbSB7VW5pc3ROb2RlfSB0cmVlXG4gKiAgIFRyZWUgdG8gdHJhdmVyc2UuXG4gKiBAcGFyYW0ge1Zpc2l0b3IgfCBUZXN0fSB0ZXN0XG4gKiAgIGB1bmlzdC11dGlsLWlzYC1jb21wYXRpYmxlIHRlc3RcbiAqIEBwYXJhbSB7VmlzaXRvciB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdmlzaXRvcl1cbiAqICAgSGFuZGxlIGVhY2ggbm9kZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICogICBUcmF2ZXJzZSBpbiByZXZlcnNlIHByZW9yZGVyIChOUkwpIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgcHJlb3JkZXIgKE5MUikuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEB0ZW1wbGF0ZSB7VW5pc3ROb2RlfSBUcmVlXG4gKiAgIE5vZGUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSB7VGVzdH0gQ2hlY2tcbiAqICAgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0UGFyZW50cyh0cmVlLCB0ZXN0LCB2aXNpdG9yLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7VGVzdH0gKi9cbiAgbGV0IGNoZWNrXG5cbiAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2aXNpdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV2ZXJzZSA9IHZpc2l0b3JcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vIHZpc2l0b3IgZ2l2ZW4sIHNvIGB2aXNpdG9yYCBpcyB0ZXN0LlxuICAgIHZpc2l0b3IgPSB0ZXN0XG4gIH0gZWxzZSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB2aXNpdG9yIGdpdmVuLCBzbyBgdGVzdGAgaXNu4oCZdCBhIHZpc2l0b3IuXG4gICAgY2hlY2sgPSB0ZXN0XG4gIH1cblxuICBjb25zdCBpcyA9IGNvbnZlcnQoY2hlY2spXG4gIGNvbnN0IHN0ZXAgPSByZXZlcnNlID8gLTEgOiAxXG5cbiAgZmFjdG9yeSh0cmVlLCB1bmRlZmluZWQsIFtdKSgpXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VW5pc3ROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICAgKiBAcGFyYW0ge0FycmF5PFVuaXN0UGFyZW50Pn0gcGFyZW50c1xuICAgKi9cbiAgZnVuY3Rpb24gZmFjdG9yeShub2RlLCBpbmRleCwgcGFyZW50cykge1xuICAgIGNvbnN0IHZhbHVlID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi8gKFxuICAgICAgbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgPyBub2RlIDoge31cbiAgICApXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBuYW1lID1cbiAgICAgICAgLy8gYGhhc3RgXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50YWdOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gdmFsdWUudGFnTmFtZVxuICAgICAgICAgIDogLy8gYHhhc3RgXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdmFsdWUubmFtZVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpc2l0LCAnbmFtZScsIHtcbiAgICAgICAgdmFsdWU6XG4gICAgICAgICAgJ25vZGUgKCcgKyBjb2xvcihub2RlLnR5cGUgKyAobmFtZSA/ICc8JyArIG5hbWUgKyAnPicgOiAnJykpICsgJyknXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB2aXNpdFxuXG4gICAgZnVuY3Rpb24gdmlzaXQoKSB7XG4gICAgICAvKiogQHR5cGUge1JlYWRvbmx5PEFjdGlvblR1cGxlPn0gKi9cbiAgICAgIGxldCByZXN1bHQgPSBlbXB0eVxuICAgICAgLyoqIEB0eXBlIHtSZWFkb25seTxBY3Rpb25UdXBsZT59ICovXG4gICAgICBsZXQgc3VicmVzdWx0XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIGxldCBvZmZzZXRcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8VW5pc3RQYXJlbnQ+fSAqL1xuICAgICAgbGV0IGdyYW5kcGFyZW50c1xuXG4gICAgICBpZiAoIXRlc3QgfHwgaXMobm9kZSwgaW5kZXgsIHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSB8fCB1bmRlZmluZWQpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGB2aXNpdG9yYCBpcyBub3cgYSB2aXNpdG9yLlxuICAgICAgICByZXN1bHQgPSB0b1Jlc3VsdCh2aXNpdG9yKG5vZGUsIHBhcmVudHMpKVxuXG4gICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCdjaGlsZHJlbicgaW4gbm9kZSAmJiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IG5vZGVBc1BhcmVudCA9IC8qKiBAdHlwZSB7VW5pc3RQYXJlbnR9ICovIChub2RlKVxuXG4gICAgICAgIGlmIChub2RlQXNQYXJlbnQuY2hpbGRyZW4gJiYgcmVzdWx0WzBdICE9PSBTS0lQKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gKHJldmVyc2UgPyBub2RlQXNQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIDogLTEpICsgc3RlcFxuICAgICAgICAgIGdyYW5kcGFyZW50cyA9IHBhcmVudHMuY29uY2F0KG5vZGVBc1BhcmVudClcblxuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPiAtMSAmJiBvZmZzZXQgPCBub2RlQXNQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGVBc1BhcmVudC5jaGlsZHJlbltvZmZzZXRdXG5cbiAgICAgICAgICAgIHN1YnJlc3VsdCA9IGZhY3RvcnkoY2hpbGQsIG9mZnNldCwgZ3JhbmRwYXJlbnRzKSgpXG5cbiAgICAgICAgICAgIGlmIChzdWJyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN1YnJlc3VsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPVxuICAgICAgICAgICAgICB0eXBlb2Ygc3VicmVzdWx0WzFdID09PSAnbnVtYmVyJyA/IHN1YnJlc3VsdFsxXSA6IG9mZnNldCArIHN0ZXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFR1cm4gYSByZXR1cm4gdmFsdWUgaW50byBhIGNsZWFuIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge1Zpc2l0b3JSZXN1bHR9IHZhbHVlXG4gKiAgIFZhbGlkIHJldHVybiB2YWx1ZXMgZnJvbSB2aXNpdG9ycy5cbiAqIEByZXR1cm5zIHtSZWFkb25seTxBY3Rpb25UdXBsZT59XG4gKiAgIENsZWFuIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gdG9SZXN1bHQodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbQ09OVElOVUUsIHZhbHVlXVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eSA6IFt2YWx1ZV1cbn1cbiJdLCJuYW1lcyI6WyJjb252ZXJ0IiwiY29sb3IiLCJlbXB0eSIsIkNPTlRJTlVFIiwiRVhJVCIsIlNLSVAiLCJ2aXNpdFBhcmVudHMiLCJ0cmVlIiwidGVzdCIsInZpc2l0b3IiLCJyZXZlcnNlIiwiY2hlY2siLCJpcyIsInN0ZXAiLCJmYWN0b3J5IiwidW5kZWZpbmVkIiwibm9kZSIsImluZGV4IiwicGFyZW50cyIsInZhbHVlIiwidHlwZSIsIm5hbWUiLCJ0YWdOYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2aXNpdCIsInJlc3VsdCIsInN1YnJlc3VsdCIsIm9mZnNldCIsImdyYW5kcGFyZW50cyIsImxlbmd0aCIsInRvUmVzdWx0IiwiY2hpbGRyZW4iLCJub2RlQXNQYXJlbnQiLCJjb25jYXQiLCJjaGlsZCIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unist-util-visit-parents/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/unist-util-visit-parents/node_modules/unist-util-is/lib/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/unist-util-visit-parents/node_modules/unist-util-is/lib/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   is: () => (/* binding */ is)\n/* harmony export */ });\n/**\n * @import {Node, Parent} from 'unist'\n */ /**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */ /**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | ReadonlyArray<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */ /**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodeâ€™s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */ const is = // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n/**\n   * @type {(\n   *   (<Condition extends ReadonlyArray<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends Array<string>>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition[number]}) &\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */ /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */ // eslint-disable-next-line max-params\nfunction(node, test, index, parent, context) {\n    const check = convert(test);\n    if (index !== undefined && index !== null && (typeof index !== \"number\" || index < 0 || index === Number.POSITIVE_INFINITY)) {\n        throw new Error(\"Expected positive finite index\");\n    }\n    if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n        throw new Error(\"Expected parent node\");\n    }\n    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n        throw new Error(\"Expected both parent and index\");\n    }\n    return looksLikeANode(node) ? check.call(context, node, index, parent) : false;\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */ const convert = // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n/**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */ /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */ function(test) {\n    if (test === null || test === undefined) {\n        return ok;\n    }\n    if (typeof test === \"function\") {\n        return castFactory(test);\n    }\n    if (typeof test === \"object\") {\n        return Array.isArray(test) ? anyFactory(test) : // narrows to `Array`.\n        propertiesFactory(/** @type {Props} */ test);\n    }\n    if (typeof test === \"string\") {\n        return typeFactory(test);\n    }\n    throw new Error(\"Expected function, string, or object as test\");\n};\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */ function anyFactory(tests) {\n    /** @type {Array<Check>} */ const checks = [];\n    let index = -1;\n    while(++index < tests.length){\n        checks[index] = convert(tests[index]);\n    }\n    return castFactory(any);\n    /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */ function any(...parameters) {\n        let index = -1;\n        while(++index < checks.length){\n            if (checks[index].apply(this, parameters)) return true;\n        }\n        return false;\n    }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */ function propertiesFactory(check) {\n    const checkAsRecord = /** @type {Record<string, unknown>} */ check;\n    return castFactory(all);\n    /**\n   * @param {Node} node\n   * @returns {boolean}\n   */ function all(node) {\n        const nodeAsRecord = /** @type {unknown} */ node;\n        /** @type {string} */ let key;\n        for(key in check){\n            if (nodeAsRecord[key] !== checkAsRecord[key]) return false;\n        }\n        return true;\n    }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */ function typeFactory(check) {\n    return castFactory(type);\n    /**\n   * @param {Node} node\n   */ function type(node) {\n        return node && node.type === check;\n    }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */ function castFactory(testFunction) {\n    return check;\n    /**\n   * @this {unknown}\n   * @type {Check}\n   */ function check(value, index, parent) {\n        return Boolean(looksLikeANode(value) && testFunction.call(this, value, typeof index === \"number\" ? index : undefined, parent || undefined));\n    }\n}\nfunction ok() {\n    return true;\n}\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */ function looksLikeANode(value) {\n    return value !== null && typeof value === \"object\" && \"type\" in value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLWlzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNQSxLQUNYLGlFQUFpRTtBQUNqRTs7Ozs7Ozs7Ozs7R0FXQyxHQUVDOzs7Ozs7O0tBT0MsR0FDRCxzQ0FBc0M7QUFDdEMsU0FBVUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQzFDLE1BQU1DLFFBQVFDLFFBQVFMO0lBRXRCLElBQ0VDLFVBQVVLLGFBQ1ZMLFVBQVUsUUFDVCxRQUFPQSxVQUFVLFlBQ2hCQSxRQUFRLEtBQ1JBLFVBQVVNLE9BQU9DLGlCQUFpQixHQUNwQztRQUNBLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLElBQ0VQLFdBQVdJLGFBQ1hKLFdBQVcsUUFDVixFQUFDSixHQUFHSSxXQUFXLENBQUNBLE9BQU9RLFFBQVEsR0FDaEM7UUFDQSxNQUFNLElBQUlELE1BQU07SUFDbEI7SUFFQSxJQUNFLENBQUNQLFdBQVdJLGFBQWFKLFdBQVcsSUFBRyxNQUN0Q0QsQ0FBQUEsVUFBVUssYUFBYUwsVUFBVSxJQUFHLEdBQ3JDO1FBQ0EsTUFBTSxJQUFJUSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0UsZUFBZVosUUFDbEJLLE1BQU1RLElBQUksQ0FBQ1QsU0FBU0osTUFBTUUsT0FBT0MsVUFDakM7QUFDTixFQUNEO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sTUFBTUcsVUFDWCxpRUFBaUU7QUFDakU7Ozs7Ozs7O0dBUUMsR0FFQzs7O0tBR0MsR0FDRCxTQUFVTCxJQUFJO0lBQ1osSUFBSUEsU0FBUyxRQUFRQSxTQUFTTSxXQUFXO1FBQ3ZDLE9BQU9PO0lBQ1Q7SUFFQSxJQUFJLE9BQU9iLFNBQVMsWUFBWTtRQUM5QixPQUFPYyxZQUFZZDtJQUNyQjtJQUVBLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzVCLE9BQU9lLE1BQU1DLE9BQU8sQ0FBQ2hCLFFBQ2pCaUIsV0FBV2pCLFFBRVgsc0JBQXNCO1FBQ3RCa0Isa0JBQWtCLGtCQUFrQixHQUFJbEI7SUFDOUM7SUFFQSxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixPQUFPbUIsWUFBWW5CO0lBQ3JCO0lBRUEsTUFBTSxJQUFJUyxNQUFNO0FBQ2xCLEVBQ0Q7QUFFSDs7O0NBR0MsR0FDRCxTQUFTUSxXQUFXRyxLQUFLO0lBQ3ZCLHlCQUF5QixHQUN6QixNQUFNQyxTQUFTLEVBQUU7SUFDakIsSUFBSXBCLFFBQVEsQ0FBQztJQUViLE1BQU8sRUFBRUEsUUFBUW1CLE1BQU1FLE1BQU0sQ0FBRTtRQUM3QkQsTUFBTSxDQUFDcEIsTUFBTSxHQUFHSSxRQUFRZSxLQUFLLENBQUNuQixNQUFNO0lBQ3RDO0lBRUEsT0FBT2EsWUFBWVM7SUFFbkI7OztHQUdDLEdBQ0QsU0FBU0EsSUFBSSxHQUFHQyxVQUFVO1FBQ3hCLElBQUl2QixRQUFRLENBQUM7UUFFYixNQUFPLEVBQUVBLFFBQVFvQixPQUFPQyxNQUFNLENBQUU7WUFDOUIsSUFBSUQsTUFBTSxDQUFDcEIsTUFBTSxDQUFDd0IsS0FBSyxDQUFDLElBQUksRUFBRUQsYUFBYSxPQUFPO1FBQ3BEO1FBRUEsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNOLGtCQUFrQmQsS0FBSztJQUM5QixNQUFNc0IsZ0JBQWdCLG9DQUFvQyxHQUFJdEI7SUFFOUQsT0FBT1UsWUFBWWE7SUFFbkI7OztHQUdDLEdBQ0QsU0FBU0EsSUFBSTVCLElBQUk7UUFDZixNQUFNNkIsZUFDSixvQkFBb0IsR0FBSTdCO1FBRzFCLG1CQUFtQixHQUNuQixJQUFJOEI7UUFFSixJQUFLQSxPQUFPekIsTUFBTztZQUNqQixJQUFJd0IsWUFBWSxDQUFDQyxJQUFJLEtBQUtILGFBQWEsQ0FBQ0csSUFBSSxFQUFFLE9BQU87UUFDdkQ7UUFFQSxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1YsWUFBWWYsS0FBSztJQUN4QixPQUFPVSxZQUFZZ0I7SUFFbkI7O0dBRUMsR0FDRCxTQUFTQSxLQUFLL0IsSUFBSTtRQUNoQixPQUFPQSxRQUFRQSxLQUFLK0IsSUFBSSxLQUFLMUI7SUFDL0I7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1UsWUFBWWlCLFlBQVk7SUFDL0IsT0FBTzNCO0lBRVA7OztHQUdDLEdBQ0QsU0FBU0EsTUFBTTRCLEtBQUssRUFBRS9CLEtBQUssRUFBRUMsTUFBTTtRQUNqQyxPQUFPK0IsUUFDTHRCLGVBQWVxQixVQUNiRCxhQUFhbkIsSUFBSSxDQUNmLElBQUksRUFDSm9CLE9BQ0EsT0FBTy9CLFVBQVUsV0FBV0EsUUFBUUssV0FDcENKLFVBQVVJO0lBR2xCO0FBQ0Y7QUFFQSxTQUFTTztJQUNQLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNGLGVBQWVxQixLQUFLO0lBQzNCLE9BQU9BLFVBQVUsUUFBUSxPQUFPQSxVQUFVLFlBQVksVUFBVUE7QUFDbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWN1cml0eS1ibG9nLy4vbm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cy9ub2RlX21vZHVsZXMvdW5pc3QtdXRpbC1pcy9saWIvaW5kZXguanM/YjBkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge05vZGUsIFBhcmVudH0gZnJvbSAndW5pc3QnXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgRm5cbiAqIEB0ZW1wbGF0ZSBGYWxsYmFja1xuICogQHR5cGVkZWYge0ZuIGV4dGVuZHMgKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIGluZmVyIFRoaW5nID8gVGhpbmcgOiBGYWxsYmFja30gUHJlZGljYXRlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQ2hlY2tcbiAqICAgQ2hlY2sgdGhhdCBhbiBhcmJpdHJhcnkgdmFsdWUgaXMgYSBub2RlLlxuICogQHBhcmFtIHt1bmtub3dufSB0aGlzXG4gKiAgIFRoZSBnaXZlbiBjb250ZXh0LlxuICogQHBhcmFtIHt1bmtub3dufSBbbm9kZV1cbiAqICAgQW55dGhpbmcgKHR5cGljYWxseSBhIG5vZGUpLlxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gKiAgIFRoZSBub2Rl4oCZcyBwb3NpdGlvbiBpbiBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFyZW50XVxuICogICBUaGUgbm9kZeKAmXMgcGFyZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhpcyBpcyBhIG5vZGUgYW5kIHBhc3NlcyBhIHRlc3QuXG4gKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHVua25vd24+IHwgTm9kZX0gUHJvcHNcbiAqICAgT2JqZWN0IHRvIGNoZWNrIGZvciBlcXVpdmFsZW5jZS5cbiAqXG4gKiAgIE5vdGU6IGBOb2RlYCBpcyBpbmNsdWRlZCBhcyBpdCBpcyBjb21tb24gYnV0IGlzIG5vdCBpbmRleGFibGUuXG4gKlxuICogQHR5cGVkZWYge0FycmF5PFByb3BzIHwgVGVzdEZ1bmN0aW9uIHwgc3RyaW5nPiB8IFJlYWRvbmx5QXJyYXk8UHJvcHMgfCBUZXN0RnVuY3Rpb24gfCBzdHJpbmc+IHwgUHJvcHMgfCBUZXN0RnVuY3Rpb24gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBUZXN0XG4gKiAgIENoZWNrIGZvciBhbiBhcmJpdHJhcnkgbm9kZS5cbiAqXG4gKiBAY2FsbGJhY2sgVGVzdEZ1bmN0aW9uXG4gKiAgIENoZWNrIGlmIGEgbm9kZSBwYXNzZXMgYSB0ZXN0LlxuICogQHBhcmFtIHt1bmtub3dufSB0aGlzXG4gKiAgIFRoZSBnaXZlbiBjb250ZXh0LlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiAgIEEgbm9kZS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gKiAgIFRoZSBub2Rl4oCZcyBwb3NpdGlvbiBpbiBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnQgfCB1bmRlZmluZWR9IFtwYXJlbnRdXG4gKiAgIFRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZCB8IHZvaWR9XG4gKiAgIFdoZXRoZXIgdGhpcyBub2RlIHBhc3NlcyB0aGUgdGVzdC5cbiAqXG4gKiAgIE5vdGU6IGB2b2lkYCBpcyBpbmNsdWRlZCB1bnRpbCBUUyBzZWVzIG5vIHJldHVybiBhcyBgdW5kZWZpbmVkYC5cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGBub2RlYCBpcyBhIGBOb2RlYCBhbmQgd2hldGhlciBpdCBwYXNzZXMgdGhlIGdpdmVuIHRlc3QuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBub2RlXG4gKiAgIFRoaW5nIHRvIGNoZWNrLCB0eXBpY2FsbHkgYE5vZGVgLlxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gKiAgIEEgY2hlY2sgZm9yIGEgc3BlY2lmaWMgbm9kZS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgVGhlIG5vZGXigJlzIHBvc2l0aW9uIGluIGl0cyBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBUaGUgbm9kZeKAmXMgcGFyZW50LlxuICogQHBhcmFtIHt1bmtub3dufSBjb250ZXh0XG4gKiAgIENvbnRleHQgb2JqZWN0IChgdGhpc2ApIHRvIHBhc3MgdG8gYHRlc3RgIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIGBub2RlYCBpcyBhIG5vZGUgYW5kIHBhc3NlcyBhIHRlc3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpcyA9XG4gIC8vIE5vdGU6IG92ZXJsb2FkcyBpbiBKU0RvYyBjYW7igJl0IHlldCB1c2UgZGlmZmVyZW50IGBAdGVtcGxhdGVgcy5cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxDb25kaXRpb24gZXh0ZW5kcyBSZWFkb25seUFycmF5PHN0cmluZz4+KG5vZGU6IHVua25vd24sIHRlc3Q6IENvbmRpdGlvbiwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gbm9kZSBpcyBOb2RlICYge3R5cGU6IENvbmRpdGlvbltudW1iZXJdfSkgJlxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgQXJyYXk8c3RyaW5nPj4obm9kZTogdW5rbm93biwgdGVzdDogQ29uZGl0aW9uLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBub2RlIGlzIE5vZGUgJiB7dHlwZTogQ29uZGl0aW9uW251bWJlcl19KSAmXG4gICAqICAgKDxDb25kaXRpb24gZXh0ZW5kcyBzdHJpbmc+KG5vZGU6IHVua25vd24sIHRlc3Q6IENvbmRpdGlvbiwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gbm9kZSBpcyBOb2RlICYge3R5cGU6IENvbmRpdGlvbn0pICZcbiAgICogICAoPENvbmRpdGlvbiBleHRlbmRzIFByb3BzPihub2RlOiB1bmtub3duLCB0ZXN0OiBDb25kaXRpb24sIGluZGV4PzogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50IHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IG5vZGUgaXMgTm9kZSAmIENvbmRpdGlvbikgJlxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgVGVzdEZ1bmN0aW9uPihub2RlOiB1bmtub3duLCB0ZXN0OiBDb25kaXRpb24sIGluZGV4PzogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50IHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IG5vZGUgaXMgTm9kZSAmIFByZWRpY2F0ZTxDb25kaXRpb24sIE5vZGU+KSAmXG4gICAqICAgKChub2RlPzogbnVsbCB8IHVuZGVmaW5lZCkgPT4gZmFsc2UpICZcbiAgICogICAoKG5vZGU6IHVua25vd24sIHRlc3Q/OiBudWxsIHwgdW5kZWZpbmVkLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBub2RlIGlzIE5vZGUpICZcbiAgICogICAoKG5vZGU6IHVua25vd24sIHRlc3Q/OiBUZXN0LCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBib29sZWFuKVxuICAgKiApfVxuICAgKi9cbiAgKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7dW5rbm93bn0gW25vZGVdXG4gICAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICAgKiBAcGFyYW0ge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IFtpbmRleF1cbiAgICAgKiBAcGFyYW0ge1BhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXJlbnRdXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuICAgIGZ1bmN0aW9uIChub2RlLCB0ZXN0LCBpbmRleCwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBjaGVjayA9IGNvbnZlcnQodGVzdClcblxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGluZGV4ICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgaW5kZXggPCAwIHx8XG4gICAgICAgICAgaW5kZXggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvc2l0aXZlIGZpbml0ZSBpbmRleCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcGFyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcGFyZW50ICE9PSBudWxsICYmXG4gICAgICAgICghaXMocGFyZW50KSB8fCAhcGFyZW50LmNoaWxkcmVuKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IG5vZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnQgPT09IG51bGwpICE9PVxuICAgICAgICAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA9PT0gbnVsbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJvdGggcGFyZW50IGFuZCBpbmRleCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb29rc0xpa2VBTm9kZShub2RlKVxuICAgICAgICA/IGNoZWNrLmNhbGwoY29udGV4dCwgbm9kZSwgaW5kZXgsIHBhcmVudClcbiAgICAgICAgOiBmYWxzZVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGFzc2VydGlvbiBmcm9tIGEgdGVzdC5cbiAqXG4gKiBVc2VmdWwgaWYgeW914oCZcmUgZ29pbmcgdG8gdGVzdCBtYW55IG5vZGVzLCBmb3IgZXhhbXBsZSB3aGVuIGNyZWF0aW5nIGFcbiAqIHV0aWxpdHkgd2hlcmUgc29tZXRoaW5nIGVsc2UgcGFzc2VzIGEgY29tcGF0aWJsZSB0ZXN0LlxuICpcbiAqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGEgYml0IGZhc3RlciBiZWNhdXNlIGl0IGV4cGVjdHMgdmFsaWQgaW5wdXQgb25seTpcbiAqIGEgYG5vZGVgLCBgaW5kZXhgLCBhbmQgYHBhcmVudGAuXG4gKlxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gKiAgICogICB3aGVuIG51bGxpc2gsIGNoZWNrcyBpZiBgbm9kZWAgaXMgYSBgTm9kZWAuXG4gKiAgICogICB3aGVuIGBzdHJpbmdgLCB3b3JrcyBsaWtlIHBhc3NpbmcgYChub2RlKSA9PiBub2RlLnR5cGUgPT09IHRlc3RgLlxuICogICAqICAgd2hlbiBgZnVuY3Rpb25gIGNoZWNrcyBpZiBmdW5jdGlvbiBwYXNzZWQgdGhlIG5vZGUgaXMgdHJ1ZS5cbiAqICAgKiAgIHdoZW4gYG9iamVjdGAsIGNoZWNrcyB0aGF0IGFsbCBrZXlzIGluIHRlc3QgYXJlIGluIG5vZGUsIGFuZCB0aGF0IHRoZXkgaGF2ZSAoc3RyaWN0bHkpIGVxdWFsIHZhbHVlcy5cbiAqICAgKiAgIHdoZW4gYGFycmF5YCwgY2hlY2tzIGlmIGFueSBvbmUgb2YgdGhlIHN1YnRlc3RzIHBhc3MuXG4gKiBAcmV0dXJucyB7Q2hlY2t9XG4gKiAgIEFuIGFzc2VydGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnQgPVxuICAvLyBOb3RlOiBvdmVybG9hZHMgaW4gSlNEb2MgY2Fu4oCZdCB5ZXQgdXNlIGRpZmZlcmVudCBgQHRlbXBsYXRlYHMuXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgc3RyaW5nPih0ZXN0OiBDb25kaXRpb24pID0+IChub2RlOiB1bmtub3duLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBub2RlIGlzIE5vZGUgJiB7dHlwZTogQ29uZGl0aW9ufSkgJlxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgUHJvcHM+KHRlc3Q6IENvbmRpdGlvbikgPT4gKG5vZGU6IHVua25vd24sIGluZGV4PzogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50IHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IG5vZGUgaXMgTm9kZSAmIENvbmRpdGlvbikgJlxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgVGVzdEZ1bmN0aW9uPih0ZXN0OiBDb25kaXRpb24pID0+IChub2RlOiB1bmtub3duLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudCB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBub2RlIGlzIE5vZGUgJiBQcmVkaWNhdGU8Q29uZGl0aW9uLCBOb2RlPikgJlxuICAgKiAgICgodGVzdD86IG51bGwgfCB1bmRlZmluZWQpID0+IChub2RlPzogdW5rbm93biwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gbm9kZSBpcyBOb2RlKSAmXG4gICAqICAgKCh0ZXN0PzogVGVzdCkgPT4gQ2hlY2spXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICAgKiBAcmV0dXJucyB7Q2hlY2t9XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAgIGlmICh0ZXN0ID09PSBudWxsIHx8IHRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2tcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjYXN0RmFjdG9yeSh0ZXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRlc3QpXG4gICAgICAgICAgPyBhbnlGYWN0b3J5KHRlc3QpXG4gICAgICAgICAgOiAvLyBDYXN0IGJlY2F1c2UgYFJlYWRvbmx5QXJyYXlgIGdvZXMgaW50byB0aGUgYWJvdmUgYnV0IGBpc0FycmF5YFxuICAgICAgICAgICAgLy8gbmFycm93cyB0byBgQXJyYXlgLlxuICAgICAgICAgICAgcHJvcGVydGllc0ZhY3RvcnkoLyoqIEB0eXBlIHtQcm9wc30gKi8gKHRlc3QpKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlRmFjdG9yeSh0ZXN0KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGZ1bmN0aW9uLCBzdHJpbmcsIG9yIG9iamVjdCBhcyB0ZXN0JylcbiAgICB9XG4gIClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb3BzIHwgVGVzdEZ1bmN0aW9uIHwgc3RyaW5nPn0gdGVzdHNcbiAqIEByZXR1cm5zIHtDaGVja31cbiAqL1xuZnVuY3Rpb24gYW55RmFjdG9yeSh0ZXN0cykge1xuICAvKiogQHR5cGUge0FycmF5PENoZWNrPn0gKi9cbiAgY29uc3QgY2hlY2tzID0gW11cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IHRlc3RzLmxlbmd0aCkge1xuICAgIGNoZWNrc1tpbmRleF0gPSBjb252ZXJ0KHRlc3RzW2luZGV4XSlcbiAgfVxuXG4gIHJldHVybiBjYXN0RmFjdG9yeShhbnkpXG5cbiAgLyoqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiBAdHlwZSB7VGVzdEZ1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gYW55KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGVja3MubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hlY2tzW2luZGV4XS5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKSkgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFR1cm4gYW4gb2JqZWN0IGludG8gYSB0ZXN0IGZvciBhIG5vZGUgd2l0aCBhIGNlcnRhaW4gZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7UHJvcHN9IGNoZWNrXG4gKiBAcmV0dXJucyB7Q2hlY2t9XG4gKi9cbmZ1bmN0aW9uIHByb3BlcnRpZXNGYWN0b3J5KGNoZWNrKSB7XG4gIGNvbnN0IGNoZWNrQXNSZWNvcmQgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqLyAoY2hlY2spXG5cbiAgcmV0dXJuIGNhc3RGYWN0b3J5KGFsbClcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYWxsKG5vZGUpIHtcbiAgICBjb25zdCBub2RlQXNSZWNvcmQgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqLyAoXG4gICAgICAvKiogQHR5cGUge3Vua25vd259ICovIChub2RlKVxuICAgIClcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGZvciAoa2V5IGluIGNoZWNrKSB7XG4gICAgICBpZiAobm9kZUFzUmVjb3JkW2tleV0gIT09IGNoZWNrQXNSZWNvcmRba2V5XSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vKipcbiAqIFR1cm4gYSBzdHJpbmcgaW50byBhIHRlc3QgZm9yIGEgbm9kZSB3aXRoIGEgY2VydGFpbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGVja1xuICogQHJldHVybnMge0NoZWNrfVxuICovXG5mdW5jdGlvbiB0eXBlRmFjdG9yeShjaGVjaykge1xuICByZXR1cm4gY2FzdEZhY3RvcnkodHlwZSlcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiB0eXBlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnR5cGUgPT09IGNoZWNrXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgY3VzdG9tIHRlc3QgaW50byBhIHRlc3QgZm9yIGEgbm9kZSB0aGF0IHBhc3NlcyB0aGF0IHRlc3QuXG4gKlxuICogQHBhcmFtIHtUZXN0RnVuY3Rpb259IHRlc3RGdW5jdGlvblxuICogQHJldHVybnMge0NoZWNrfVxuICovXG5mdW5jdGlvbiBjYXN0RmFjdG9yeSh0ZXN0RnVuY3Rpb24pIHtcbiAgcmV0dXJuIGNoZWNrXG5cbiAgLyoqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiBAdHlwZSB7Q2hlY2t9XG4gICAqL1xuICBmdW5jdGlvbiBjaGVjayh2YWx1ZSwgaW5kZXgsIHBhcmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgbG9va3NMaWtlQU5vZGUodmFsdWUpICYmXG4gICAgICAgIHRlc3RGdW5jdGlvbi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyA/IGluZGV4IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmVudCB8fCB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBvaygpIHtcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgTm9kZX1cbiAqL1xuZnVuY3Rpb24gbG9va3NMaWtlQU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ3R5cGUnIGluIHZhbHVlXG59XG4iXSwibmFtZXMiOlsiaXMiLCJub2RlIiwidGVzdCIsImluZGV4IiwicGFyZW50IiwiY29udGV4dCIsImNoZWNrIiwiY29udmVydCIsInVuZGVmaW5lZCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiRXJyb3IiLCJjaGlsZHJlbiIsImxvb2tzTGlrZUFOb2RlIiwiY2FsbCIsIm9rIiwiY2FzdEZhY3RvcnkiLCJBcnJheSIsImlzQXJyYXkiLCJhbnlGYWN0b3J5IiwicHJvcGVydGllc0ZhY3RvcnkiLCJ0eXBlRmFjdG9yeSIsInRlc3RzIiwiY2hlY2tzIiwibGVuZ3RoIiwiYW55IiwicGFyYW1ldGVycyIsImFwcGx5IiwiY2hlY2tBc1JlY29yZCIsImFsbCIsIm5vZGVBc1JlY29yZCIsImtleSIsInR5cGUiLCJ0ZXN0RnVuY3Rpb24iLCJ2YWx1ZSIsIkJvb2xlYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/unist-util-visit-parents/node_modules/unist-util-is/lib/index.js\n");

/***/ })

};
;